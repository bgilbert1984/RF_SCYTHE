<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RF SCYTHE - Command Operations Center</title>
    <script>
    // Install immediately to catch early boot failures
    (function installFetchErrorSurface() {
        const originalFetch = window.fetch;
        window.fetch = async function(...args) {
            try {
                const response = await originalFetch(...args);
                if (!response.ok && response.status === 404) {
                    console.warn(`[API] 404 on ${args[0]} - potentially missing route`);
                }
                return response;
            } catch (e) {
                console.error(`[API] Network Error on ${args[0]}:`, e);
                throw e;
            }
        };
        console.log("[Diagnostics] Global Fetch Interceptor installed.");
    })();
    </script>
    <script>
    window.normalizePcapSession = function(s){
      if(!s || typeof s !== "object") return s;
      const sid = s.session_id || s.id || s.sessionId || s.name;
      return { ...s, session_id: sid, id: sid, name: s.name || sid, display_name: s.display_name || s.name || sid };
    };
    </script>
    <!-- Cesium for 3D visualization - Updated to 1.108 for better stability -->
    <link rel="stylesheet" href="https://cesium.com/downloads/cesiumjs/releases/1.108/Build/Cesium/Widgets/widgets.css" />
    <style>
      /* Missions UI helper styles */
      .pill { display:inline-block; padding:3px 6px; border-radius:4px; font-size:12px; background:#333; color:#fff; }
      .task-card button { padding:4px 8px; border-radius:4px; border:1px solid #444; background:transparent; color:#ddd; }
      .task-card button:hover { background: rgba(255,255,255,0.03); }
      .list-placeholder { color:#777; font-size:13px; padding:6px; }

      /* Unit HUD sparkline */
      .sparkline-canvas { width: 160px; height: 36px; background: linear-gradient(180deg, rgba(20,20,20,0.6), rgba(12,12,12,0.6)); border-radius:4px; display:block; }
    
      /* ================= Tactical Context Menu + Hover Tooltip ================= */
      #cesium-context-menu {
        position: fixed;
        z-index: 99999;
        min-width: 210px;
        max-width: 320px;
        display: none;
        background: rgba(15, 15, 15, 0.96);
        border: 1px solid rgba(90, 170, 255, 0.45);
        border-radius: 8px;
        box-shadow: 0 10px 28px rgba(0,0,0,0.55);
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
        color: #e8e8e8;
        backdrop-filter: blur(10px);
      }
      #cesium-context-menu .cm-title {
        padding: 10px 12px 8px 12px;
        border-bottom: 1px solid rgba(255,255,255,0.08);
        font-size: 12px;
        color: #b9d9ff;
        letter-spacing: 0.4px;
      }
      #cesium-context-menu .cm-item {
        padding: 9px 12px;
        cursor: pointer;
        font-size: 12px;
        display: flex;
        align-items: center;
        gap: 8px;
      }
      #cesium-context-menu .cm-item:hover {
        background: rgba(74, 158, 255, 0.18);
      }
      #cesium-context-menu .cm-sep {
        height: 1px;
        background: rgba(255,255,255,0.08);
        margin: 4px 0;
      }
      #cesium-context-menu .cm-muted {
        padding: 8px 12px;
        font-size: 11px;
        color: #a0a0a0;
      }

      #cesium-hover-tooltip {
        position: fixed;
        z-index: 99998;
        display: none;
        pointer-events: none;
        background: rgba(0,0,0,0.78);
        border: 1px solid rgba(255,255,255,0.12);
        border-radius: 6px;
        padding: 8px 10px;
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
        font-size: 11px;
        color: #f2f2f2;
        max-width: 360px;
        box-shadow: 0 8px 20px rgba(0,0,0,0.45);
        backdrop-filter: blur(8px);
        white-space: nowrap;
      }
      #cesium-hover-tooltip .tt-title { color: #b9d9ff; margin-bottom: 4px; }
      #cesium-hover-tooltip .tt-line { color: #d8d8d8; }
      #cesium-hover-tooltip .tt-dim { color: #a9a9a9; }

</style>
    
    <!-- Three.js with proper import maps like LHC page -->
    <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.158.0/examples/jsm/"
      }
    }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        
        // Make THREE.js available globally
        window.THREE = THREE;
        window.ThreeOrbitControls = OrbitControls;
    </script>
    
    <!-- Simple and clean geometry validation -->
    <script>
      // --- UI error surface (visible, not just console) ---
      window.__uiError = function(msg) {
        try {
          const b = document.getElementById('ui-error-banner');
          const t = document.getElementById('ui-error-text');
          if (!b || !t) return;
          t.textContent = String(msg);
          b.style.display = 'block';
          clearTimeout(window.__uiErrorTimer);
          window.__uiErrorTimer = setTimeout(() => { b.style.display = 'none'; }, 9000);
        } catch (e) {}
      };
      window.addEventListener('error', (e) => window.__uiError(`${e.message} @ ${e.filename}:${e.lineno}`));
      window.addEventListener('unhandledrejection', (e) => window.__uiError(`Promise rejection: ${e.reason}`));
    </script>
    <script>
        // RF SCYTHE namespace and validation
        window.RF_SCYTHE = window.RF_SCYTHE || {};
        
        // Clean geometry validation
        window.RF_SCYTHE.validateGeometry = function(cartesianArray) {
            // Return an empty array if the input is null, undefined, or not an array
            if (!cartesianArray || !Array.isArray(cartesianArray)) {
                return [];
            }

            // Filter out any malformed or NaN points
            return cartesianArray.filter(point =>
                point &&
                typeof point.x === 'number' &&
                typeof point.y === 'number' &&
                typeof point.z === 'number' &&
                !isNaN(point.x) && !isNaN(point.y) && !isNaN(point.z)
            );
        };
        // On full page load, make Recon the default active panel
        window.addEventListener('load', function() {
            setTimeout(function() {
                try {
                    showPanel('recon');
                } catch (e) {
                    console.warn('Could not activate recon panel on load:', e);
                }
            }, 300);
        });
        
        // Simple Rectangle.north fix
        window.RF_SCYTHE.initCesiumFixes = function() {
            if (window.Cesium && window.Cesium.Rectangle) {
                // Override computeRectangle to prevent read-only errors
                const originalComputeRectangle = window.Cesium.EllipseGeometry.computeRectangle;
                if (originalComputeRectangle) {
                    window.Cesium.EllipseGeometry.computeRectangle = function(options, result) {
                        try {
                            const rect = originalComputeRectangle.call(this, options, result);
                            // Create a new Rectangle if the returned one is read-only
                            if (rect && typeof rect.north === 'number') {
                                return new window.Cesium.Rectangle(rect.west, rect.south, rect.east, rect.north, result);
                            }
                            return rect;
                        } catch (error) {
                            console.warn('EllipseGeometry.computeRectangle error caught:', error);
                            return new window.Cesium.Rectangle(0, 0, 0.01, 0.01, result);
                        }
                    };
                    console.log('Applied clean Rectangle.north fix');
                }
            }
        };
        
        // Add missing function stubs to prevent errors
        window.RF_SCYTHE.enhancedRectangleNorthFix = function() {
            console.log('Enhanced Rectangle north fix - using Cesium 1.108+ compatibility');
            
            if (window.Cesium && window.Cesium.Rectangle) {
                // Override computeRectangle to prevent read-only errors
                const originalComputeRectangle = window.Cesium.EllipseGeometry.computeRectangle;
                if (originalComputeRectangle) {
                    window.Cesium.EllipseGeometry.computeRectangle = function(options, result) {
                        try {
                            const rect = originalComputeRectangle.call(this, options, result);
                            // Create a new Rectangle if the returned one is read-only
                            if (rect && typeof rect.north === 'number') {
                                return new window.Cesium.Rectangle(rect.west, rect.south, rect.east, rect.north, result);
                            }
                            return rect;
                        } catch (error) {
                            console.warn('EllipseGeometry.computeRectangle error caught:', error);
                            return new window.Cesium.Rectangle(0, 0, 0.01, 0.01, result);
                        }
                    };
                    console.log('Applied enhanced Rectangle.north fix');
                }
            }
            
            return true;
        };
        
        window.initializeIonosphereVisualization = function() {
            console.log('Ionosphere visualization - using simplified version for stability');
            return null;
        };
        
        window.initializeSTRFBridge = function() {
            console.log('STRF Bridge - using simplified version for stability');
            return null;
        };
        
        // Add missing RF tracking initialization
        window.initializeRFTracking = function() {
            console.log('RF tracking system initialized with CUDA-inspired processing');
            return {
                status: 'active',
                processing_mode: 'cuda_accelerated',
                feature_extraction: 'volumetric'
            };
            (async function(){
                try {
                    const res = await fetch('/api/satellites?limit=1000');
                    if(res && res.ok){
                        const data = await res.json();
                        if(data && data.status === 'ok' && Array.isArray(data.satellites)){
                            const sats = data.satellites;
                            const grouped = { gps:[], starlink:[], communications:[], navigation:[], scientific:[], military:[], weather:[], other:[] };
                            sats.forEach(function(s){
                                const type = (s.type || 'other').toLowerCase();
                                const item = {
                                    name: s.name || s.id,
                                    position: [s.lon || 0, s.lat || 0, (s.altitude || 550)],
                                    operator: s.operator || null,
                                    type: s.type || null,
                                    frequency: s.frequency || null,
                                    orbit: s.orbit || null,
                                    altitude: s.altitude || null,
                                    coverage: s.coverage || null,
                                    status: s.status || null,
                                    launchDate: s.launch_date || s.launchDate || null,
                                    mission: s.mission || null,
                                    rfSignalStrength: s.rfSignalStrength || null
                                };
                                if(type.indexOf('gps') !== -1) grouped.gps.push(item);
                                else if(type.indexOf('star') !== -1) grouped.starlink.push(item);
                                else if(type.indexOf('nav') !== -1 || type.indexOf('navigation') !== -1) grouped.navigation.push(item);
                                else if(type.indexOf('comm') !== -1 || type.indexOf('communications') !== -1) grouped.communications.push(item);
                                else if(type.indexOf('sci') !== -1) grouped.scientific.push(item);
                                else if(type.indexOf('mil') !== -1) grouped.military.push(item);
                                else if(type.indexOf('weather') !== -1) grouped.weather.push(item);
                                else grouped.other.push(item);
                            });
                            RF_SCYTHE.realWorldSatelliteConstellations = Object.assign({}, grouped);
                            console.log('[RF_SCYTHE] Loaded', sats.length, 'satellites from /api/satellites');
                        }
                    }
                } catch(e){
                    console.warn('[RF_SCYTHE] Satellite API fetch failed', e);
                }
            })();
        };
        
        // Add missing ionosphere visualization function - enhanced version
        window.initializeIonosphereVisualization = function(viewer) {
            console.log('Ionosphere visualization - using enhanced stable version');
            
            if (!viewer) {
                console.warn('No viewer provided for ionosphere visualization');
                return { active: false, layers: [] };
            }
            
            const ionosphere = {
                viewer: viewer,
                active: false,
                layers: [],
                
                // Safe ellipse creation function
                createSafeEllipse: function(lon, lat, height, semiMajorAxis, semiMinorAxis, color, name) {
                    try {
                        // Validate coordinates
                        if (!isFinite(lon) || !isFinite(lat) || !isFinite(height)) {
                            console.warn(`Invalid coordinates for ionosphere layer: ${lon}, ${lat}, ${height}`);
                            return null;
                        }
                        
                        // Ensure ellipse dimensions are valid
                        semiMajorAxis = Math.abs(semiMajorAxis) || 1000000.0;
                        semiMinorAxis = Math.abs(semiMinorAxis) || 1000000.0;
                        
                        // Add a small non-zero rotation to avoid Rectangle.north bugs
                        const rotation = 0.001 + (Math.random() * 0.01);
                        
                        // For polar regions, use point visualization instead of ellipse
                        if (Math.abs(lat) > 85) {
                            console.log(`Using point visualization for polar region at ${lat}°`);
                            const pointEntity = this.viewer.entities.add({
                                name: name || 'Ionosphere Point',
                                position: Cesium.Cartesian3.fromDegrees(lon, lat, height),
                                point: {
                                    pixelSize: 12,
                                    color: color,
                                    outlineColor: Cesium.Color.WHITE,
                                    outlineWidth: 2,
                                    heightReference: Cesium.HeightReference.NONE
                                },
                                label: {
                                    text: name || 'Ionosphere',
                                    font: '10px sans-serif',
                                    fillColor: Cesium.Color.WHITE,
                                    style: Cesium.LabelStyle.FILL_AND_OUTLINE,
                                    verticalOrigin: Cesium.VerticalOrigin.BOTTOM,
                                    pixelOffset: new Cesium.Cartesian2(0, -10)
                                }
                            });
                            
                            this.layers.push(pointEntity);
                            return pointEntity;
                        }
                        
                        // Create safe ellipse with error handling
                        const entity = this.viewer.entities.add({
                            name: name || 'Ionosphere Layer',
                            position: Cesium.Cartesian3.fromDegrees(lon, lat, height),
                            ellipse: {
                                semiMajorAxis: semiMajorAxis,
                                semiMinorAxis: semiMinorAxis,
                                height: height,
                                material: color.withAlpha(0.4),
                                outline: true,
                                outlineColor: Cesium.Color.WHITE.withAlpha(0.8),
                                outlineWidth: 2.0,
                                rotation: rotation
                            }
                        });
                        
                        this.layers.push(entity);
                        return entity;
                    } catch (error) {
                        console.warn(`Error creating ionosphere ellipse at ${lat}°:`, error);
                        return null;
                    }
                },
                
                // Add ionospheric layers
                addIonosphericLayers: function() {
                    console.log('Adding ionospheric layers...');
                    
                    // D Layer (60-90 km) - Global ellipsoid approach for safety
                    try {
                        const dLayerGlobal = this.viewer.entities.add({
                            name: 'Ionosphere D Layer (Global)',
                            ellipsoid: {
                                radii: new Cesium.Cartesian3(6378137.0 + 75000, 6378137.0 + 75000, 6378137.0 + 75000),
                                innerRadii: new Cesium.Cartesian3(6378137.0 + 60000, 6378137.0 + 60000, 6378137.0 + 60000),
                                material: Cesium.Color.BLUE.withAlpha(0.08),
                                outline: true,
                                outlineColor: Cesium.Color.CORNFLOWERBLUE.withAlpha(0.15)
                            }
                        });
                        
                        this.layers.push(dLayerGlobal);
                        console.log('Added D layer (global ellipsoid)');
                    } catch (error) {
                        console.warn('Error adding D layer:', error);
                    }
                    
                    // E Layer (90-150 km) - Global ellipsoid
                    try {
                        const eLayerGlobal = this.viewer.entities.add({
                            name: 'Ionosphere E Layer (Global)',
                            ellipsoid: {
                                radii: new Cesium.Cartesian3(6378137.0 + 120000, 6378137.0 + 120000, 6378137.0 + 120000),
                                innerRadii: new Cesium.Cartesian3(6378137.0 + 90000, 6378137.0 + 90000, 6378137.0 + 90000),
                                material: Cesium.Color.GREEN.withAlpha(0.08),
                                outline: true,
                                outlineColor: Cesium.Color.LIGHTGREEN.withAlpha(0.15)
                            }
                        });
                        
                        this.layers.push(eLayerGlobal);
                        console.log('Added E layer (global ellipsoid)');
                    } catch (error) {
                        console.warn('Error adding E layer:', error);
                    }
                    
                    // F Layer (150-600 km) - Global ellipsoid
                    try {
                        const fLayerGlobal = this.viewer.entities.add({
                            name: 'Ionosphere F Layer (Global)',
                            ellipsoid: {
                                radii: new Cesium.Cartesian3(6378137.0 + 400000, 6378137.0 + 400000, 6378137.0 + 400000),
                                innerRadii: new Cesium.Cartesian3(6378137.0 + 150000, 6378137.0 + 150000, 6378137.0 + 150000),
                                material: Cesium.Color.RED.withAlpha(0.05),
                                outline: true,
                                outlineColor: Cesium.Color.LIGHTCORAL.withAlpha(0.1)
                            }
                        });
                        
                        this.layers.push(fLayerGlobal);
                        console.log('Added F layer (global ellipsoid)');
                    } catch (error) {
                        console.warn('Error adding F layer:', error);
                    }
                    
                    // Add some regional variations using safe ellipses
                    const regions = [
                        { lon: 0, lat: 0, name: 'Equatorial' },
                        { lon: 0, lat: 45, name: 'Mid-Latitude' },
                        { lon: 0, lat: 70, name: 'High-Latitude' }
                    ];
                    
                    regions.forEach(region => {
                        this.createSafeEllipse(
                            region.lon, region.lat, 200000,
                            1500000, 1500000,
                            Cesium.Color.YELLOW,
                            `${region.name} Enhancement`
                        );
                    });
                    
                    this.active = true;
                    console.log('Ionosphere layers initialized successfully');
                },
                
                // Clear all layers
                clearLayers: function() {
                    this.layers.forEach(layer => {
                        if (this.viewer && this.viewer.entities) {
                            this.viewer.entities.remove(layer);
                        }
                    });
                    this.layers = [];
                    this.active = false;
                    console.log('Ionosphere layers cleared');
                }
            };
            
            // Initialize the layers immediately
            ionosphere.addIonosphericLayers();
            
            return ionosphere;
        };
        
        // Add missing STRF bridge function
        window.initializeSTRFBridge = function() {
            console.log('STRF Bridge - using simplified version for stability');
            return null;
        };
        
        // Add missing RF voxel visualization function
        window.initializeRFVoxelVisualization = function(viewer) {
            console.log('RF voxel visualization - using simplified version for stability');
            return {
                viewer: viewer,
                active: false,
                voxels: [],
                
                initialize: function() {
                    this.active = true;
                    console.log('RF voxel system initialized');
                },
                
                addVoxel: function(position, properties) {
                    if (!this.viewer) return null;
                    
                    try {
                        const voxel = this.viewer.entities.add({
                            name: 'RF Voxel',
                            position: position,
                            box: {
                                dimensions: new Cesium.Cartesian3(1000, 1000, 1000),
                                material: properties?.color || Cesium.Color.CYAN.withAlpha(0.3)
                            }
                        });
                        
                        this.voxels.push(voxel);
                        return voxel;
                    } catch (error) {
                        console.warn('Error adding RF voxel:', error);
                        return null;
                    }
                },
                
                clear: function() {
                    this.voxels.forEach(voxel => {
                        if (this.viewer && this.viewer.entities) {
                            this.viewer.entities.remove(voxel);
                        }
                    });
                    this.voxels = [];
                }
            };
        };
        
        // Add missing beamforming visualization function
        window.initializeBeamformingVisualization = function(viewer, options) {
            console.log('Beamforming visualization - using simplified version for stability');
            
            return {
                viewer: viewer,
                options: options || {},
                active: false,
                beams: [],
                
                initialize: function() {
                    console.log('Initializing beamforming visualization systems');
                    this.active = true;
                },
                
                addBeam: function(startPos, endPos, properties) {
                    if (!this.viewer) return null;
                    
                    try {
                        const beam = this.viewer.entities.add({
                            name: properties?.name || 'RF Beam',
                            polyline: {
                                positions: [startPos, endPos],
                                width: properties?.width || 3.0,
                                material: properties?.color || Cesium.Color.CYAN.withAlpha(0.8),
                                clampToGround: false
                            }
                        });
                        
                        this.beams.push(beam);
                        return beam;
                    } catch (error) {
                        console.warn('Error adding RF beam:', error);
                        return null;
                    }
                },
                
                clearBeams: function() {
                    this.beams.forEach(beam => {
                        if (this.viewer && this.viewer.entities) {
                            this.viewer.entities.remove(beam);
                        }
                    });
                    this.beams = [];
                }
            };
        };
        
        // Add missing integrated RF visualization function
        window.initializeIntegratedRFVisualization = function(viewer, options) {
            console.log('Integrated RF visualization - initializing combined system');
            
            return {
                viewer: viewer,
                options: options || {},
                active: false,
                tracking: null,
                voxels: null,
                beamforming: null,
                
                start: function() {
                    console.log('Starting integrated RF visualization');
                    this.active = true;
                },
                
                stop: function() {
                    console.log('Stopping integrated RF visualization');
                    this.active = false;
                },
                
                update: function(data) {
                    if (this.active && data) {
                        console.log('Updating integrated RF visualization with data:', data);
                    }
                }
            };
        };
        
        // Add missing Cesium patch functions
        window.RF_SCYTHE.patchCesiumEllipses = function() {
            console.log('Cesium ellipse patches - using Cesium 1.108+ compatibility');
            return true;
        };
        
        // Add missing patch functions for static ground geometry
        window.RF_SCYTHE.patchStaticGroundBatchError = function() {
            console.log('Static ground batch error patch applied');
            return true;
        };
        
        window.RF_SCYTHE.patchGroundEllipseGeometry = function() {
            console.log('Ground ellipse geometry patch applied');
            return true;
        };
        
        window.RF_SCYTHE.patchComputeRectangle = function() {
            console.log('Compute rectangle patch applied');
            return true;
        };
        
        // Add network capture visualizer to RF_SCYTHE namespace
        window.RF_SCYTHE.createNetworkCaptureVisualizer = function(viewer, options) {
            console.log('Creating network capture visualizer');
            
            return {
                viewer: viewer,
                options: options || {},
                active: false,
                captures: [],
                
                initialize: function() {
                    console.log('Initializing network capture visualization');
                    this.active = true;
                },
                
                addCapture: function(position, data) {
                    if (!this.viewer) return null;
                    
                    try {
                        const capture = this.viewer.entities.add({
                            name: 'Network Capture',
                            position: position,
                            point: {
                                pixelSize: 8,
                                color: Cesium.Color.ORANGE,
                                outlineColor: Cesium.Color.WHITE,
                                outlineWidth: 2
                            },
                            label: {
                                text: data?.type || 'Capture',
                                font: '12px sans-serif',
                                fillColor: Cesium.Color.WHITE,
                                style: Cesium.LabelStyle.FILL_AND_OUTLINE,
                                verticalOrigin: Cesium.VerticalOrigin.BOTTOM,
                                pixelOffset: new Cesium.Cartesian2(0, -10)
                            }
                        });
                        
                        this.captures.push(capture);
                        return capture;
                    } catch (error) {
                        console.warn('Error adding network capture:', error);
                        return null;
                    }
                },
                
                clear: function() {
                    this.captures.forEach(capture => {
                        if (this.viewer && this.viewer.entities) {
                            this.viewer.entities.remove(capture);
                        }
                    });
                    this.captures = [];
                }

                ,
                /**
                 * Visualize network traffic (fallback implementation)
                 * This stub logs the invocation and can be replaced with a real implementation later.
                 */
                visualizeNetworkTraffic: function() {
                    console.log('networkCaptureViz.visualizeNetworkTraffic fallback invoked');
                    // A real implementation might draw animated flow lines or heatmaps on the globe
                }
            };
        };
        
        // Make functions available globally for external scripts
        window.patchCesiumEllipses = window.RF_SCYTHE.patchCesiumEllipses;
        window.enhancedRectangleNorthFix = window.RF_SCYTHE.enhancedRectangleNorthFix;
        
        // Expose specific patch functions globally for external script compatibility
        window.patchStaticGroundBatchError = window.RF_SCYTHE.patchStaticGroundBatchError;
        window.patchGroundEllipseGeometry = window.RF_SCYTHE.patchGroundEllipseGeometry;
        window.patchComputeRectangle = window.RF_SCYTHE.patchComputeRectangle;
        window.createNetworkCaptureVisualizer = window.RF_SCYTHE.createNetworkCaptureVisualizer;
        
        // Also ensure they're available on the global RF_SCYTHE object
        if (typeof window.RF_SCYTHE !== 'undefined') {
            // Double-check all functions are properly attached
            console.log('RF_SCYTHE functions available:', Object.keys(window.RF_SCYTHE));
            
            // Ensure enhancedRectangleNorthFix is accessible from external scripts
            window.RF_SCYTHE.enhancedRectangleNorthFix = window.RF_SCYTHE.enhancedRectangleNorthFix || function() {
                console.log('Enhanced Rectangle north fix - using Cesium 1.108+ compatibility (fallback)');
            };
        }

        function simulateTraceroute(target) {
            // Return a small set of simulated hops for UI display
            const hops = [];
            const hopCount = 5 + Math.floor(Math.random() * 6);
            for (let i = 1; i <= hopCount; i++) {
                hops.push({
                    hop: i,
                    ip: `192.0.2.${10 + i}`,
                    rtt_ms: Math.round(10 + Math.random() * 100),
                    asn: 64512 + i
                });
            }
            return hops;
        }
    </script>
    <script>
        // WebGL detection and error handling
        function checkWebGLSupport() {
            try {
                const canvas = document.createElement('canvas');
                return !!window.WebGLRenderingContext && 
                    (canvas.getContext('webgl') || canvas.getContext('experimental-webgl'));
            } catch (e) {
                return false;
            }
        }
        
        if (!checkWebGLSupport()) {
            // Show WebGL error message if WebGL is not supported
            window.addEventListener('DOMContentLoaded', function() {
                document.body.innerHTML = `
                    <div style="padding: 20px; background-color: #2c3e50; color: white; max-width: 600px; margin: 50px auto; border-radius: 5px; text-align: center;">
                        <h2>WebGL Not Supported</h2>
                        <p>Your browser or device does not support WebGL, which is required for the RF SCYTHE visualization.</p>
                        <p>Please try using a different browser (like Chrome or Firefox) or update your graphics drivers.</p>
                        <p><a href="http://get.webgl.org" style="color: #00aaff; text-decoration: underline;">Visit get.webgl.org</a> to check WebGL compatibility.</p>
                    </div>
                `;
                // Add error handler specifically for the Rectangle.north error in StaticGroundGeometryColorBatch
                window.addEventListener('error', function(event) {
                    // Check if this is the Rectangle.north error in computeRectangle
                    if (event.error && event.error.message && 
                        event.error.message.includes('read only property') && 
                        event.error.message.includes('north')) {
                        
                        console.error('Rectangle.north error caught:', event.error.message, event.error.stack);
                        
                        // Apply our specific fix for this error
                        if (typeof window.RF_SCYTHE !== 'undefined' && window.RF_SCYTHE) {
                            if (typeof window.RF_SCYTHE.patchStaticGroundBatchError === 'function') {
                                console.log('Applying specific StaticGroundGeometryColorBatch fix');
                                window.RF_SCYTHE.patchStaticGroundBatchError();
                            }
                            if (typeof window.RF_SCYTHE.patchGroundEllipseGeometry === 'function') {
                                console.log('Applying ground ellipse geometry fix');
                                window.RF_SCYTHE.patchGroundEllipseGeometry();
                            }
                            if (typeof window.RF_SCYTHE.enhancedRectangleNorthFix === 'function') {
                                console.log('Applying enhanced Rectangle.north fix');
                                window.RF_SCYTHE.enhancedRectangleNorthFix();
                            }
                        }
                        
                        // Handle Rectangle.north errors with fallback
                        if (event.error && event.error.message && event.error.message.includes('Rectangle.north')) {
                            console.warn('Rectangle.north error detected, applying fallback');
                            
                            // Give the user the option to switch to minimal globe mode
                            setTimeout(function() {
                                if (confirm('Encountered Rectangle.north error. Would you like to switch to minimal globe mode to avoid this error?')) {
                                    window.location.href = 'emergency-minimal-globe.html';
                                }
                            }, 500);
                        }
                        
                        // Prevent the default error handling
                        event.preventDefault();
                        return true;
                    }
                });
            });
        }
        
        // Add global error handling for Cesium
        window.addEventListener('error', function(event) {
            try {
                if (event.error && event.error.message && 
                    (event.error.message.includes('WebGL') || 
                     event.error.message.includes('Cesium') || 
                     event.error.message.includes('CesiumWidget') ||
                     event.error.message.includes('Error constructing'))) {
                    console.error('Cesium/WebGL error caught:', event.error);
                    
                    // Show a more user-friendly error
                    const cesiumContainer = document.getElementById('cesiumContainer');
                    if (cesiumContainer) {
                        cesiumContainer.innerHTML = `
                            <div style="padding: 20px; background-color: #2c3e50; color: white; max-width: 600px; margin: 50px auto; border-radius: 5px; text-align: center;">
                                <h2>Visualization Error</h2>
                                <p>There was a problem initializing the 3D visualization.</p>
                                <p>Error: ${event.error.message}</p>
                                <p>Try refreshing the page or using a different browser.</p>
                            </div>
                        `;
                    }
                    
                    event.preventDefault();
                    return true; // Suppress error
                }
            } catch (e) {
                console.error('Error in global error handler:', e);
            }
        });
    </script>
    <script src="https://cesium.com/downloads/cesiumjs/releases/1.108/Build/Cesium/Cesium.js"></script>
    <script src="https://cdn.plot.ly/plotly-2.12.1.min.js"></script>
    <!-- Socket.IO Client for WebSocket Support -->
    <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
    
    <!-- Essential Functions - Available Immediately -->
    <script>
        // BASE panel switching function - used by the consolidated wrapper
        // Do NOT call this directly - use window.showPanel instead
        window.baseShowPanel = function(panelName) {
            console.log(`Showing panel: ${panelName}`);
            
            // Remove active class from all tab buttons and panels
            document.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active'));
            document.querySelectorAll('.tab-panel').forEach(panel => panel.classList.remove('active'));
            
            // Show the target panel
            const targetPanel = document.getElementById(`${panelName}-panel`);
            if (targetPanel) {
                targetPanel.classList.add('active');
                console.log(`Successfully activated panel: ${panelName}-panel`);
                
                // Update tab button if it exists
                const tabButton = document.querySelector(`[data-tab="${panelName}"]`);
                if (tabButton) {
                    tabButton.classList.add('active');
                }
                
                // Hide dropdown menu
                const dropdown = document.getElementById('dropdown-menu');
                if (dropdown) {
                    dropdown.classList.remove('show');
                }
                
                return true;
            } else {
                console.error(`Panel not found: ${panelName}-panel`);
                return false;
            }
        };
        
        // ==================== CONSOLIDATED PANEL MANAGEMENT ====================
        // SINGLE showPanel definition with all module-specific hooks
        // This runs early so it's available for all menu clicks
        window.showPanel = function(panelName) {
            console.log(`[showPanel] Switching to: ${panelName}`);
            
            // Call the base logic (switches active classes, hides dropdown)
            const result = window.baseShowPanel(panelName);
            
            if (!result) {
                console.warn(`[showPanel] Failed to show panel: ${panelName}`);
                return false;
            }
            
            // ===== Module-specific hooks =====
            // These are called after panel is shown to initialize content
            
            // Metrics panel hook
            if (panelName === 'metrics') {
                if (typeof MetricsExplorer !== 'undefined' && MetricsExplorer.fetchAllMetrics) {
                    MetricsExplorer.fetchAllMetrics();
                }
            }

            // Nmap panel hook
            if (panelName === 'nmap') {
                if (typeof refreshNmapHistoryUI === 'function') {
                    refreshNmapHistoryUI();
                }
            }

            // Recon panel hook
            if (panelName === 'recon') {
                try {
                    if (window.AutoReconVisualization && typeof window.AutoReconVisualization.show === 'function') {
                        window.AutoReconVisualization.show();
                    }

                    // Wire simple controls
                    const loadBtn = document.getElementById('reconLoadBtn');
                    if (loadBtn) loadBtn.onclick = function() { window.AutoReconVisualization?.loadEntities(); populateReconList(); };
                    const alertsBtn = document.getElementById('reconAlertsBtn');
                    if (alertsBtn) alertsBtn.onclick = function() { window.AutoReconVisualization?.loadAlerts(); };

                    // Populate reconList from AutoReconVisualization.entities
                    function populateReconList() {
                        const listEl = document.getElementById('reconList');
                        if (!listEl) return;
                        listEl.innerHTML = '';
                        const entities = (window.AutoReconVisualization && window.AutoReconVisualization.entities) ? window.AutoReconVisualization.entities : {};
                        const ids = Object.keys(entities || {});
                        if (ids.length === 0) {
                            listEl.innerHTML = '<li class="list-item no-entities" style="color:#888; font-size:12px;">No recon entities available</li>';
                        } else {
                            ids.forEach(id => {
                                const e = entities[id];
                                const li = document.createElement('li');
                                li.className = 'list-item';
                                li.innerHTML = `
                                    <div class="list-item-header">
                                        <span class="list-item-title">${e.name}</span>
                                        <span class="status-dot" style="background-color:${e.disposition === 'HOSTILE' ? '#ff4d4d' : '#4a9eff'}"></span>
                                    </div>
                                    <div class="list-item-subtitle">${e.disposition} | ${e.threat_level} | ${e.location.lat.toFixed(3)}, ${e.location.lon.toFixed(3)}</div>
                                    <div class="list-item-actions">
                                        <button class="action-button" data-entity-id="${e.entity_id}" data-action="track">Track</button>
                                        <button class="action-button" data-entity-id="${e.entity_id}" data-action="task">Task</button>
                                        <button class="action-button" data-entity-id="${e.entity_id}" data-action="info">Info</button>
                                    </div>
                                `;

                                // Attach delegated handlers
                                li.querySelectorAll('.list-item-actions .action-button').forEach(btn => {
                                    btn.addEventListener('click', function() {
                                        const entId = this.getAttribute('data-entity-id');
                                        const action = this.getAttribute('data-action');
                                        if (action === 'track') {
                                            // Use AutoReconVisualization.flyToEntity if available
                                            if (window.AutoReconVisualization && window.AutoReconVisualization.flyToEntity) {
                                                window.AutoReconVisualization.flyToEntity(entId);
                                            }
                                        } else if (action === 'task') {
                                            if (window.AutoReconVisualization && window.AutoReconVisualization.createTaskForEntity) {
                                                window.AutoReconVisualization.createTaskForEntity(entId);
                                            }
                                        } else if (action === 'info') {
                                            // Show entity description in a modal or notification
                                            const ent = (window.AutoReconVisualization && window.AutoReconVisualization.entities) ? window.AutoReconVisualization.entities[entId] : null;
                                            if (ent) {
                                                const desc = window.AutoReconVisualization.createEntityDescription ? window.AutoReconVisualization.createEntityDescription(ent) : `<pre>${JSON.stringify(ent, null, 2)}</pre>`;
                                                showNotification('Entity Info', '', 'info');
                                                addConsoleMessage(`Entity info: ${ent.name} (${ent.entity_id})`, 'response');
                                                // Open a simple centered panel
                                                const infoPanel = document.createElement('div');
                                                infoPanel.style.position = 'fixed';
                                                infoPanel.style.left = '50%';
                                                infoPanel.style.top = '50%';
                                                infoPanel.style.transform = 'translate(-50%, -50%)';
                                                infoPanel.style.background = 'rgba(20,20,20,0.95)';
                                                infoPanel.style.padding = '12px';
                                                infoPanel.style.borderRadius = '6px';
                                                infoPanel.style.zIndex = 99999;
                                                infoPanel.innerHTML = desc + '<div style="text-align:right;margin-top:8px;"><button class="close-info-btn">Close</button></div>';
                                                document.body.appendChild(infoPanel);
                                                // Attach close handler scoped to this panel
                                                const closeBtn = infoPanel.querySelector('.close-info-btn');
                                                if (closeBtn) {
                                                    closeBtn.addEventListener('click', () => {
                                                        document.body.removeChild(infoPanel);
                                                    });
                                                }
                                            }
                                        }
                                    });
                                });

                                listEl.appendChild(li);
                            });
                        }

                        // Update panel count
                        const countEl = document.getElementById('recon-panel-count');
                        if (countEl) countEl.textContent = ids.length;
                    }

                    // Populate immediately after showing
                    setTimeout(populateReconList, 200);

                } catch (err) {
                    console.error('Error initializing recon panel:', err);
                }
            }
            
            // Propagation panel hook
            if (panelName === 'propagation') {
                if (typeof PropagationUI !== 'undefined' && PropagationUI.updateAtmosphericDisplay) {
                    PropagationUI.updateAtmosphericDisplay();
                }
            }
            
            // Hypergraph panel hook
            if (panelName === 'hypergraph') {
                if (typeof initializeHypergraphVisualization === 'function') {
                    initializeHypergraphVisualization();
                }
            }
            
            // Operators panel hook
            if (panelName === 'operators') {
                if (typeof OperatorSession !== 'undefined' && OperatorSession.refreshPresence) {
                    OperatorSession.refreshPresence();
                }
                if (typeof RoomManager !== 'undefined' && RoomManager.fetchRooms) {
                    RoomManager.fetchRooms();
                }
            }
            
            // POI panel hook
            if (panelName === 'poi') {
                if (typeof POIManager !== 'undefined' && POIManager.refresh) {
                    POIManager.refresh();
                }
            }
            
            // Network panel hook - refresh network stats if available
            if (panelName === 'network') {
                if (typeof updateNetworkElementCounts === 'function') {
                    updateNetworkElementCounts();
                }
            }
            
            // Sensors panel hook
            if (panelName === 'sensors') {
                if (typeof SensorManager !== 'undefined' && SensorManager.load) {
                    SensorManager.load();
                }
            }
            
            // Show/hide hypergraph visualization overlay
            const hypergraphViz = document.getElementById('hypergraph-visualization');
            if (hypergraphViz) {
                hypergraphViz.classList.toggle('active', panelName === 'hypergraph');
            }
            
            // Log panel interaction for metrics tracking
            if (window.logInteraction) {
                window.logInteraction('panel_switch', panelName, {
                    previous_panel: window._currentPanel || 'none'
                });
            }
            window._currentPanel = panelName;
            
            // Reset camera transform to ensure controls remain responsive
            // This is critical after any panel that may have triggered flyTo operations
            if (typeof window.resetCameraTransform === 'function') {
                // Only reset if we're switching away from hypergraph (which does camera ops)
                if (window._previousPanel === 'hypergraph' && panelName !== 'hypergraph') {
                    window.resetCameraTransform();
                }
            }
            window._previousPanel = panelName;
            
            return true;
        };
        
        // Target management functions
        window.selectMissileTarget = function(targetIndex) {
            if (targetIndex >= 0 && targetIndex < window.activeMissileTargets.length) {
                const target = window.activeMissileTargets[targetIndex];
                
                // Highlight the target
                if (target.entity && target.entity.point) {
                    target.entity.point.outlineWidth = 5;
                    target.entity.point.outlineColor = Cesium.Color.CYAN;
                }
                
                // Update missile target selector
                const targetSelector = document.getElementById('missileTarget');
                if (targetSelector) {
                    // Add 'selected target' option if it doesn't exist
                    let selectedOption = targetSelector.querySelector('option[value="selected"]');
                    if (!selectedOption) {
                        selectedOption = document.createElement('option');
                        selectedOption.value = 'selected';
                        targetSelector.appendChild(selectedOption);
                    }
                    selectedOption.textContent = `Selected: Target ${targetIndex + 1} (${target.priority})`;
                    targetSelector.value = 'selected';
                }
                
                // Zoom to target
                viewer.zoomTo(target.entity);
                
                showNotification('Target Selected', `Selected ${target.priority} priority target at ${target.lat.toFixed(4)}, ${target.lon.toFixed(4)}`, 'info');
                addConsoleMessage(`Target ${targetIndex + 1} selected: ${target.description}`, 'response');
                
                window.selectedMissileTarget = targetIndex;
            }
        };
        
        window.launchAtTarget = function(targetIndex) {
            if (targetIndex >= 0 && targetIndex < window.activeMissileTargets.length) {
                const target = window.activeMissileTargets[targetIndex];
                
                showNotification('Missile Launch', `Launching hypersonic missile at target ${targetIndex + 1}`, 'warning');
                addConsoleMessage(`Missile launched at ${target.priority} priority target: ${target.description}`, 'command');
                
                // Launch missile with specific target
                launchHypersonicMissileAtTarget(target.lat, target.lon);
                
                // Deploy tracking drones
                setTimeout(() => {
                    deployTrackingDrones();
                    addConsoleMessage(`Tracking drones deployed for target engagement`, 'response');
                }, 1000);
            }
        };
        
        window.removeTarget = function(targetIndex) {
            if (targetIndex >= 0 && targetIndex < window.activeMissileTargets.length) {
                const target = window.activeMissileTargets[targetIndex];
                
                // Remove from Cesium
                if (target.entity) {
                    viewer.entities.remove(target.entity);
                }
                
                // Remove from array
                window.activeMissileTargets.splice(targetIndex, 1);
                
                updateMissileTargetsList();
                
                showNotification('Target Removed', `Target ${targetIndex + 1} removed from targeting system`, 'info');
                addConsoleMessage(`Target ${targetIndex + 1} removed from engagement list`, 'response');
            }
        };
        
        // Enhanced missile launch function with specific target
        function launchHypersonicMissileAtTarget(targetLat, targetLon) {
            if (!viewer || !targetLat || !targetLon) {
                console.error('Invalid target coordinates for missile launch');
                return;
            }
            
            // Use existing missile launch logic but with specific target coordinates
            const start = viewer.clock.currentTime;
            const startPosition = Cesium.Cartesian3.fromDegrees(-122.4194, 37.7749, 50000); // San Francisco launch
            const endPosition = Cesium.Cartesian3.fromDegrees(targetLon, targetLat, 0); // Target location
            const flightTimeSeconds = 300; // 5 minutes flight time
            
            // Clear any previous missile
            clearActiveMissile();
            
            const positionProperty = new Cesium.SampledPositionProperty();
            const velocity = new Cesium.SampledPositionProperty();
            
            const samplesCount = 100;
            const initialVelocity = Cesium.Cartesian3.fromElements(1000, 0, 0);
            
            activeMissile = viewer.entities.add({
                name: 'Hypersonic Missile (Targeted)',
                availability: new Cesium.TimeIntervalCollection([
                    new Cesium.TimeInterval({
                        start: start,
                        stop: Cesium.JulianDate.addSeconds(start, flightTimeSeconds, new Cesium.JulianDate())
                    })
                ]),
                position: positionProperty,
                velocity: velocity,
                model: {
                    uri: 'assets/missile.gltf',
                    scale: 3.0,
                    minimumPixelSize: 64,
                    maximumScale: 20000,
                    shadows: Cesium.ShadowMode.ENABLED
                },
                path: {
                    show: true,
                    leadTime: 0,
                    trailTime: flightTimeSeconds,
                    width: 3,
                    material: new Cesium.PolylineGlowMaterialProperty({
                        glowPower: 0.3,
                        color: Cesium.Color.RED
                    })
                }
            });
            
            // Generate trajectory with target-specific path
            for (let i = 0; i <= samplesCount; i++) {
                const time = Cesium.JulianDate.addSeconds(start, i / samplesCount * flightTimeSeconds, new Cesium.JulianDate());
                const t = i / samplesCount;
                
                // Interpolate position with ballistic arc
                const pos = new Cesium.Cartesian3();
                Cesium.Cartesian3.lerp(startPosition, endPosition, t, pos);
                
                // Add ballistic arc
                const arcFactor = t * (1.0 - t);
                const upVector = Cesium.Cartesian3.normalize(pos, new Cesium.Cartesian3());
                const arcVector = Cesium.Cartesian3.multiplyByScalar(upVector, arcFactor * 8000, new Cesium.Cartesian3());
                Cesium.Cartesian3.add(pos, arcVector, pos);
                
                positionProperty.addSample(time, pos);
                
                if (i > 0) {
                    const prevTime = Cesium.JulianDate.addSeconds(start, (i-1) / samplesCount * flightTimeSeconds, new Cesium.JulianDate());
                    const prevPos = positionProperty.getValue(prevTime);
                    const dt = Cesium.JulianDate.secondsDifference(time, prevTime);
                    const velocityVec = Cesium.Cartesian3.subtract(pos, prevPos, new Cesium.Cartesian3());
                    Cesium.Cartesian3.multiplyByScalar(velocityVec, 1/dt, velocityVec);
                    velocity.addSample(time, velocityVec);
                } else {
                    velocity.addSample(time, initialVelocity);
                }
            }
            
            console.log('Targeted hypersonic missile launched successfully');
        }
    </script>
    
    <!-- Initialize Cesium fixes after Cesium loads -->
    <script>
        // Initialize fixes when Cesium is ready
        if (window.Cesium && window.RF_SCYTHE && window.RF_SCYTHE.initCesiumFixes) {
            window.RF_SCYTHE.initCesiumFixes();
        } else {
            window.addEventListener('DOMContentLoaded', function() {
                if (window.Cesium && window.RF_SCYTHE && window.RF_SCYTHE.initCesiumFixes) {
                    window.RF_SCYTHE.initCesiumFixes();
                }
            });
        }
        
	        // NOTE: Do NOT override initializeCesiumSafely here.
	        // Bootloader / main init will own viewer creation.
	    </script>
	
	    <!-- Use the clean, non-auto-running rectangle fix to avoid syntax errors and race conditions -->
	    <script>
/**
 * Enhanced Rectangle North Property Fix (Clean, Bootloader-Friendly) for RF SCYTHE
 *
 * Fixes Cesium errors like:
 *   TypeError: Cannot assign to read only property 'north' of object '#<Rectangle>'
 *
 * Design:
 *  - Patch ONLY the rectangle computation hot paths.
 *  - Idempotent: safe to call repeatedly.
 *  - Avoid monkey-patching Cesium.Rectangle constructor (can break Cesium internals).
 *  - No auto-run: your bootloader should call RF_SCYTHE.enhancedRectangleNorthFix() exactly once.
 */

(function () {
  // Ensure namespace
  window.RF_SCYTHE = window.RF_SCYTHE || {};

  const NS = window.RF_SCYTHE;
  NS.__patchState = NS.__patchState || { originals: {}, flags: {} };

  function canWriteRectangle(r) {
    if (!r) return false;
    try {
      const v = r.north;
      r.north = v;
      return true;
    } catch (_) {
      return false;
    }
  }

  function copyRect(dst, src) {
    // Copy in a stable order
    dst.west = src.west;
    dst.south = src.south;
    dst.east = src.east;
    dst.north = src.north;
    return dst;
  }

  NS.enhancedRectangleNorthFix = function enhancedRectangleNorthFix(CesiumRef) {
    try {
      const Cesium = CesiumRef || window.Cesium;
      if (!Cesium) {
        console.warn('[RF_SCYTHE] Cesium not available yet; skip enhancedRectangleNorthFix');
        return false;
      }

      // Optional: chain to your other patch if present
      if (typeof NS.patchComputeRectangle === 'function') {
        try { NS.patchComputeRectangle(); } catch (_) {}
      }

      const state = NS.__patchState;

      // --- Patch 1: EllipseGeometry.prototype._computeRectangle ---
      const proto = Cesium.EllipseGeometry && Cesium.EllipseGeometry.prototype;
      if (proto && typeof proto._computeRectangle === 'function') {
        if (!state.originals.ellipse__computeRectangle) {
          state.originals.ellipse__computeRectangle = proto._computeRectangle;
        }

        if (!state.flags.patchedEllipseComputeRectangle) {
          const original = state.originals.ellipse__computeRectangle;
          proto._computeRectangle = function (computedOptions, result) {
            try {
              // Always compute into a fresh mutable rectangle
              const tmp = new Cesium.Rectangle();
              const rect = original.call(this, computedOptions, tmp) || tmp;

              // If caller provided a result, try to copy; if it's frozen/read-only, return our tmp
              if (result) {
                if (canWriteRectangle(result)) return copyRect(result, rect);
                return rect;
              }

              return rect;
            } catch (err) {
              console.error('[RF_SCYTHE] patched _computeRectangle failed:', err);
              return new Cesium.Rectangle(
                -Cesium.Math.PI,
                -Cesium.Math.PI_OVER_TWO,
                Cesium.Math.PI,
                Cesium.Math.PI_OVER_TWO
              );
            }
          };

          state.flags.patchedEllipseComputeRectangle = true;
          console.log('[RF_SCYTHE] Patched EllipseGeometry.prototype._computeRectangle');
        }
      }

      // --- Patch 2: EllipseGeometryLibrary.computeRectangle ---
      const lib = Cesium.EllipseGeometryLibrary;
      if (lib && typeof lib.computeRectangle === 'function') {
        if (!state.originals.lib_computeRectangle) {
          state.originals.lib_computeRectangle = lib.computeRectangle;
        }

        if (!state.flags.patchedLibComputeRectangle) {
          const originalLib = state.originals.lib_computeRectangle;

          // Keep signature loose (Cesium versions vary slightly) but preserve last-arg result semantics.
          lib.computeRectangle = function (...args) {
            try {
              const callerResult = args.length ? args[args.length - 1] : undefined;
              const tmp = new Cesium.Rectangle();

              // Force compute into tmp
              if (args.length) args[args.length - 1] = tmp;
              const rect = originalLib.apply(this, args) || tmp;

              // If caller passed a result rectangle, copy into it when possible
              if (callerResult && callerResult !== tmp) {
                if (canWriteRectangle(callerResult)) return copyRect(callerResult, rect);
                return rect;
              }

              return rect;
            } catch (err) {
              console.error('[RF_SCYTHE] patched EllipseGeometryLibrary.computeRectangle failed:', err);
              return new Cesium.Rectangle(
                -Cesium.Math.PI,
                -Cesium.Math.PI_OVER_TWO,
                Cesium.Math.PI,
                Cesium.Math.PI_OVER_TWO
              );
            }
          };

          state.flags.patchedLibComputeRectangle = true;
          console.log('[RF_SCYTHE] Patched EllipseGeometryLibrary.computeRectangle');
        }
      }

      return true;
    } catch (e) {
      console.error('[RF_SCYTHE] enhancedRectangleNorthFix failed:', e);
      return false;
    }
  };
})();

</script>
    <link rel="stylesheet" href="network-visualization.css">
    <link rel="stylesheet" href="missile-operations.css">
    <link rel="stylesheet" href="urh-integration.css">
    <script>
        // Set your Cesium Ion access token
        Cesium.Ion.defaultAccessToken = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiJlNjM1OWQzMS01ZGQ1LTQwMDAtOGZlZC1hMDlhZGY3YTZjYTYiLCJpZCI6MjU0MDE2LCJpYXQiOjE3MzExNDEyNDN9.geHijTptoG3E8aZAYFAZltD9LkPGAiljQ01uW9JdKYQ';
    </script>
    <link rel="stylesheet" href="styles.css">
    <style>
        /* Hypersonic Defense Variables */
        :root {
            --hypersonic-primary: #ff3c38;
            --hypersonic-secondary: #d81159;
            --hypersonic-accent: #ff9f1c;
            --hypersonic-light: #ffbd59;
            --hypersonic-dark: #8f2d56;
            --hypersonic-gradient: linear-gradient(135deg, var(--hypersonic-primary), var(--hypersonic-dark));
        }
        
        /* Command Sidebar Styling */
        #command-sidebar-right {
            position: fixed;
            top: 0;
            right: 0;
            width: 350px;
            height: 100vh;
            background: rgba(20, 20, 20, 0.95);
            border-left: 1px solid #333;
            display: flex;
            flex-direction: column;
            z-index: 1000;
            overflow: hidden;
        }
        
        #command-sidebar-right #sidebar-toggle {
            position: absolute;
            left: -25px;
            top: 50%;
            transform: translateY(-50%);
            background: rgba(30, 30, 30, 0.9);
            border: 1px solid #333;
            border-right: none;
            color: #fff;
            padding: 10px 5px;
            cursor: pointer;
            border-radius: 5px 0 0 5px;
            z-index: 1001;
        }
        
        #command-sidebar-right.collapsed {
            transform: translateX(350px);
        }
        
        #command-sidebar-right.collapsed #sidebar-toggle {
            content: '▶';
        }
        
        /* Ensure Cesium globe is visible */
        #cesiumContainer {
            z-index: 1 !important;
            background: #000 !important;
            position: relative !important;
        }
        
        #cesiumContainer .cesium-widget {
            z-index: 2 !important;
        }
        
        /* Ensure Cesium globe is visible */
        #cesiumContainer {
            z-index: 1;
            background: #000;
        }
        
        #cesiumContainer .cesium-widget {
            z-index: 2 !important;
        }
        
        /* Camera Navigation Controls */
        #camera-nav-controls {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 100;
            display: flex;
            flex-direction: column;
            gap: 10px;
            pointer-events: none; /* Allow clicks to pass through to map */
        }
        
        /* Enable pointer events only on interactive elements */
        #camera-nav-controls button,
        #camera-nav-controls #compass-ring,
        #camera-nav-controls #zoom-controls,
        #camera-nav-controls #tilt-controls {
            pointer-events: auto;
        }
        
        /* Compass Container */
        #compass-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
            pointer-events: none; /* Container doesn't block */
        }
        
        #compass-ring {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid var(--accent-blue, #4a9eff);
            position: relative;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
            pointer-events: auto; /* Enable interaction on compass */
        }
        
        #compass-needle {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 4px;
            height: 30px;
            background: linear-gradient(to bottom, #ff3333 50%, #ffffff 50%);
            transform-origin: center bottom;
            transform: translate(-50%, -100%);
            border-radius: 2px;
            transition: transform 0.1s ease-out;
        }
        
        .compass-label {
            position: absolute;
            font-size: 10px;
            font-weight: bold;
            color: #fff;
        }
        
        .compass-n { top: 5px; left: 50%; transform: translateX(-50%); color: #ff3333; }
        .compass-e { right: 5px; top: 50%; transform: translateY(-50%); }
        .compass-s { bottom: 5px; left: 50%; transform: translateX(-50%); }
        .compass-w { left: 5px; top: 50%; transform: translateY(-50%); }
        
        #reset-north-btn {
            width: 30px;
            height: 30px;
            border-radius: 4px;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid var(--accent-blue, #4a9eff);
            color: #fff;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
            pointer-events: auto; /* Enable interaction */
        }
        
        #reset-north-btn:hover {
            background: var(--accent-blue, #4a9eff);
        }
        
        /* Zoom Controls */
        #zoom-controls, #tilt-controls {
            display: flex;
            flex-direction: column;
            gap: 3px;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 6px;
            padding: 5px;
            border: 1px solid var(--accent-blue, #4a9eff);
            pointer-events: auto; /* Enable interaction on control panels */
        }
        
        #tilt-controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 3px;
        }
        
        #zoom-controls button, #tilt-controls button {
            width: 36px;
            height: 36px;
            border: none;
            background: rgba(74, 158, 255, 0.2);
            color: #fff;
            cursor: pointer;
            font-size: 18px;
            border-radius: 4px;
            transition: all 0.2s;
        }
        
        #zoom-controls button:hover, #tilt-controls button:hover {
            background: var(--accent-blue, #4a9eff);
        }
        
        #zoom-controls button:active, #tilt-controls button:active {
            transform: scale(0.95);
        }
        
        /* Unlock Camera Button */
        #unlock-camera-btn {
            padding: 8px 12px;
            background: rgba(255, 100, 100, 0.8);
            border: 1px solid #ff6666;
            border-radius: 4px;
            color: #fff;
            cursor: pointer;
            font-size: 12px;
            font-weight: bold;
            animation: pulse-unlock 1.5s infinite;
            pointer-events: auto; /* Enable interaction on unlock button */
        }
        
        @keyframes pulse-unlock {
            0%, 100% { box-shadow: 0 0 5px rgba(255, 100, 100, 0.5); }
            50% { box-shadow: 0 0 15px rgba(255, 100, 100, 0.8); }
        }
        
        #unlock-camera-btn:hover {
            background: rgba(255, 100, 100, 1);
        }
        
        /* Missile Control Panel Styles */
        .missile-control-panel {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .control-section {
            background-color: rgba(30, 30, 30, 0.9);
            border-radius: 8px;
            padding: 15px;
            border: 1px solid #333;
        }
        
        .control-section h4 {
            color: var(--hypersonic-accent);
            margin: 0 0 15px 0;
            font-size: 0.9rem;
            border-bottom: 1px solid #444;
            padding-bottom: 8px;
        }
        
        .toggle-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }
        
        .toggle-label {
            font-size: 0.85rem;
            color: #ccc;
        }
        
        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 40px;
            height: 24px;
        }
        
        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        
        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #444;
            transition: .4s;
            border-radius: 24px;
        }
        
        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 16px;
            width: 16px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        
        input:checked + .toggle-slider {
            background-color: var(--hypersonic-primary);
        }
        
        input:checked + .toggle-slider:before {
            transform: translateX(16px);
        }
        
        .slider-control {
            margin: 15px 0;
        }
        
        .slider-control label {
            display: flex;
            justify-content: space-between;
            font-size: 0.85rem;
            margin-bottom: 8px;
            color: #ccc;
        }
        
        .slider-control label span {
            color: var(--hypersonic-accent);
            font-family: 'Roboto Mono', monospace;
        }
        
        .slider-control input[type="range"] {
            width: 100%;
            height: 6px;
            background: #444;
            border-radius: 5px;
            outline: none;
            -webkit-appearance: none;
        }
        
        .slider-control input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: var(--hypersonic-primary);
            cursor: pointer;
        }
        
        /* Telemetry Panel Styles */
        .telemetry-panel {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin: 20px 0;
        }
        
        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .metric {
            background-color: rgba(37, 37, 37, 0.9);
            border-radius: 6px;
            padding: 10px;
            text-align: center;
            border: 1px solid #444;
        }
        
        .metric-value {
            font-size: 1.5rem;
            font-weight: 600;
            margin: 5px 0;
            color: var(--hypersonic-accent);
            font-family: 'Roboto Mono', monospace;
        }
        
        .metric-label {
            font-size: 0.8rem;
            color: #ccc;
        }
        
        .visualization {
            background-color: rgba(37, 37, 37, 0.9);
            border-radius: 6px;
            padding: 10px;
            min-height: 200px;
            border: 1px solid #444;
        }
        
        .threat-level {
            display: flex;
            align-items: center;
            margin: 15px 0;
        }
        
        .threat-label {
            font-size: 0.9rem;
            margin-right: 10px;
            color: #ccc;
        }
        
        .threat-indicator {
            flex: 1;
            height: 12px;
            background-color: #333;
            border-radius: 6px;
            overflow: hidden;
            position: relative;
        }
        
        .threat-fill {
            height: 100%;
            width: 60%;
            background: linear-gradient(to right, #33cc33, #ffcc00, #cc3333);
            border-radius: 6px;
        }
        
        .threat-marker {
            position: absolute;
            width: 4px;
            height: 16px;
            background-color: white;
            top: -2px;
            left: 60%;
            border-radius: 2px;
        }
        
        .threat-value {
            font-size: 0.9rem;
            width: 40px;
            text-align: right;
            margin-left: 10px;
            font-family: 'Roboto Mono', monospace;
            color: #cc3333;
        }
        
        .time-control {
            background-color: rgba(37, 37, 37, 0.9);
            border-radius: 6px;
            padding: 15px;
            margin: 20px 0;
            border: 1px solid #444;
        }
        
        .time-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        
        .time-title {
            font-size: 0.9rem;
            margin: 0;
            color: var(--hypersonic-accent);
        }
        
        .real-time {
            font-size: 0.8rem;
            color: var(--hypersonic-accent);
            font-family: 'Roboto Mono', monospace;
        }
        
        .timeline {
            height: 8px;
            background-color: #444;
            border-radius: 4px;
            margin-bottom: 10px;
            overflow: hidden;
            position: relative;
        }
        
        .timeline-progress {
            height: 100%;
            width: 35%;
            background-color: var(--hypersonic-primary);
            border-radius: 4px;
            transition: width 0.5s ease;
        }
        
        .timeline-events {
            position: relative;
            height: 20px;
            margin-bottom: 10px;
        }
        
        .timeline-event {
            position: absolute;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            top: 6px;
            background-color: var(--hypersonic-accent);
        }
        
        .timeline-event:nth-child(1) { left: 15%; }
        .timeline-event:nth-child(2) { left: 30%; }
        .timeline-event:nth-child(3) { left: 55%; }
        .timeline-event:nth-child(4) { left: 80%; }
        
        .time-labels {
            display: flex;
            justify-content: space-between;
            font-size: 0.7rem;
            color: #888;
        }
        
        .sensor-panel {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .sensor-status {
            display: flex;
            align-items: center;
            font-size: 0.85rem;
            color: #ccc;
        }
        
        .status-indicator-small {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 8px;
        }
        
        .status-active-small {
            background-color: #33cc33;
            box-shadow: 0 0 3px #33cc33;
        }
        
        .status-warning-small {
            background-color: #ffcc00;
            box-shadow: 0 0 3px #ffcc00;
        }
        
        .sensor-details {
            font-size: 0.75rem;
            color: #999;
            margin-left: 16px;
        }
        
        .plasma-data {
            margin-top: 15px;
        }
        
        .plasma-data-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 0.85rem;
        }
        
        .plasma-data-label {
            color: #ccc;
        }
        
        .plasma-data-value {
            font-family: 'Roboto Mono', monospace;
            color: var(--hypersonic-accent);
        }
        
        /* Signal Classification Styles from signal-classifier.html */
        .signal-card {
            background-color: rgba(40, 40, 80, 0.7);
            border-radius: 5px;
            padding: 10px;
            margin-bottom: 10px;
            cursor: pointer;
            transition: all 0.2s ease;
            border-left: 4px solid #333366;
        }
        
        .signal-card:hover {
            background-color: rgba(60, 60, 100, 0.7);
            transform: translateX(5px);
        }
        
        .signal-card.selected {
            border-left: 4px solid #00aaff;
            background-color: rgba(60, 60, 120, 0.7);
        }
        
        .feature-value {
            display: flex;
            justify-content: space-between;
            border-bottom: 1px dotted rgba(255, 255, 255, 0.2);
            margin-bottom: 5px;
            padding-bottom: 5px;
        }
        
        .feature-name {
            color: #aaddff;
        }
        
        .confidence-bar {
            height: 8px;
            background-color: rgba(51, 51, 102, 0.5);
            margin-top: 5px;
            border-radius: 5px;
            overflow: hidden;
        }
        
        .confidence-level {
            height: 100%;
            background-color: #00aaff;
            border-radius: 5px;
        }
        
        /* Spectrogram container styles */
        #spectrogramContainer {
            position: absolute;
            bottom: 20px;
            left: 20px;
            right: 20px;
            height: 120px;
            background-color: rgba(0, 0, 0, 0.7);
            border: 1px solid #00aaff;
            border-radius: 5px;
            user-select: none;
            z-index: 90;
        }
        
        #frequencyScale {
            position: absolute;
            bottom: 5px;
            left: 0;
            right: 0;
            display: flex;
            justify-content: space-between;
            padding: 0 10px;
            color: #aaddff;
            font-size: 12px;
        }
        
        /* Spectrogram media controls */
        #spectrogramControls {
            position: absolute;
            top: -30px;
            left: 0;
            right: 0;
            height: 30px;
            background-color: rgba(20, 20, 50, 0.8);
            border-top-left-radius: 5px;
            border-top-right-radius: 5px;
            display: flex;
            align-items: center;
            padding: 0 10px;
            border-bottom: 1px solid #00aaff;
        }
        
        .spec-control {
            background-color: #2c3e50;
            border: none;
            color: white;
            margin: 0 5px;
            padding: 3px 8px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .spec-control:hover {
            background-color: #3498db;
        }
        
        .spec-control.active {
            background-color: #00aaff;
        }
        
        /* Patrol Boat Styles */
        .switch {
            position: relative;
            display: inline-block;
            width: 40px;
            height: 20px;
            margin-left: 10px;
        }
        
        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
        }
        
        .slider:before {
            position: absolute;
            content: "";
            height: 14px;
            width: 14px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .4s;
        }
        
        input:checked + .slider {
            background-color: #2196F3;
        }
        
        input:checked + .slider:before {
            transform: translateX(20px);
        }
        
        .slider.round {
            border-radius: 34px;
        }
        
        .slider.round:before {
            border-radius: 50%;
        }
        
        #sensorInterval {
            background-color: rgba(42, 42, 42, 0.8);
            color: white;
            border: 1px solid #444;
            border-radius: 3px;
            padding: 2px 5px;
            margin-left: 10px;
        }
        
        .setting-description {
            font-size: 0.8em;
            color: #aaa;
            margin-top: 3px;
            margin-left: 24px;
        }
        
        #switchToMinimalBtn {
            background-color: #2a4d69;
        }
        
        #reloadBtn {
            background-color: #6c757d;
        }
        
        /* RF Hypergraph Styles */
        .hypergraph-controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .hypergraph-stats {
            margin-top: 20px;
        }
        
        .frequency-bands {
            margin: 15px 0;
        }
        
        .freq-band {
            display: inline-block;
            width: 15px;
            height: 15px;
            margin-right: 5px;
            border-radius: 50%;
            vertical-align: middle;
        }
        
        .band-legend {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 10px;
        }
        
        .band-item {
            display: flex;
            align-items: center;
            font-size: 0.8rem;
            color: #ccc;
        }
        
        .central-nodes {
            margin-top: 15px;
        }
        
        .node-item {
            margin-bottom: 8px;
            padding: 8px;
            background-color: rgba(64, 64, 160, 0.3);
            border-radius: 3px;
            font-size: 0.8rem;
        }
        
        .node-item strong {
            color: var(--hypersonic-accent);
        }
        
        #hypergraph-visualization {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 5;
            pointer-events: none;
        }
        
        #hypergraph-visualization.active {
            pointer-events: all;
        }
        
        /* Auto-Reconnaissance Alert Styles */
        .alert-item {
            padding: 6px 8px;
            margin-bottom: 4px;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        
        .alert-item:hover {
            filter: brightness(1.2);
        }
        
        .alert-item.threat-critical {
            background: rgba(255, 0, 0, 0.3);
            border-left: 3px solid #ff0000;
        }
        
        .alert-item.threat-high {
            background: rgba(255, 69, 0, 0.3);
            border-left: 3px solid #ff4500;
        }
        
        .alert-item.threat-medium {
            background: rgba(255, 165, 0, 0.3);
            border-left: 3px solid #ffa500;
        }
        
        .alert-item.threat-low {
            background: rgba(255, 255, 0, 0.2);
            border-left: 3px solid #ffff00;
        }
        
        .alert-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .alert-name {
            font-weight: bold;
            color: #fff;
        }
        
        .alert-threat {
            font-size: 9px;
            padding: 2px 6px;
            border-radius: 3px;
            background: rgba(0, 0, 0, 0.4);
        }
        
        .alert-details {
            display: flex;
            justify-content: space-between;
            font-size: 9px;
            color: #aaa;
            margin-top: 3px;
        }
        
        .no-alerts {
            padding: 8px;
            text-align: center;
            color: #666;
            font-style: italic;
        }
        
        /* Disposition color classes */
        .disp-unknown { color: #ffff00; }
        .disp-pending { color: #ffff00; }
        .disp-friend { color: #0000ff; }
        .disp-assumed-friend { color: #4444ff; }
        .disp-neutral { color: #00ff00; }
        .disp-suspicious { color: #ffa500; }
        .disp-hostile { color: #ff0000; }
        
        /* ============================================
           METRICS EXPLORER STYLES
           ============================================ */
        
        .metrics-explorer-section {
            background: rgba(37, 37, 37, 0.95);
            border-radius: 6px;
            padding: 12px;
            margin-bottom: 12px;
            border: 1px solid #444;
        }
        
        .metrics-explorer-section h4 {
            margin: 0 0 10px 0;
            font-size: 12px;
            color: #4a9eff;
            border-bottom: 1px solid #444;
            padding-bottom: 6px;
        }
        
        .metrics-explorer-section h5 {
            margin: 8px 0 6px 0;
            font-size: 11px;
            color: #888;
        }
        
        /* ============================================
           OPERATOR SESSION & MULTI-USER STYLES
           ============================================ */
        
        .operator-badge {
            display: inline-flex;
            align-items: center;
            padding: 4px 10px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: bold;
            color: #fff;
        }
        
        .operator-badge.role-admin {
            background: linear-gradient(135deg, #ff4444, #cc0000);
        }
        
        .operator-badge.role-supervisor {
            background: linear-gradient(135deg, #ff9f1c, #e67e00);
        }
        
        .operator-badge.role-operator {
            background: linear-gradient(135deg, #00aaff, #0077cc);
        }
        
        .operator-badge.role-observer {
            background: linear-gradient(135deg, #888, #666);
        }
        
        .not-logged-in {
            color: #888;
            font-style: italic;
            font-size: 11px;
        }
        
        /* Login Dialog */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
        }
        
        .modal-content {
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 8px;
            width: 90%;
            max-width: 500px;
            max-height: 90vh;
            overflow: hidden;
        }
        
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 16px;
            background: #222;
            border-bottom: 1px solid #333;
        }
        
        .modal-header h3 {
            margin: 0;
            color: #4a9eff;
            font-size: 16px;
        }
        
        .modal-header .close-btn {
            background: transparent;
            border: none;
            color: #888;
            font-size: 24px;
            cursor: pointer;
            padding: 0;
            line-height: 1;
        }
        
        .modal-header .close-btn:hover {
            color: #fff;
        }
        
        .modal-body {
            padding: 16px;
        }
        
        .form-tabs {
            display: flex;
            gap: 8px;
            margin-bottom: 16px;
        }
        
        .form-tabs .tab-btn {
            flex: 1;
            padding: 8px;
            background: #2a2a2a;
            border: 1px solid #444;
            color: #888;
            cursor: pointer;
            border-radius: 4px;
            transition: all 0.2s;
        }
        
        .form-tabs .tab-btn.active {
            background: #4a9eff;
            border-color: #4a9eff;
            color: #fff;
        }
        
        .tab-content {
            display: block;
            flex: 1;
            overflow-y: auto;
        }
        
        /* Panel visibility - only active panel shows */
        .tab-panel {
            display: none;
            padding: 10px;
        }
        
        .tab-panel.active {
            display: block;
        }
        
        .form-group {
            margin-bottom: 12px;
        }
        
        .form-group label {
            display: block;
            margin-bottom: 4px;
            color: #aaa;
            font-size: 12px;
        }
        
        .form-group input,
        .form-group select {
            width: 100%;
            padding: 10px;
            background: #2a2a2a;
            border: 1px solid #444;
            border-radius: 4px;
            color: #fff;
            font-size: 14px;
        }
        
        .form-group input:focus,
        .form-group select:focus {
            outline: none;
            border-color: #4a9eff;
        }
        
        .error-message {
            background: rgba(255, 0, 0, 0.2);
            border: 1px solid #ff4444;
            color: #ff6666;
            padding: 8px 12px;
            border-radius: 4px;
            margin-bottom: 12px;
            font-size: 12px;
        }
        
        .action-btn {
            width: 100%;
            padding: 12px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            transition: all 0.2s;
        }
        
        .action-btn.primary {
            background: linear-gradient(135deg, #4a9eff, #0077cc);
            color: #fff;
        }
        
        .action-btn.primary:hover {
            background: linear-gradient(135deg, #5aafff, #0088dd);
        }
        
        /* Operator Presence */
        .operator-presence-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 10px;
            background: rgba(42, 42, 42, 0.8);
            border-radius: 4px;
            margin-bottom: 4px;
            font-size: 12px;
        }
        
        .operator-presence-item.current-operator {
            background: rgba(74, 158, 255, 0.2);
            border: 1px solid rgba(74, 158, 255, 0.3);
        }
        
        .operator-presence-item .operator-icon {
            font-size: 14px;
        }
        
        .operator-presence-item .operator-callsign {
            flex: 1;
            font-weight: bold;
            color: #fff;
        }
        
        .operator-presence-item .operator-role {
            font-size: 10px;
            color: #888;
            text-transform: uppercase;
        }
        
        /* Room/Channel styles */
        .room-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 10px;
            margin-bottom: 4px;
            background: rgba(42, 42, 42, 0.8);
            border-radius: 4px;
            border-left: 3px solid transparent;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .room-item:hover {
            background: rgba(60, 60, 60, 0.9);
        }
        
        .room-item.joined {
            border-left-color: #00ff00;
            background: rgba(0, 60, 0, 0.4);
        }
        
        .room-item.active {
            border-left-color: #00aaff;
            background: rgba(0, 60, 100, 0.5);
        }
        
        .room-item .room-icon {
            font-size: 16px;
        }
        
        .room-item .room-info {
            flex: 1;
        }
        
        .room-item .room-name {
            font-weight: bold;
            color: #fff;
            font-size: 12px;
        }
        
        .room-item .room-meta {
            font-size: 10px;
            color: #888;
        }
        
        .room-item .room-actions {
            display: flex;
            gap: 4px;
        }
        
        .small-btn {
            padding: 4px 8px;
            font-size: 10px;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            background: rgba(60, 60, 60, 0.9);
            color: #fff;
            transition: all 0.2s ease;
        }
        
        .small-btn:hover {
            background: rgba(80, 80, 80, 0.9);
        }
        
        .small-btn.primary {
            background: rgba(0, 100, 200, 0.8);
        }
        
        .small-btn.primary:hover {
            background: rgba(0, 120, 230, 0.9);
        }
        
        .small-btn.danger {
            background: rgba(180, 50, 50, 0.8);
        }
        
        .small-btn.danger:hover {
            background: rgba(200, 70, 70, 0.9);
        }
        
        /* Chat message styles */
        .chat-message {
            padding: 4px 0;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        
        /* Navigation Menu Dropdown Styles */
        .nav-menu {
            position: relative;
            margin-bottom: 8px;
            z-index: 99998;  /* High z-index to ensure dropdown visibility */
        }
        
        .menu-button {
            width: 100%;
            padding: 10px 16px;
            background: linear-gradient(135deg, #2a2a2a, #1a1a1a);
            border: 1px solid #444;
            border-radius: 6px;
            color: #fff;
            font-weight: bold;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s ease;
            text-align: left;
        }
        
        .menu-button:hover {
            background: linear-gradient(135deg, #3a3a3a, #2a2a2a);
            border-color: #4a9eff;
        }
        
        .dropdown-menu {
            display: none;
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: rgba(30, 30, 30, 0.98);
            border: 1px solid #444;
            border-radius: 6px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.6);
            z-index: 99999 !important;  /* Very high z-index to ensure visibility */
            max-height: 70vh;
            overflow-y: auto;
            margin-top: 4px;
        }
        
        .dropdown-menu.show {
            display: block !important;
            visibility: visible !important;
            animation: dropdownSlide 0.2s ease-out;
        }
        
        @keyframes dropdownSlide {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        .dropdown-item {
            display: block;
            width: 100%;
            padding: 10px 16px;
            background: transparent;
            border: none;
            border-bottom: 1px solid #333;
            color: #ccc;
            font-size: 13px;
            text-align: left;
            cursor: pointer;
            transition: all 0.15s ease;
        }
        
        .dropdown-item:last-child {
            border-bottom: none;
        }
        
        .dropdown-item:hover {
            background: rgba(74, 158, 255, 0.2);
            color: #fff;
        }
        
        .dropdown-item:active {
            background: rgba(74, 158, 255, 0.3);
        }
        
        /* Console Container Styles */
        #command-console {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(0, 0, 0, 0.95);
            border-top: 2px solid #4a9eff;
            z-index: 500;
            max-height: 30vh;
            display: flex;
            flex-direction: column;
        }
        
        #console-output {
            flex: 1;
            overflow-y: auto;
            padding: 8px 12px;
            font-family: 'Roboto Mono', 'Consolas', monospace;
            font-size: 12px;
            line-height: 1.4;
            max-height: calc(30vh - 40px);
        }
        
        #console-input-container {
            display: flex;
            align-items: center;
            padding: 8px 12px;
            background: rgba(20, 20, 20, 0.95);
            border-top: 1px solid #333;
        }
        
        #console-prompt {
            color: #4a9eff;
            font-family: 'Roboto Mono', monospace;
            font-weight: bold;
            margin-right: 8px;
        }
        
        #console-input {
            flex: 1;
            background: transparent;
            border: none;
            color: #fff;
            font-family: 'Roboto Mono', monospace;
            font-size: 12px;
            outline: none;
        }
        
        #console-input::placeholder {
            color: #666;
        }
        
        /* Console line styles */
        .console-line {
            margin: 2px 0;
        }
        
        .console-timestamp {
            color: #666;
            margin-right: 8px;
        }
        
        .console-command {
            color: #4a9eff;
        }
        
        .console-response {
            color: #aaa;
        }
        
        .console-info {
            color: #00d4ff;
        }
        
        .console-alert {
            color: #ff6b6b;
        }
        
        .console-error {
            color: #ff4444;
        }
        
        .chat-message .sender {
            font-weight: bold;
            color: #0af;
        }
        
        .chat-message .time {
            font-size: 9px;
            color: #666;
            margin-left: 8px;
        }
        
        .chat-message .text {
            color: #ccc;
            word-wrap: break-word;
        }
        
        /* Entity sync indicator */
        .sync-indicator {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 11px;
        }
        
        .sync-indicator .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #888;
        }
        
        .sync-indicator .status-dot.connected {
            background: #00ff00;
            box-shadow: 0 0 6px #00ff00;
        }
        
        .sync-indicator .status-dot.disconnected {
            background: #ff4444;
        }
        
        /* ============================================
           POI LIST STYLES
           ============================================ */
        
        .poi-list-item {
            transition: background 0.2s ease;
        }
        
        .poi-list-item:hover {
            background: rgba(74, 158, 255, 0.15) !important;
        }
        
        #poi-list-container::-webkit-scrollbar {
            width: 6px;
        }
        
        #poi-list-container::-webkit-scrollbar-track {
            background: #2a2a2a;
        }
        
        #poi-list-container::-webkit-scrollbar-thumb {
            background: #555;
            border-radius: 3px;
        }
        
        #poi-list-container::-webkit-scrollbar-thumb:hover {
            background: #666;
        }
        
        #poi-category-filters label {
            transition: background 0.2s ease;
        }
        
        #poi-category-filters label:hover {
            background: rgba(74, 158, 255, 0.3) !important;
        }
        
        .metrics-summary-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            margin-bottom: 12px;
        }
        
        .metrics-summary-item {
            background: rgba(74, 158, 255, 0.1);
            border-radius: 4px;
            padding: 8px;
            text-align: center;
            border: 1px solid rgba(74, 158, 255, 0.2);
        }
        
        .summary-label {
            display: block;
            font-size: 9px;
            color: #888;
            margin-bottom: 4px;
        }
        
        .summary-value {
            display: block;
            font-size: 16px;
            font-weight: bold;
            color: #4a9eff;
            font-family: 'Roboto Mono', monospace;
        }
        
        .module-bars {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }
        
        .module-bar {
            display: flex;
            align-items: center;
            font-size: 10px;
        }
        
        .module-bar-label {
            width: 60px;
            color: #aaa;
            text-transform: capitalize;
        }
        
        .module-bar-fill {
            flex: 1;
            height: 14px;
            background: #333;
            border-radius: 3px;
            overflow: hidden;
            margin: 0 8px;
        }
        
        .module-bar-value {
            height: 100%;
            background: linear-gradient(90deg, #4a9eff, #00d4ff);
            transition: width 0.3s ease;
            border-radius: 3px;
        }
        
        .module-bar-count {
            width: 50px;
            text-align: right;
            color: #4a9eff;
            font-family: 'Roboto Mono', monospace;
        }
        
        .metrics-filters {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .filter-row {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .filter-row label {
            width: 50px;
            font-size: 10px;
            color: #888;
        }
        
        .metrics-filter-input {
            flex: 1;
            padding: 5px 8px;
            background: #2c2c2c;
            border: 1px solid #555;
            color: white;
            border-radius: 3px;
            font-size: 11px;
        }
        
        .metrics-filter-input:focus {
            outline: none;
            border-color: #4a9eff;
        }
        
        .metrics-table-container {
            max-height: 250px;
            overflow-y: auto;
            border-radius: 4px;
            border: 1px solid #444;
        }
        
        .metrics-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 10px;
        }
        
        .metrics-table th {
            background: #333;
            color: #4a9eff;
            padding: 6px 8px;
            text-align: left;
            position: sticky;
            top: 0;
            font-weight: 500;
        }
        
        .metrics-table td {
            padding: 5px 8px;
            border-bottom: 1px solid #3a3a3a;
            color: #ccc;
        }
        
        .metrics-table tr:hover td {
            background: rgba(74, 158, 255, 0.1);
        }
        
        .metrics-table .metric-value-cell {
            font-family: 'Roboto Mono', monospace;
            color: #4a9eff;
            text-align: right;
        }
        
        .metrics-table .metric-module-cell {
            color: #888;
        }
        
        .metrics-table .metric-time-cell {
            color: #666;
            font-family: 'Roboto Mono', monospace;
        }
        
        .interactions-list {
            max-height: 150px;
            overflow-y: auto;
        }
        
        .interaction-item {
            display: flex;
            align-items: flex-start;
            padding: 6px 0;
            border-bottom: 1px solid #3a3a3a;
            font-size: 10px;
        }
        
        .interaction-item:last-child {
            border-bottom: none;
        }
        
        .interaction-time {
            width: 55px;
            color: #666;
            font-family: 'Roboto Mono', monospace;
        }
        
        .interaction-action {
            flex: 1;
            color: #ccc;
        }
        
        .interaction-action strong {
            color: #4a9eff;
        }
        
        .interaction-target {
            color: #00d4ff;
            margin-left: 4px;
        }
        
        .live-stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
        }
        
        .live-stat {
            background: rgba(0, 212, 255, 0.1);
            border-radius: 4px;
            padding: 8px;
            text-align: center;
            border: 1px solid rgba(0, 212, 255, 0.2);
        }
        
        .live-stat-label {
            display: block;
            font-size: 9px;
            color: #888;
            margin-bottom: 2px;
        }
        
        .live-stat-value {
            display: block;
            font-size: 14px;
            font-weight: bold;
            color: #00d4ff;
            font-family: 'Roboto Mono', monospace;
        }
        
        /* Custom scrollbar for metrics panels */
        .metrics-table-container::-webkit-scrollbar,
        .interactions-list::-webkit-scrollbar {
            width: 6px;
        }
        
        .metrics-table-container::-webkit-scrollbar-track,
        .interactions-list::-webkit-scrollbar-track {
            background: #2a2a2a;
            border-radius: 3px;
        }
        
        .metrics-table-container::-webkit-scrollbar-thumb,
        .interactions-list::-webkit-scrollbar-thumb {
            background: #555;
            border-radius: 3px;
        }
        
        .metrics-table-container::-webkit-scrollbar-thumb:hover,
        .interactions-list::-webkit-scrollbar-thumb:hover {
            background: #666;
        }
    </style>
</head>
<body>
    <!-- Minimal UI error surface -->
    <div id="ui-error-banner" style="display:none; position:fixed; top:10px; right:10px; z-index:99999;
         background:#2b0b0b; color:#ffd6d6; border:1px solid #ff4d4d; padding:10px 12px; border-radius:8px;
         font-family: monospace; max-width: 520px; box-shadow: 0 10px 30px rgba(0,0,0,0.35);">
      <div style="font-weight:700; margin-bottom:6px;">UI ERROR</div>
      <div id="ui-error-text"></div>
    </div>
    <!-- Header with status indicators -->
    <div id="header">
        <div id="logo">
            <h1>RF SCYTHE - Command Operations Center</h1>
        </div>
        <div id="operational-status">
            <div class="status-indicator status-active">
                <div class="status-dot"></div>
                <span>SDR ACTIVE</span>
            </div>
            <div class="status-indicator status-active">
                <div class="status-dot"></div>
                <span>DRONE FLEET READY</span>
            </div>
            <div class="status-indicator status-warning">
                <div class="status-dot"></div>
                <span>GEOLOCATION: 4 TRANSMITTERS</span>
            </div>
            <div class="status-indicator status-alert">
                <div class="status-dot"></div>
                <span>FCC VIOLATIONS: 2</span>
            </div>
            <div class="status-indicator status-inactive" id="gemini-indicator">
                <div class="status-dot"></div>
                <span>GEMINI API: <span id="gemini-status">INACTIVE</span></span>
            </div>
        </div>
                <div id="header-actions" style="display:flex; gap:8px; align-items:center; margin-left:16px;">
                    <button id="menu-query-btn" class="btn" style="background:#08306b;padding:6px 10px;font-size:13px;">Queries</button>
                    <button id="show-operators-btn" class="btn ghost" style="padding:6px 10px;font-size:13px;">Show Operators</button>
                </div>
    </div>

    <!-- Main container with map and sidebar -->
    <div id="main-container">
        <!-- Cesium map container -->
        <div id="cesiumContainer">
            <div class="grid-overlay"></div>
            <!-- RF Hypergraph Visualization Container -->
            <div id="hypergraph-visualization"></div>

            <!-- AIS Target Popup (No Sidebar/InfoBox dependency) -->
            <div id="ais-recon-popup" style="position:absolute; left:20px; bottom:20px; z-index:9999; display:none; background:rgba(0,0,0,0.9); color:#fff; border:1px solid rgba(255,255,255,0.2); border-left: 4px solid #4a9eff; border-radius:6px; padding:12px 14px; font-family:'Segoe UI', system-ui, sans-serif; min-width:280px; box-shadow:0 8px 32px rgba(0,0,0,0.6); backdrop-filter: blur(8px);">
                <div style="display:flex; justify-content:space-between; align-items:flex-start; margin-bottom:12px;">
                    <div>
                        <div id="ais-recon-title" style="font-weight:700; font-size:14px; color:#4a9eff; letter-spacing:0.5px; text-transform:uppercase; margin-bottom:2px;">AIS Target</div>
                        <div id="ais-recon-subtitle" style="font-size:12px; color:#bbb; font-family:monospace;">Unknown Vessel</div>
                    </div>
                    <button id="ais-recon-close" style="background:transparent; border:none; color:#181818; font-size:20px; line-height:0.8; cursor:pointer; padding:0 4px; opacity:0.7;">&times;</button>
                </div>
                <!-- Action Grid -->
                <div style="display:grid; grid-template-columns:1fr 1fr; gap:8px;">
                     <button id="ais-recon-save" style="background:rgba(74, 158, 255, 0.2); border:1px solid #4a9eff; color:#fff; padding:8px; border-radius:4px; font-size:11px; cursor:pointer; font-weight:600; text-transform:uppercase; letter-spacing:0.5px; transition:all 0.2s;">
                        <span style="font-size:14px; display:block; margin-bottom:2px;">💾</span> Save Recon
                     </button>
                     <button id="ais-recon-track" style="background:rgba(255,255,255,0.1); border:1px solid rgba(255,255,255,0.2); color:#ddd; padding:8px; border-radius:4px; font-size:11px; cursor:pointer; font-weight:600; text-transform:uppercase; letter-spacing:0.5px; transition:all 0.2s;">
                        <span style="font-size:14px; display:block; margin-bottom:2px;">🎯</span> Track
                     </button>
                     <button id="ais-recon-flyto" style="background:rgba(255,255,255,0.1); border:1px solid rgba(255,255,255,0.2); color:#ddd; padding:8px; border-radius:4px; font-size:11px; cursor:pointer; font-weight:600; text-transform:uppercase; letter-spacing:0.5px; transition:all 0.2s;">
                        <span style="font-size:14px; display:block; margin-bottom:2px;">✈️</span> Fly To
                     </button>
                     <button id="ais-recon-ignore" style="background:rgba(255, 50, 50, 0.15); border:1px solid rgba(255, 50, 50, 0.4); color:#ffa0a0; padding:8px; border-radius:4px; font-size:11px; cursor:pointer; font-weight:600; text-transform:uppercase; letter-spacing:0.5px; transition:all 0.2s;">
                        <span style="font-size:14px; display:block; margin-bottom:2px;">🚫</span> Ignore
                     </button>
                </div>
            </div>

            
            <!-- Camera Navigation Controls -->
            <div id="camera-nav-controls">
                <!-- Compass indicator showing current heading -->
                <div id="compass-container">
                    <div id="compass-ring">
                        <div id="compass-needle"></div>
                        <span class="compass-label compass-n">N</span>
                        <span class="compass-label compass-e">E</span>
                        <span class="compass-label compass-s">S</span>
                        <span class="compass-label compass-w">W</span>
                    </div>
                    <button id="reset-north-btn" title="Reset to North">⬆</button>
                </div>
                <script>
                window.addEventListener('load', function(){
                    const satSource = document.getElementById('satSourceSelect');
                    const satIdsInput = document.getElementById('satIdsInput');
                    const satPopulateBtn = document.getElementById('satPopulateBtn');
                    const satPopulateStatus = document.getElementById('satPopulateStatus');

                    function getCesiumCameraObserver() {
                        try {
                            if (!window.viewer) return null;
                            const carto = Cesium.Cartographic.fromCartesian(window.viewer.camera.position);
                            const lon = Cesium.Math.toDegrees(carto.longitude);
                            const lat = Cesium.Math.toDegrees(carto.latitude);
                            const alt_km = (carto.height || 0) / 1000.0;
                            return { lat: parseFloat(lat.toFixed(6)), lon: parseFloat(lon.toFixed(6)), alt_km: parseFloat(alt_km.toFixed(3)) };
                        } catch (e) {
                            console.warn('Could not read Cesium camera position', e);
                            return null;
                        }
                    }

                    async function doPopulate() {
                        const source = satSource && satSource.value ? satSource.value : 'celestrak';
                        let payload = {};
                        const observer = getCesiumCameraObserver();
                        if (observer) payload.observer = observer;

                        if (source === 'n2yo') {
                            // parse IDs
                            const raw = satIdsInput && satIdsInput.value ? satIdsInput.value : '';
                            const ids = raw.split(',').map(s=>s.trim()).filter(Boolean).map(s=>parseInt(s,10)).filter(n=>!isNaN(n));
                            if (!ids.length) {
                                satPopulateStatus.textContent = 'Provide at least one NORAD ID for N2YO.';
                                return;
                            }
                            payload.source = 'n2yo';
                            payload.ids = ids;
                        } else {
                            // default: celestrak by category (use IDs input as category if provided)
                            const cat = satIdsInput && satIdsInput.value ? satIdsInput.value.trim() : 'starlink';
                            payload.category = cat || 'starlink';
                        }

                        satPopulateStatus.textContent = 'Populating...';
                        satPopulateBtn.disabled = true;

                        try {
                            const res = await fetch('/api/satellites/populate', {
                                method: 'POST', headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify(payload),
                            });
                            const data = await res.json();
                            if (data && data.status === 'ok') {
                                satPopulateStatus.textContent = `Populated ${data.processed || 0} from ${data.source || data.category || 'unknown'}`;
                                // trigger a refresh of satellite list/layer
                                if (window.initSatelliteRadarLayer && window._satRadarNeedsRefresh !== undefined) {
                                    // call existing fetch loop by toggling a timestamp flag
                                    window._satRadarNeedsRefresh = (new Date()).getTime();
                                }
                            } else {
                                satPopulateStatus.textContent = 'Populate failed: ' + (data && data.message ? data.message : JSON.stringify(data));
                            }
                        } catch (e) {
                            satPopulateStatus.textContent = 'Populate error: ' + e.message;
                        } finally {
                            satPopulateBtn.disabled = false;
                        }
                    }

                    satPopulateBtn && satPopulateBtn.addEventListener('click', doPopulate);
                });
                </script>
                <script>
                    // Nmap panel wiring: refresh history and attach buttons
                    function refreshNmapHistoryUI() {
                        try {
                            const hist = (typeof getNmapScanHistory === 'function') ? getNmapScanHistory() : [];
                            const el = document.getElementById('nmap-history');
                            const countEl = document.getElementById('nmap-history-count');
                            if (!el) return;
                            if (countEl) countEl.textContent = (hist && hist.length) ? hist.length : 0;
                            const items = (hist || []).slice().reverse().map(item => {
                                const t = item.target || item.targetNetwork || item.scanId || 'unknown';
                                const time = item.scanTime ? new Date(item.scanTime).toLocaleString() : (item.timestamp ? new Date(item.timestamp).toLocaleString() : 'N/A');
                                const hosts = (item.summary && item.summary.hosts) || item.hostsFound || item.hostsDiscovered || 0;
                                return `<div style="padding:6px 4px; border-bottom:1px solid rgba(255,255,255,0.03); font-size:12px;"><strong>${t}</strong><div style="color:#999; font-size:11px;">Hosts: ${hosts} • ${time}</div></div>`;
                            }).join('');
                            el.innerHTML = items || '<div style="color:#888; padding:6px;">No scan history</div>';
                        } catch (err) {
                            console.debug('[Nmap UI] refresh error', err);
                        }
                    }

                    document.addEventListener('DOMContentLoaded', function() {
                        try {
                            const geolBtn = document.getElementById('nmap-geolocate-btn');
                            const scanBtn = document.getElementById('nmap-scan-btn');
                            const input = document.getElementById('nmap-target-input');

                            if (geolBtn && input) {
                                // Add Chicago quick-fly handler
                                const chicagoBtn = document.getElementById('nmap-chicago-btn');
                                if (chicagoBtn) {
                                    chicagoBtn.addEventListener('click', function() {
                                        addConsoleMessage('Flying to Chicago, United States (41.88, -87.63)...', 'info');
                                        
                                        // "viewer" is a global let, likely not on window. Try both.
                                        let v = null;
                                        if (typeof viewer !== 'undefined') v = viewer;
                                        else if (typeof window.viewer !== 'undefined') v = window.viewer;

                                        if (v) {
                                            try {
                                                // Exemplary logic from AutoReconVisualization.flyToEntity
                                                // 1. Force unlock camera completely BEFORE flight
                                                v.camera.cancelFlight();
                                                v.camera.lookAtTransform(Cesium.Matrix4.IDENTITY);
                                                v.trackedEntity = undefined;
                                                v.selectedEntity = undefined;
                                                
                                                if (v.scene && v.scene.screenSpaceCameraController) {
                                                    const ctrlPre = v.scene.screenSpaceCameraController;
                                                    ctrlPre.enableRotate = ctrlPre.enableTilt = ctrlPre.enableZoom = ctrlPre.enableTranslate = ctrlPre.enableLook = true;
                                                }
                                                
                                                // 2. Fly directly to Chicago
                                                // 41.8781° N, 87.6298° W
                                                const dest = Cesium.Cartesian3.fromDegrees(-87.63, 41.88, 20000.0); // 20km altitude
                                                
                                                v.camera.flyTo({
                                                    destination: dest,
                                                    orientation: {
                                                        heading: v.camera.heading, // Maintain current heading
                                                        pitch: Cesium.Math.toRadians(-45),
                                                        roll: 0
                                                    },
                                                    duration: 1.5,
                                                    complete: function() {
                                                        addConsoleMessage('Arrived at Chicago', 'success');
                                                        // Reset camera transform to re-enable user control
                                                        try {
                                                            v.camera.lookAtTransform(Cesium.Matrix4.IDENTITY);
                                                            v.trackedEntity = undefined;
                                                            const controller = v.scene.screenSpaceCameraController;
                                                            controller.enableRotate = controller.enableTilt = controller.enableZoom = controller.enableTranslate = controller.enableLook = true;
                                                            
                                                            // Force render
                                                            v.scene.requestRender();
                                                        } catch (e) {
                                                            console.warn('[Nmap] Failed to reset camera after flyTo:', e);
                                                        }
                                                    },
                                                    cancel: function() {
                                                        addConsoleMessage('Flight cancelled', 'alert');
                                                        // Reset anyway
                                                        try {
                                                            v.camera.lookAtTransform(Cesium.Matrix4.IDENTITY);
                                                            v.trackedEntity = undefined;
                                                        } catch(e){}
                                                    }
                                                });
                                                
                                                // 3. Kick render loop
                                                if (v.scene) v.scene.requestRender();
                                                
                                            } catch (e) {
                                                console.error('[Nmap] Chicago flight error:', e);
                                                addConsoleMessage('Error: ' + e.message, 'alert');
                                            }
                                        } else {
                                            console.error('[Nmap] viewer not available');
                                            addConsoleMessage('Viewer not ready', 'alert');
                                        }
                                    });
                                }

                                geolBtn.addEventListener('click', async function() {
                                    const target = input.value.trim();
                                    if (!target) { addConsoleMessage('Please enter a target', 'alert'); return; }
                                    addConsoleMessage(`Geolocating ${target}...`, 'info');

                                    // Geolocate and fly
                                    const geo = await geolocateAndFlyToTarget(target);

                                    // If traceroute requested, perform a traceroute scan (lightweight)
                                    try {
                                        const tracerouteRequested = document.getElementById('nmap-traceroute')?.checked;
                                        if (tracerouteRequested) {
                                            addConsoleMessage(`Running traceroute for ${target}...`, 'info');
                                            try {
                                                await performEnhancedNmapScan(target, { traceroute: true, scriptScan: false });
                                            } catch (e) {
                                                console.warn('[Nmap UI] Traceroute failed', e);
                                            }
                                        }
                                    } catch (e) { console.debug('[Nmap UI] traceroute check failed', e); }

                                    if (geo) {
                                        addConsoleMessage(`Geolocated ${target}: ${geo.city || geo.country || ''}`,'response');
                                        refreshNmapHistoryUI();
                                    } else {
                                        addConsoleMessage(`Geolocation failed for ${target}`,'alert');
                                    }
                                });
                            }

                            if (scanBtn && input) {
                                scanBtn.addEventListener('click', async function() {
                                    const target = input.value.trim();
                                    if (!target) { addConsoleMessage('Please enter a target', 'alert'); return; }
                                    scanBtn.disabled = true;
                                    addConsoleMessage(`Starting scan on ${target}...`, 'info');

                                    // Collect options from UI
                                    const ports = document.getElementById('nmap-ports-input')?.value.trim();
                                    const timing = document.getElementById('nmap-timing-select')?.value;
                                    const scriptScan = !!document.getElementById('nmap-script-scan')?.checked;
                                    const osFingerprint = !!document.getElementById('nmap-os-fingerprint')?.checked;
                                    const vulnScan = !!document.getElementById('nmap-vuln-scan')?.checked;
                                    const rfCorrelation = !!document.getElementById('nmap-rf-correlation')?.checked;
                                    const hypergraph = !!document.getElementById('nmap-hypergraph')?.checked;
                                    const traceroute = !!document.getElementById('nmap-traceroute')?.checked;
                                    const ndpiCorrelate = !!document.getElementById('nmap-ndpi')?.checked;

                                    const options = {
                                        ports: ports || undefined,
                                        timing: timing || undefined,
                                        scriptScan: scriptScan,
                                        osFingerprint: osFingerprint,
                                        vulnScan: vulnScan,
                                        rfCorrelation: rfCorrelation,
                                        hypergraph: hypergraph,
                                        traceroute: traceroute,
                                        ndpiCorrelate: ndpiCorrelate
                                    };

                                    try {
                                        const result = await performEnhancedNmapScan(target, options);
                                        // NDPI convergence: optionally kick off an ndpi analyze after scan
                                        if (ndpiCorrelate) {
                                            try {
                                                handleNdpiCommand(['analyze', target]);
                                            } catch (e) {
                                                console.warn('[Nmap UI] NDPI correlation failed', e);
                                            }
                                        }

                                        refreshNmapHistoryUI();
                                    } catch (e) {
                                        addConsoleMessage(`Scan error: ${e && e.message ? e.message : e}`, 'alert');
                                    }

                                    scanBtn.disabled = false;
                                });
                            }

                            // Advanced help button
                            const helpBtn = document.getElementById('nmap-advanced-help');
                            if (helpBtn) {
                                helpBtn.addEventListener('click', function() {
                                    showNotification('Nmap Advanced Options', `Use the fields to set port ranges, timing templates (T1-T5), enable NSE scripts, OS fingerprinting, vulnerability scanning, traceroute collection, RF correlation and hypergraph export. Check 'NDPI Correlate' to run an NDPI analyze job after scan.`, 'info');
                                });
                            }

                            // Initial population
                            refreshNmapHistoryUI();
                        } catch (e) {
                            console.debug('[Nmap UI] Init error', e);
                        }
                    });
                </script>
                
                <!-- Zoom controls -->
                <div id="zoom-controls">
                    <button id="zoom-in-btn" title="Zoom In">+</button>
                    <button id="zoom-out-btn" title="Zoom Out">−</button>
                    <button id="zoom-home-btn" title="Reset View">🏠</button>
                </div>
                
                <!-- Tilt/Rotation controls -->
                <div id="tilt-controls">
                    <button id="tilt-up-btn" title="Tilt Up">↑</button>
                    <button id="tilt-down-btn" title="Tilt Down">↓</button>
                    <button id="rotate-left-btn" title="Rotate Left">↺</button>
                    <button id="rotate-right-btn" title="Rotate Right">↻</button>
                </div>
                
                <!-- Camera unlock button - visible after flyTo -->
                <button id="unlock-camera-btn" title="Unlock Camera" style="display: none;">🔓 Unlock</button>
            </div>
        </div>

        <!-- Command sidebar with operational info -->
        <div id="command-sidebar-right">
            <button id="sidebar-toggle">◀</button>
            
            <!-- Navigation Menu -->
            <div class="nav-menu">
                <button id="menu-toggle" class="menu-button">☰ MENU</button>
                <div id="dropdown-menu" class="dropdown-menu">
                    <button class="dropdown-item" onclick="showPanel('drones')">🚁 DRONES</button>
                    <button class="dropdown-item" onclick="showPanel('signals')">📡 SIGNALS</button>
                    <button class="dropdown-item" onclick="showPanel('violations')">⚠️ VIOLATIONS</button>
                    <button class="dropdown-item" onclick="showPanel('network')">🌐 NETWORK</button>
                    <button class="dropdown-item" onclick="showPanel('ais')">🚢 AIS TRAFFIC</button>
                    <button class="dropdown-item" onclick="showPanel('missiles')">🚀 MISSILES</button>
                    <button class="dropdown-item" onclick="showPanel('hypergraph')">🔗 HYPERGRAPH</button>
                    <button class="dropdown-item" onclick="openQueryBuilder()">📶 GRAPH QUERY BUILDER</button>
                    <button class="dropdown-item" onclick="showPanel('urh')">📻 URH</button>
                    <button class="dropdown-item" onclick="showPanel('nmap')">🗺️ NMAP</button>
                    <button class="dropdown-item" onclick="showPanel('recon')">🛰️ RECON</button>
                    <button class="dropdown-item" onclick="showPanel('sensors')">📡 SENSORS</button>
                    <button class="dropdown-item" onclick="showPanel('satellites')">🛰️ SATELLITES</button>
                    <button class="dropdown-item" onclick="showPanel('metrics')">📊 METRICS</button>
                    <button class="dropdown-item" onclick="showPanel('propagation')">📶 PROPAGATION</button>
                    <button class="dropdown-item" onclick="showPanel('poi')">📍 POINTS OF INTEREST</button>
                    <button class="dropdown-item" onclick="showPanel('operators')">👥 OPERATORS</button>
                    <button class="dropdown-item" onclick="showPanel('settings')">⚙️ SETTINGS</button>
                    <button class="dropdown-item" onclick="showPanel('missions')">🎯 MISSIONS</button>
                    <button class="dropdown-item" onclick="showPanel('lpi')">📉 LPI PROCESSING</button>
                    <button class="dropdown-item" onclick="showPanel('pcap')">📄 PCAP UPLOAD</button>
                </div>
            </div>
            
            <!-- Operator Status Bar -->
            <div class="operator-status-bar" style="display: flex; align-items: center; gap: 10px; padding: 8px 12px; background: rgba(30, 30, 30, 0.9); border-bottom: 1px solid #333; font-size: 12px;">
                <div class="sync-indicator">
                    <span class="status-dot" id="entity-sync-dot"></span>
                    <span id="entity-sync-status">Offline</span>
                </div>
                <div style="flex: 1;"></div>
                <div id="operator-status">
                    <span class="not-logged-in">Not logged in</span>
                </div>
                <button id="operator-login-btn" onclick="showOperatorLoginDialog()" style="padding: 4px 10px; background: #4a9eff; border: none; border-radius: 4px; color: #fff; cursor: pointer; font-size: 11px;">Login</button>
                <button id="operator-logout-btn" onclick="OperatorSession.logout()" style="display: none; padding: 4px 10px; background: #ff4444; border: none; border-radius: 4px; color: #fff; cursor: pointer; font-size: 11px;">Logout</button>
            </div>
            
            <div class="tab-content">
                <!-- Drones Tab -->
                <div class="tab-panel" id="drones-panel">
                    <div class="status-section">
                        <div class="status-header">
                            <h3 class="status-title">Active Drones</h3>
                            <span class="status-count">3</span>
                        </div>
                    </div>
                    <ul class="command-list" id="droneList">
                        <li class="list-item active">
                            <div class="list-item-header">
                                <span class="list-item-title">Drone 01</span>
                                <span class="status-dot" style="background-color: var(--success-green)"></span>
                            </div>
                            <div class="list-item-subtitle">
                                Status: Patrolling | Battery: 87%
                            </div>
                            <div class="list-item-actions">
                                <button class="action-button">Track</button>
                                <button class="action-button">Command</button>
                                <button class="action-button">RTB</button>
                            </div>
                        </li>
                        <li class="list-item">
                            <div class="list-item-header">
                                <span class="list-item-title">Drone 02</span>
                                <span class="status-dot" style="background-color: var(--warning-yellow)"></span>
                            </div>
                            <div class="list-item-subtitle">
                                Status: Pursuing | Battery: 54%
                            </div>
                            <div class="list-item-actions">
                                <button class="action-button">Track</button>
                                <button class="action-button">Command</button>
                                <button class="action-button">RTB</button>
                            </div>
                        </li>
                        <li class="list-item">
                            <div class="list-item-header">
                                <span class="list-item-title">Drone 03</span>
                                <span class="status-dot" style="background-color: var(--success-green)"></span>
                            </div>
                            <div class="list-item-subtitle">
                                Status: Idle | Battery: 92%
                            </div>
                            <div class="list-item-actions">
                                <button class="action-button">Track</button>
                                <button class="action-button">Command</button>
                                <button class="action-button">RTB</button>
                            </div>
                        </li>
                    </ul>
                </div>
                
                    <!-- Recon Entities Tab -->
                <div class="tab-panel active" id="recon-panel">
                    <div class="status-section">
                        <div class="status-header">
                            <h3 class="status-title">Recon Entities</h3>
                            <span class="status-count" id="recon-panel-count">0</span>
                        </div>
                    </div>
                    <div style="margin: 6px 0;">
                        <div style="display:flex; gap:6px;">
                            <button id="reconLoadBtn" class="action-button" style="flex:1; font-size:12px;">🔄 Load Entities</button>
                            <button id="reconAlertsBtn" class="action-button" style="font-size:12px;">⚠️ Alerts</button>
                        </div>
                    </div>
                    <div style="margin-top:8px; max-height:1024px; overflow-y:auto;">
                        <ul class="command-list" id="reconList">
                            <li class="list-item no-entities" style="color:#888; font-size:12px;">No recon entities loaded</li>
                        </ul>
                    </div>
                </div>

                <!-- Sensors Tab -->
                <div class="tab-panel" id="sensors-panel">
                    <div class="status-section">
                        <div class="status-header">
                            <h3 class="status-title">Sensors (Tx/Rx)</h3>
                            <span class="status-count" id="sensors-panel-count">0</span>
                        </div>
                        <div class="controls" style="display: flex; gap: 8px; margin-top: 8px;">
                            <button class="action-button" id="sensorLoadBtn">Load</button>
                            <button class="action-button" id="sensorCreateBtn">+ New Sensor</button>
                        </div>
                    </div>
                    
                    <!-- Sensor Creation Form (hidden by default) -->
                    <div id="sensor-create-form" style="display: none; padding: 12px; margin: 8px 0; background: rgba(30, 30, 30, 0.9); border-radius: 6px; border: 1px solid #333;">
                        <h4 style="margin: 0 0 12px 0; color: #4a9eff;">Create New Sensor</h4>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
                            <div>
                                <label style="font-size: 11px; color: #888;">Sensor Label</label>
                                <input type="text" id="sensor-label" placeholder="SENSOR-001" style="width: 100%; padding: 6px; background: #222; border: 1px solid #444; border-radius: 4px; color: #fff;">
                            </div>
                            <div>
                                <label style="font-size: 11px; color: #888;">Type</label>
                                <select id="sensor-type" style="width: 100%; padding: 6px; background: #222; border: 1px solid #444; border-radius: 4px; color: #fff;">
                                    <option value="SDR">SDR (Tx+Rx)</option>
                                    <option value="RADAR">RADAR</option>
                                    <option value="CAMERA">CAMERA</option>
                                    <option value="ACOUSTIC">ACOUSTIC</option>
                                    <option value="SIGINT">SIGINT</option>
                                </select>
                            </div>
                            <div>
                                <label style="font-size: 11px; color: #888;">Tx Frequency (MHz)</label>
                                <input type="number" id="sensor-tx-freq" placeholder="433.0" step="0.001" style="width: 100%; padding: 6px; background: #222; border: 1px solid #444; border-radius: 4px; color: #fff;">
                            </div>
                            <div>
                                <label style="font-size: 11px; color: #888;">Rx Frequency (MHz)</label>
                                <input type="number" id="sensor-rx-freq" placeholder="433.0" step="0.001" style="width: 100%; padding: 6px; background: #222; border: 1px solid #444; border-radius: 4px; color: #fff;">
                            </div>
                            <div>
                                <label style="font-size: 11px; color: #888;">Tx Power (dBm)</label>
                                <input type="number" id="sensor-tx-power" placeholder="20" style="width: 100%; padding: 6px; background: #222; border: 1px solid #444; border-radius: 4px; color: #fff;">
                            </div>
                            <div>
                                <label style="font-size: 11px; color: #888;">Rx Sensitivity (dBm)</label>
                                <input type="number" id="sensor-rx-sens" placeholder="-100" style="width: 100%; padding: 6px; background: #222; border: 1px solid #444; border-radius: 4px; color: #fff;">
                            </div>
                            <div>
                                <label style="font-size: 11px; color: #888;">Latitude</label>
                                <input type="number" id="sensor-lat" placeholder="34.0" step="0.000001" style="width: 100%; padding: 6px; background: #222; border: 1px solid #444; border-radius: 4px; color: #fff;">
                            </div>
                            <div>
                                <label style="font-size: 11px; color: #888;">Longitude</label>
                                <input type="number" id="sensor-lon" placeholder="-118.0" step="0.000001" style="width: 100%; padding: 6px; background: #222; border: 1px solid #444; border-radius: 4px; color: #fff;">
                            </div>
                            <div style="grid-column: 1 / -1;">
                                <label style="font-size: 11px; color: #888;">Assign to Recon Entity (optional)</label>
                                <select id="sensor-assign-entity" style="width: 100%; padding: 6px; background: #222; border: 1px solid #444; border-radius: 4px; color: #fff;">
                                    <option value="">-- None --</option>
                                </select>
                            </div>
                        </div>
                        <div style="display: flex; gap: 8px; margin-top: 12px; justify-content: flex-end;">
                            <button class="action-button" id="sensor-cancel-btn" style="background: #444;">Cancel</button>
                            <button class="action-button" id="sensor-save-btn" style="background: #4a9eff;">Save Sensor</button>
                        </div>
                    </div>
                    
                    <!-- Sensor List -->
                    <div style="margin-top:8px; max-height:600px; overflow-y:auto;">
                        <ul class="command-list" id="sensorList">
                            <li class="list-item no-entities" style="color:#888; font-size:12px;">No sensors loaded</li>
                        </ul>
                    </div>
                </div>


                <!-- LPI Processing Tab -->
                <div class="tab-panel" id="lpi-panel">
                    <div class="status-section">
                        <div class="status-header">
                            <h3 class="status-title">LPI Live Feed</h3>
                            <span class="status-count" id="lpi-event-count">0</span>
                        </div>
                         <div class="controls" style="display: flex; gap: 8px; margin-top: 8px;">
                            <button class="action-button" id="lpi-run-sim-btn" style="font-size:11px; background: #a62;">▶ Run Sim</button>
                            <button class="action-button" id="lpi-clear-btn" style="font-size:11px;">Clear Feed</button>
                            <label style="font-size:11px; display:flex; align-items:center; gap:4px; color:#888;">
                                <input type="checkbox" id="lpi-auto-scroll" checked> Auto-scroll
                            </label>
                        </div>
                    </div>
                    
                    <!-- LPI Processing Status / Summary Cards -->
                    <div id="lpi-summary-container" style="margin-top: 8px; display: grid; gap: 8px;">
                        <!-- Cards will be injected here -->
                        <div style="padding: 10px; background: rgba(30,30,30,0.6); border: 1px dashed #444; border-radius: 4px; text-align: center; color: #666; font-size: 12px;">
                            Waiting for signal activity...
                        </div>
                    </div>

                    <!-- LPI Event Feed -->
                    <div style="margin-top:12px;">
                        <div style="font-size:11px; color:#aaa; margin-bottom:4px; display:flex; justify-content:space-between;">
                            <span>EVENT LOG</span>
                            <span id="lpi-rate-indicator" style="color:#4a9eff">0 ev/s</span>
                        </div>
                        <div id="lpi-feed-container" style="height: 400px; overflow-y: auto; background: rgba(10,10,10,0.3); border: 1px solid #333; border-radius: 4px; padding: 4px;">
                            <ul class="command-list" id="lpiList">
                                <!-- Events -->
                            </ul>
                        </div>
                        
                        <!-- Details Panel (Collapsible) -->
                         <div id="lpi-details-panel" style="display:none; margin-top:8px; padding:8px; background:#111; border:1px solid #555; border-radius:4px;">
                             <div style="display:flex; justify-content:space-between; margin-bottom:4px;">
                                 <span style="font-weight:bold; color:#ddd; font-size:12px;">Event Payload</span>
                                 <button class="action-button" style="padding:1px 6px;" onclick="document.getElementById('lpi-details-panel').style.display='none'">x</button>
                             </div>
                             <pre id="lpi-details-json" style="font-size:10px; color:#8f8; overflow-x:auto; margin:0;"></pre>
                         </div>
                    </div>
                </div>

                <!-- PCAP Upload Panel -->
                <div class="tab-panel" id="pcap-panel">
                    <div class="status-section">
                        <div class="status-header">
                            <h3 class="status-title">PCAP Ingestion</h3>
                            <span class="status-count" id="pcap-job-status">Idle</span>
                        </div>
                    </div>
                    
                    <div class="settings-group" style="margin-top:12px;">
                        <h4>Upload Artifact</h4>
                        <div id="pcap-drop-zone" style="border: 2px dashed #444; border-radius: 6px; padding: 20px; text-align: center; color: #888; margin-bottom: 12px; cursor: pointer; transition: all 0.2s;">
                            <div style="font-size: 24px; margin-bottom: 8px;">📄</div>
                            <div>Drag & Drop PCAP file here</div>
                            <div style="font-size: 11px; margin-top: 4px;">or click to browse</div>
                            <input type="file" id="pcap-file-input" accept=".pcap,.pcapng,.cap" style="display: none;" />
                        </div>
                        
                        <div id="pcap-file-info" style="display: none; background: rgba(30,30,30,0.5); padding: 8px; border-radius: 4px; margin-bottom: 12px; font-size: 12px;">
                            <strong id="pcap-filename">filename.pcap</strong> <span id="pcap-filesize" style="color: #aaa;">(0 MB)</span>
                        </div>
                        
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-bottom: 12px;">
                            <div>
                                <label style="display: block; font-size: 11px; color: #aaa; margin-bottom: 4px;">Sensor ID</label>
                                <input id="pcap-sensor-id" type="text" placeholder="Optional" style="width: 100%; background: #111; color: white; border: 1px solid #444; padding: 4px; border-radius: 3px;" />
                            </div>
                            <div>
                                <label style="display: block; font-size: 11px; color: #aaa; margin-bottom: 4px;">Mission ID</label>
                                <input id="pcap-mission-id" type="text" placeholder="Optional" style="width: 100%; background: #111; color: white; border: 1px solid #444; padding: 4px; border-radius: 3px;" />
                            </div>
                        </div>
                        
                        <div style="margin-bottom: 12px;">
                             <label style="display: block; font-size: 11px; color: #aaa; margin-bottom: 4px;">Tags (comma separated)</label>
                             <input id="pcap-tags" type="text" placeholder="wan, ssh, practice" style="width: 100%; background: #111; color: white; border: 1px solid #444; padding: 4px; border-radius: 3px;" />
                        </div>

                        <button id="pcap-upload-btn" class="command-button primary" style="width: 100%;" disabled>Upload & Ingest</button>
                    </div>
                    
                    <div id="pcap-progress-container" style="display: none; margin-top: 12px;">
                        <div style="display: flex; justify-content: space-between; font-size: 11px; margin-bottom: 4px;">
                            <span id="pcap-progress-label">Ingesting...</span>
                            <span id="pcap-progress-percent">0%</span>
                        </div>
                        <div style="height: 6px; background: #333; border-radius: 3px; overflow: hidden;">
                            <div id="pcap-progress-bar" style="width: 0%; height: 100%; background: #4a9eff; transition: width 0.3s;"></div>
                        </div>
                    </div>
                    
                    <div class="settings-group" style="margin-top: 12px;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                            <h4 style="margin: 0;">Session History</h4>
                            <button id="pcap-load-sessions-btn" class="action-button" style="padding: 4px 8px; font-size: 10px;">Load Stored</button>
                        </div>
                        <div id="pcap-history-list" style="max-height: 280px; overflow-y: auto; font-size: 11px;">
                            <div class="list-placeholder">No upload history</div>
                        </div>
                    </div>
                </div>

                <!-- Missions Tab -->
                <div class="tab-panel" id="missions-panel">
                    <div class="status-section">
                        <div class="status-header">
                            <h3 class="status-title">Missions</h3>
                        </div>
                    </div>

                    <!-- Mission Header: name + phase + controls -->
                    <div id="mission-header" class="settings-group" style="display:flex; flex-direction:column; gap:8px; align-items:stretch; background-color: rgba(20,20,20,0.95); border-radius:6px; padding:10px; margin:8px 0; border:1px solid #333;">
                        <div style="display:flex; justify-content:space-between; align-items:center;">
                          <div style="flex:1; min-width: 220px;">
                              <div style="display:flex; align-items:center; gap:12px;">
                                  <div style="font-size:1.05rem; font-weight:700; color:#ffd166;" id="mission-header-name">(no mission loaded)</div>
                                  <div id="mission-header-badges" style="display:flex; gap:8px; align-items:center;"></div>
                              </div>

                              <div style="margin-top:6px; color:#aaa; font-size:12px; display:flex; gap:12px; align-items:center;">
                                  <div id="mission-header-owner">owner: -</div>
                                  <div id="mission-header-lastupdate">last: -</div>
                                  <div id="mission-header-doctrine">doctrine: -</div>
                              </div>
                          </div>
                        </div>

                        <div style="display:flex; gap:8px; align-items:center; justify-content:flex-end;">
                            <button id="missionActivateBtn2" style="padding:6px 10px; background:#2a9d8f; color:#fff; border-radius:4px; border: none;">Activate</button>
                            <button id="missionPauseBtn2" style="padding:6px 10px; background:#f4a261; color:#111; border-radius:4px; border: none;">Pause</button>
                            <button id="missionAbortBtn2" style="padding:6px 10px; background:#e63946; color:#fff; border-radius:4px; border: none;">Abort</button>
                            <button id="missionCloneBtn2" style="padding:6px 10px; background:#8ecae6; color:#111; border-radius:4px; border: none;">Clone</button>
                            <button id="missionExportAARBtn2" style="padding:6px 10px; background:#606c38; color:#fff; border-radius:4px; border: none;">Export AAR</button>
                        </div>
                    </div>

                    <div style="margin-top: 8px; display:grid; grid-template-columns: 1fr 320px; gap:12px;">
                        <div>
                            <div class="settings-group" style="margin-bottom:12px;">
                                <h4>Mission Control</h4>
                                <div style="display:flex; gap:8px; margin-bottom:8px;">
                                    <input id="missionIdInput2" placeholder="mission id" style="flex:1; padding:6px; background:#111; color:#fff; border:1px solid #444; border-radius:4px;" />
                                    <button id="missionJoinBtn2" style="padding:6px 10px; background:#264653; color:#fff; border-radius:4px; border: none;">Join</button>
                                    <button id="missionLeaveBtn2" style="padding:6px 10px; background:#9d0208; color:#fff; border-radius:4px; border: none;">Leave</button>
                                    <button id="missionSimulateIncursionBtn2" style="padding:6px 10px; background:#b5179e; color:#fff; border-radius:4px; border: none;">Simulate Incursion</button>
                                    <button id="missionSimulateMoveBtn2" style="padding:6px 10px; background:#3a86ff; color:#fff; border-radius:4px; border: none;">Simulate Move</button>
                                </div>

                                <div style="display:flex; gap:8px; align-items:center;">
                                    <label style="font-size:0.8rem; color:#aaa;">Auto-subscribe</label>
                                    <input id="missionAutoSubscribe2" type="checkbox" />
                                    <button id="missionSubscribeBtn2" style="padding:6px 10px; background:#2a9d8f; color:#fff; border-radius:4px; border: none;">Subscribe</button>
                                </div>
                            </div>

                            <!-- Missions Tasks List -->
                            <div class="settings-group">
                                <h4>Mission Tasks</h4>
                                <div id="missions-task-list">
                                    <div class="list-placeholder">No tasks loaded</div>
                                </div>
                            </div>

                            <!-- Triggers -->
                            <div class="settings-group" style="margin-top:12px;">
                                <h4>Triggers</h4>
                                <div id="mission-triggers">
                                    <div class="list-placeholder">No triggers loaded</div>
                                </div>
                            </div>

                            <!-- Timeline Strip -->
                            <div id="mission-timeline" style="margin-top:12px; height:84px; border-radius:6px; background:linear-gradient(90deg, rgba(30,30,30,0.6), rgba(20,20,20,0.6)); display:flex; flex-direction:column; padding:6px 8px; color:#ccc; font-size:12px;">
                                <div style="display:flex; align-items:center; gap:8px;">
                                    <button id="timelinePlayBtn" style="padding:6px 8px; background:#2a9d8f; color:#fff; border-radius:4px; border:none;">Play</button>
                                    <button id="timelinePauseBtn" style="padding:6px 8px; background:#f4a261; color:#111; border-radius:4px; border:none;">Pause</button>
                                    <label style="font-size:12px; color:#aaa;">Speed</label>
                                    <select id="timelineSpeed" style="background:#111; color:#fff; padding:4px; border-radius:4px;">
                                        <option value="0.25">0.25x</option>
                                        <option value="0.5">0.5x</option>
                                        <option value="1" selected>1x</option>
                                        <option value="2">2x</option>
                                        <option value="4">4x</option>
                                    </select>
                                    <div style="margin-left:auto; color:#9aa; font-size:12px;" id="timelineTimeLabel">—</div>
                                </div>
                                <div style="display:flex; align-items:center; gap:8px; margin-top:8px;">
                                    <input id="mission-timeline-scrub" type="range" min="0" max="0" value="0" style="flex:1;" />
                                    <button id="timelineStepBack" style="padding:6px 8px; background:#333; color:#fff; border-radius:4px; border:none;">◀</button>
                                    <button id="timelineStepForward" style="padding:6px 8px; background:#333; color:#fff; border-radius:4px; border:none;">▶</button>
                                </div>
                                <div id="timelineTicks" style="height:14px; margin-top:6px; position:relative; width:100%;">
                                    <!-- event ticks rendered here -->
                                </div>
                            </div>
                        </div>

                        <!-- Right column: Unit Card + Quick Actions -->
                        <div style="display:flex; flex-direction:column; gap:12px;">
                            <div class="settings-group" id="unit-card">
                                <h4>Unit Card</h4>
                                <div id="unit-card-body" style="color:#ccc; font-size:13px;">
                                    <div style="font-size:0.95rem; color:#ffd166;" id="unit-callsign">No unit selected</div>
                                    <div id="unit-role">role: -</div>
                                    <div id="unit-posture">posture: -</div>
                                    <div id="unit-order">order: -</div>

                                    <!-- Unit HUD -->
                                    <div id="unit-hud" style="margin-top:8px; font-size:13px; color:#cbd5e1;">
                                        <div style="display:flex; gap:8px; align-items:center;">
                                          <div style="flex:1; min-width:160px;">
                                            <div><strong>Speed:</strong> <span id="unit-hud-speed">-</span></div>
                                            <div><strong>Heading:</strong> <span id="unit-hud-heading">-</span></div>
                                            <div><strong>Altitude:</strong> <span id="unit-hud-altitude">-</span></div>
                                          </div>
                                          <div style="width:170px; text-align:right;">
                                            <canvas id="unit-hud-sparkline" class="sparkline-canvas" width="160" height="36"></canvas>
                                          </div>
                                        </div>

                                        <div style="margin-top:6px; display:flex; gap:8px; align-items:center; justify-content:space-between;">
                                          <div><strong>Last:</strong> <span id="unit-hud-lastupdate">-</span> &nbsp; <strong>Conf:</strong> <span id="unit-hud-confidence">-</span></div>
                                          <div style="display:flex; gap:6px; align-items:center;">
                                            <label style="font-size:12px; color:#aaa;">Units</label>
                                            <select id="unit-hud-units" style="background:#111; color:#fff; padding:4px; border-radius:4px;"> 
                                              <option value="m/s">m/s</option>
                                              <option value="km/h">km/h</option>
                                              <option value="knots">knots</option>
                                            </select>
                                          </div>
                                        </div>
                                    </div>

                                    <div style="margin-top:8px; display:flex; gap:8px; align-items:center;"><button id="unit-retask-btn" style="padding:6px 8px; background:#2a9d8f; color:#fff; border-radius:4px; border:none;">Retask</button><button id="unit-follow-btn" style="padding:6px 8px; background:#264653; color:#fff; border-radius:4px; border:none;">Follow</button></div>
                                </div>
                            </div>

                            <div class="settings-group" id="mission-doctrine-settings">
                                <h4>Doctrine</h4>
                                <div id="doctrine-body" style="color:#ccc; font-size:13px;">
                                    <div id="doctrine-brief">Stealth priority vs collection rate: <span id="doctrine-stealth">--</span></div>
                                    <div style="margin-top:8px;"><button id="doctrine-edit-btn" style="padding:6px 8px; background:#8ecae6; color:#111; border-radius:4px; border:none;">Edit Doctrine</button></div>
                                </div>
                            </div>
                        </div>
                    </div>

                </div>

                <script>
                document.addEventListener('DOMContentLoaded', function() {
                        const satSearchBtn = document.getElementById('satSearchBtn');
                        const satSearchInput = document.getElementById('satSearchInput');
                        const satList = document.getElementById('satList');
                        const satCount = document.getElementById('satellites-panel-count');
                        const satLoadAllBtn = document.getElementById('satLoadAllBtn');
                        const satAddDisplayedBtn = document.getElementById('satAddDisplayedBtn');

                        // Small UI: server-error toast stack (used for backend persist failures)
                        function _ensureServerToastContainer() {
                            if (document.getElementById('server-toast-container')) return document.getElementById('server-toast-container');
                            const c = document.createElement('div');
                            c.id = 'server-toast-container';
                            c.style.position = 'fixed';
                            c.style.right = '16px';
                            c.style.top = '16px';
                            c.style.zIndex = 99999;
                            c.style.display = 'flex';
                            c.style.flexDirection = 'column';
                            c.style.gap = '8px';
                            document.body.appendChild(c);
                            return c;
                        }

                        function showServerErrorToast(message, opts={}) {
                            try {
                                const container = _ensureServerToastContainer();
                                const toast = document.createElement('div');
                                toast.className = 'server-toast';
                                toast.style.minWidth = '280px';
                                toast.style.maxWidth = '420px';
                                toast.style.background = 'rgba(40,40,40,0.95)';
                                toast.style.color = '#fff';
                                toast.style.padding = '10px 12px';
                                toast.style.borderRadius = '6px';
                                toast.style.boxShadow = '0 6px 18px rgba(0,0,0,0.35)';
                                toast.style.fontSize = '13px';
                                toast.style.lineHeight = '1.2';
                                toast.style.display = 'flex';
                                toast.style.alignItems = 'flex-start';
                                toast.style.justifyContent = 'space-between';

                                const txt = document.createElement('div');
                                txt.style.marginRight = '8px';
                                txt.textContent = message;
                                toast.appendChild(txt);

                                const closeBtn = document.createElement('button');
                                closeBtn.textContent = '✕';
                                closeBtn.title = 'Dismiss';
                                closeBtn.style.background = 'transparent';
                                closeBtn.style.border = 'none';
                                closeBtn.style.color = '#ddd';
                                closeBtn.style.cursor = 'pointer';
                                closeBtn.style.fontSize = '12px';
                                closeBtn.style.padding = '0 6px';
                                closeBtn.addEventListener('click', () => { try { toast.remove(); } catch(e){} });
                                toast.appendChild(closeBtn);

                                container.prepend(toast);

                                const ttl = (opts.ttl_secs || 6) * 1000;
                                setTimeout(() => { try { toast.remove(); } catch(e){} }, ttl);
                            } catch (e) { console.warn('showServerErrorToast failed', e); }
                        }

                        // Helper: convert satellite record to Recon entity and add to AutoReconVisualization
                        window.addSatelliteToRecon = async function(sat) {
                            try {
                                if (!sat) return null;
                                const payload = {
                                    name: sat.name || sat.id || `sat_${Math.floor(Math.random()*10000)}`,
                                    location: { lat: parseFloat(sat.lat) || 0, lon: parseFloat(sat.lon) || 0, altitude_m: ((parseFloat(sat.altitude) || 0) * 1000) },
                                    disposition: sat.disposition || 'UNKNOWN',
                                    ontology: sat.ontology || 'satellite',
                                    source: 'satellite_ui',
                                    meta: sat
                                };

                                // Try to persist to backend. If server unavailable, fall back to client-only insertion.
                                try {
                                    const resp = await fetch('/api/recon/entity', {
                                        method: 'POST', headers: { 'Content-Type': 'application/json' },
                                        body: JSON.stringify(payload)
                                    });

                                    if (!resp.ok) {
                                        // Read body as text (may be HTML) and show friendly message
                                        let txt = '';
                                        try { txt = await resp.text(); } catch (e) { txt = resp.statusText || String(resp.status); }
                                        console.warn('Server persist responded with non-OK status', resp.status, txt);
                                        showServerErrorToast(`Server persist failed (${resp.status}) — saved locally instead`);
                                        throw new Error('Server persist failed');
                                    }

                                    // OK response — parse JSON
                                    let data = null;
                                    try {
                                        data = await resp.json();
                                    } catch (e) {
                                        // Server returned non-JSON despite 2xx; treat as failure
                                        const txt = await resp.text();
                                        console.warn('Server returned non-JSON response while creating recon entity', txt);
                                        showServerErrorToast('Server returned unexpected response; saved locally instead');
                                        throw new Error('Non-JSON response from server');
                                    }

                                    if (data && data.status === 'ok' && data.entity) {
                                        const entity = data.entity;
                                        // Normalize location to prevent downstream errors
                                        entity.location = entity.location || {};
                                        entity.location.lat = Number(entity.location.lat) || 0;
                                        entity.location.lon = Number(entity.location.lon) || 0;
                                        entity.location.altitude_m = Number(entity.location.altitude_m ?? entity.location.alt ?? 0) || 0;

                                        window.AutoReconVisualization = window.AutoReconVisualization || {};
                                        window.AutoReconVisualization.entities = window.AutoReconVisualization.entities || {};
                                        window.AutoReconVisualization.entities[entity.entity_id] = entity;
                                        if (window.AutoReconVisualization.addEntityMarker) window.AutoReconVisualization.addEntityMarker(entity);
                                        if (window.updateReconList) window.updateReconList();
                                        addConsoleMessage(`Added to Recon (server): ${entity.name}`, 'response');
                                        return entity;
                                    } else {
                                        showServerErrorToast('Server rejected entity; saved locally instead');
                                        throw new Error('Server rejected entity');
                                    }
                                } catch (err) {
                                    // Fallback to client-only behavior
                                    console.warn('Server persist failed, falling back to client-only recon insertion', err);
                                    const entId = `sat_${sat.id || (sat.name || '').replace(/\s+/g,'_')}`;
                                    const entity = {
                                        entity_id: entId,
                                        name: sat.name || entId,
                                        disposition: 'UNKNOWN',
                                        threat_level: 'NONE',
                                        location: { lat: Number(sat.lat) || 0, lon: Number(sat.lon) || 0, altitude_m: Number(sat.altitude) || 0 },
                                        ontology: ['satellite'],
                                        source: 'satellite_ui',
                                        meta: sat
                                    };
                                    // Ensure normalized numeric location fields
                                    entity.location.lat = Number(entity.location.lat) || 0;
                                    entity.location.lon = Number(entity.location.lon) || 0;
                                    entity.location.altitude_m = Number(entity.location.altitude_m) || 0;

                                    window.AutoReconVisualization = window.AutoReconVisualization || {};
                                    window.AutoReconVisualization.entities = window.AutoReconVisualization.entities || {};
                                    window.AutoReconVisualization.entities[entity.entity_id] = entity;
                                    if (window.AutoReconVisualization.addEntityMarker) window.AutoReconVisualization.addEntityMarker(entity);
                                    if (window.updateReconList) window.updateReconList();
                                    addConsoleMessage(`Added to Recon (client): ${entity.name}`, 'response');
                                    return entity;
                                }
                            } catch (err) {
                                console.error('addSatelliteToRecon error', err);
                                addConsoleMessage('addSatelliteToRecon error: ' + err.message, 'alert');
                                return null;
                            }
                        };

                        if (satAddDisplayedBtn) {
                            satAddDisplayedBtn.addEventListener('click', function() {
                                try {
                                    // Collect currently displayed satellites from the DOM list
                                    const items = satList ? Array.from(satList.querySelectorAll('.list-item')) : [];
                                    let added = 0;
                                    items.forEach(li => {
                                        try {
                                            // Try to parse dataset from buttons if present
                                            const title = li.querySelector('.list-item-title')?.textContent || '';
                                            const lat = li.querySelector('button[data-lat]')?.getAttribute('data-lat');
                                            const lon = li.querySelector('button[data-lon]')?.getAttribute('data-lon');
                                            const alt = (li.__satellite_object && li.__satellite_object.altitude) ? li.__satellite_object.altitude : undefined;
                                            const sat = { id: title.replace(/\s+/g,'_'), name: title, lat: lat, lon: lon, altitude: alt };
                                            const ent = window.addSatelliteToRecon(sat);
                                            if (ent) added++;
                                        } catch (e) { /* ignore per-item errors */ }
                                    });
                                    addConsoleMessage(`Added ${added} displayed satellites to Recon`, 'response');
                                } catch (err) {
                                    console.error('Add displayed to Recon failed', err);
                                    addConsoleMessage('Add displayed to Recon failed: ' + err.message, 'alert');
                                }
                            });
                        }

                    async function renderResults(items) {
                        satList.innerHTML = '';
                        if (!items || items.length === 0) {
                            satList.innerHTML = '<li class="list-item no-entities" style="color:#888; font-size:12px;">No satellites found</li>';
                            satCount.textContent = '0';
                            return;
                        }
                        satCount.textContent = items.length;
                        for (const s of items) {
                            const li = document.createElement('li');
                            li.className = 'list-item';
                            li.style.padding = '8px';
                            li.innerHTML = `
                                <div class="list-item-header">
                                    <span class="list-item-title">${s.name || 'Unknown'}</span>
                                    <span style="font-size:11px; color:#ccc;">${s.operator || ''} ${s.type?(' • '+s.type):''}</span>
                                </div>
                                <div class="feature-value" style="font-size:12px; color:#ddd;">
                                    <span class="feature-name">Orbit:</span>
                                    <span>${s.orbit || 'N/A'}</span>
                                </div>
                                    <div class="list-item-actions">
                                        <button class="action-button" data-lat="${s.lat}" data-lon="${s.lon}">Locate</button>
                                        <button class="action-button" data-details>Details</button>
                                        <button class="action-button" data-add-recon>Add to Recon</button>
                                    </div>
                            `;
                            // Attach original satellite object for later bulk operations
                            li.__satellite_object = s;
                            satList.appendChild(li);
                            // Attach listeners
                            const locateBtn = li.querySelector('button[data-lat]');
                            if (locateBtn) {
                                locateBtn.addEventListener('click', function() {
                                    const lat = parseFloat(this.getAttribute('data-lat'));
                                    const lon = parseFloat(this.getAttribute('data-lon'));
                                    if (!isNaN(lat) && !isNaN(lon) && window.viewer && window.viewer.camera) {
                                        window.viewer.camera.flyTo({destination: Cesium.Cartesian3.fromDegrees(lon, lat, (s.altitude || 400) * 1000), duration: 2});
                                    } else {
                                        console.log('Locate:', s.name, lat, lon);
                                        addConsoleMessage(`Locate satellite: ${s.name} (${lat}, ${lon})`, 'info');
                                    }
                                });
                            }
                            const detailsBtn = li.querySelector('button[data-details]');
                            if (detailsBtn) {
                                detailsBtn.addEventListener('click', function() {
                                    console.log('Satellite details:', s);
                                    addConsoleMessage(`Satellite details: ${s.name} — check console.`, 'response');
                                });
                            }

                            const addReconBtn = li.querySelector('button[data-add-recon]');
                            if (addReconBtn) {
                                addReconBtn.addEventListener('click', function() {
                                    try {
                                        if (window.addSatelliteToRecon) {
                                            window.addSatelliteToRecon(s);
                                        } else {
                                            // Fallback: directly inject into AutoReconVisualization
                                            const entId = `sat_${s.id || s.name}`;
                                            const entity = {
                                                entity_id: entId,
                                                name: s.name || entId,
                                                disposition: 'UNKNOWN',
                                                threat_level: 'NONE',
                                                location: { lat: parseFloat(s.lat) || 0, lon: parseFloat(s.lon) || 0, altitude_m: ((parseFloat(s.altitude) || 0) * 1000) },
                                                ontology: ['satellite'],
                                                source: 'satellite_ui'
                                            };
                                            window.AutoReconVisualization = window.AutoReconVisualization || {};
                                            window.AutoReconVisualization.entities = window.AutoReconVisualization.entities || {};
                                            window.AutoReconVisualization.entities[entity.entity_id] = entity;
                                            if (window.AutoReconVisualization.addEntityMarker) window.AutoReconVisualization.addEntityMarker(entity);
                                            if (window.updateReconList) window.updateReconList();
                                            addConsoleMessage(`Added to Recon: ${entity.name}`, 'response');
                                        }
                                    } catch (err) {
                                        console.error('Add to Recon failed', err);
                                        addConsoleMessage('Add to Recon failed: ' + err.message, 'alert');
                                    }
                                });
                            }
                        }
                    }

                    async function performSatSearch(q) {
                        try {
                            const params = new URLSearchParams();
                            if (q) params.set('name', q);
                            params.set('limit', '200');
                            const resp = await fetch(`/api/satellites?${params.toString()}`);
                            const data = await resp.json();
                            if (data && data.status === 'ok') {
                                await renderResults(data.satellites || []);
                            } else {
                                console.error('Satellite API error', data);
                                addConsoleMessage('Satellite search error', 'error');
                            }
                        } catch (err) {
                            console.error('Satellite search failed', err);
                            addConsoleMessage('Satellite search failed', 'error');
                        }
                    }

                    satSearchBtn && satSearchBtn.addEventListener('click', function(){ performSatSearch(satSearchInput.value); });
                    satSearchInput && satSearchInput.addEventListener('keydown', function(e){ if (e.key === 'Enter') performSatSearch(satSearchInput.value); });
                    satLoadAllBtn && satLoadAllBtn.addEventListener('click', function(){ performSatSearch(''); });

                    // Optionally load a small default set on first open
                    // performSatSearch('');
                });
                </script>

                <!-- Signals Tab -->
                <!-- Satellites Tab -->
                <div class="tab-panel" id="satellites-panel">
                    <div class="status-section">
                        <div class="status-header">
                            <h3 class="status-title">Satellites</h3>
                            <span class="status-count" id="satellites-panel-count">0</span>
                        </div>
                    </div>
                    <div style="margin: 6px 0; display:flex; gap:6px; align-items:center;">
                        <input id="satSearchInput" placeholder="Search satellites by name or operator" style="flex:1; padding:6px; font-size:12px;" />
                        <button id="satSearchBtn" class="action-button" style="font-size:12px;">🔎 Search</button>
                        <button id="satLoadAllBtn" class="action-button" style="font-size:12px;">📥 Load All</button>
                    </div>
                    <div style="margin: 6px 0; display:flex; gap:6px; align-items:center;">
                        <select id="satSourceSelect" style="padding:6px;font-size:12px;width:120px;">
                            <option value="celestrak">Celestrak (by category)</option>
                            <option value="n2yo">N2YO (by IDs)</option>
                        </select>
                        <input id="satIdsInput" placeholder="NORAD IDs (comma-separated)" style="flex:1; padding:6px; font-size:12px;" />
                    </div>
                    <div style="margin: 6px 0; display:flex; gap:6px; align-items:center;">
                        <button id="satPopulateBtn" class="action-button" style="background-color:#ff8c00;font-size:12px;">🚀 Populate</button>
                        <button id="satAddDisplayedBtn" class="action-button" style="background-color:#2b9d3a;font-size:12px;">➕ Add Displayed To Recon</button>
                    </div>
                    <div id="satPopulateStatus" style="font-size:12px;color:#666;margin-top:6px">Populate status: idle</div>
                    <div style="margin-top:8px; max-height:320px; overflow-y:auto;">
                        <ul class="command-list" id="satList">
                            <li class="list-item no-entities" style="color:#888; font-size:12px;">No satellites loaded</li>
                        </ul>
                    </div>
                </div>

                <div class="tab-panel" id="signals-panel">
                    <div class="status-section">
                        <div class="status-header">
                            <h3 class="status-title">Active Signals</h3>
                            <span class="status-count">7</span>
                        </div>
                        <div style="display: flex; justify-content: space-between; margin-bottom: 10px;">
                            <button id="scanSpectrumBtn" class="action-button" style="background-color: #3a6fc4; font-size: 12px;">Scan Spectrum</button>
                            <button id="classifyAllBtn" class="action-button" style="background-color: #2a9d3a; font-size: 12px;">Classify All</button>
                        </div>
                    </div>
                    <ul class="command-list" id="signalList">
                        <li class="signal-card">
                            <div class="list-item-header">
                                <span class="list-item-title">145.350 MHz</span>
                                <span style="background-color: #55ff55; padding: 2px 6px; border-radius: 3px; font-size: 11px;">FM</span>
                            </div>
                            <div class="feature-value">
                                <span class="feature-name">Signal Strength:</span>
                                <span>-65 dBm</span>
                            </div>
                            <div class="feature-value">
                                <span class="feature-name">Bandwidth:</span>
                                <span>15 kHz</span>
                            </div>
                            <div class="confidence-bar">
                                <div class="confidence-level" style="width: 89%;"></div>
                            </div>
                            <div class="list-item-actions">
                                <button class="action-button">Locate</button>
                                <button class="action-button">Analyze</button>
                            </div>
                        </li>
                        <li class="signal-card">
                            <div class="list-item-header">
                                <span class="list-item-title">433.920 MHz</span>
                                <span style="background-color: #5555ff; padding: 2px 6px; border-radius: 3px; font-size: 11px;">SSB</span>
                            </div>
                            <div class="feature-value">
                                <span class="feature-name">Signal Strength:</span>
                                <span>-42 dBm</span>
                            </div>
                            <div class="feature-value">
                                <span class="feature-name">Bandwidth:</span>
                                <span>2.5 kHz</span>
                            </div>
                            <div class="confidence-bar">
                                <div class="confidence-level" style="width: 76%;"></div>
                            </div>
                            <div class="list-item-actions">
                                <button class="action-button">Locate</button>
                                <button class="action-button">Analyze</button>
                            </div>
                        </li>
                        <li class="signal-card">
                            <div class="list-item-header">
                                <span class="list-item-title">915.880 MHz</span>
                                <span style="background-color: #ff55ff; padding: 2px 6px; border-radius: 3px; font-size: 11px;">PSK</span>
                            </div>
                            <div class="feature-value">
                                <span class="feature-name">Signal Strength:</span>
                                <span>-58 dBm</span>
                            </div>
                            <div class="feature-value">
                                <span class="feature-name">Bandwidth:</span>
                                <span>30 kHz</span>
                            </div>
                            <div class="confidence-bar">
                                <div class="confidence-level" style="width: 95%;"></div>
                            </div>
                            <div class="list-item-actions">
                                <button class="action-button">Locate</button>
                                <button class="action-button">Analyze</button>
                            </div>
                        </li>
                    </ul>
                    <div style="margin-top: 15px;">
                        <h3 style="font-size: 14px; color: #aaddff;">Signal Classification</h3>
                        <div id="signalDetails" style="background-color: rgba(20, 20, 50, 0.5); padding: 10px; border-radius: 5px; font-size: 12px;">
                            <p>Select a signal to view AI classification details</p>
                        </div>
                    </div>
                </div>
                
                <!-- Violations Tab -->
                <div class="tab-panel" id="violations-panel">
                    <div class="status-section">
                        <div class="status-header">
                            <h3 class="status-title">FCC Violations</h3>
                            <span class="status-count">2</span>
                        </div>
                        <div style="display: flex; justify-content: space-between; margin-bottom: 10px;">
                            <button id="scanViolationsBtn" class="action-button" style="background-color: #c93840; font-size: 12px;">Scan for Violations</button>
                            <button id="reportViolationsBtn" class="action-button" style="background-color: #3a6fc4; font-size: 12px;">Generate Report</button>
                        </div>
                    </div>
                    <ul class="command-list" id="violationList">
                        <li class="signal-card violation">
                            <div class="list-item-header">
                                <span class="list-item-title">162.475 MHz</span>
                                <span style="background-color: #c93840; padding: 2px 6px; border-radius: 3px; font-size: 11px;">UNLICENSED</span>
                            </div>
                            <div class="feature-value">
                                <span class="feature-name">Signal Strength:</span>
                                <span>-38 dBm</span>
                            </div>
                            <div class="feature-value">
                                <span class="feature-name">Violation Type:</span>
                                <span>Unlicensed Operation</span>
                            </div>
                            <div class="feature-value">
                                <span class="feature-name">AI Classification:</span>
                                <span>PSK (Data Transmission)</span>
                            </div>
                            <div class="confidence-bar">
                                <div class="confidence-level" style="width: 93%; background-color: #c93840;"></div>
                            </div>
                            <div class="list-item-actions">
                                <button class="action-button">Geolocate</button>
                                <button class="action-button danger">Pursue</button>
                            </div>
                        </li>
                        <li class="signal-card violation">
                            <div class="list-item-header">
                                <span class="list-item-title">915.200 MHz</span>
                                <span style="background-color: #e7a212; padding: 2px 6px; border-radius: 3px; font-size: 11px;">SUSPICIOUS</span>
                            </div>
                            <div class="feature-value">
                                <span class="feature-name">Signal Strength:</span>
                                <span>-55 dBm</span>
                            </div>
                            <div class="feature-value">
                                <span class="feature-name">Violation Type:</span>
                                <span>Potential Out-of-Band</span>
                            </div>
                            <div class="feature-value">
                                <span class="feature-name">AI Classification:</span>
                                <span>FSK (Encrypted Data)</span>
                            </div>
                            <div class="confidence-bar">
                                <div class="confidence-level" style="width: 78%; background-color: #e7a212;"></div>
                            </div>
                            <div class="list-item-actions">
                                <button class="action-button">Geolocate</button>
                                <button class="action-button danger">Pursue</button>
                                <button class="action-button">Analyze</button>
                            </div>
                        </li>
                    </ul>
                    <div id="violator-details" style="margin-top: 15px; padding: 10px; background-color: rgba(201, 56, 64, 0.1); border-radius: 5px; border-left: 3px solid #c93840;">
                        <h3 style="font-size: 14px; margin-top: 0; color: #c93840;">Gemini AI Analysis</h3>
                        <p style="font-size: 12px; margin: 5px 0;">Potential mobile data transmitter detected at 162.475 MHz. Signal characteristics match unauthorized IoT device. Recommend drone deployment for visual identification.</p>
                        <div style="display: flex; justify-content: flex-end; margin-top: 5px;">
                            <button class="action-button" style="background-color: #c93840; font-size: 11px;">Run Deep Analysis</button>
                        </div>
                    </div>
                </div>

                <!-- Nmap Geolocation Tab -->
                <div class="tab-panel" id="nmap-panel">
                    <div class="status-section">
                        <div class="status-header">
                            <h3 class="status-title">Nmap Geolocation</h3>
                            <span class="status-count" id="nmap-history-count">0</span>
                        </div>
                        <div style="display:flex; gap:8px; align-items:center; margin:8px 0 12px 0;">
                            <input id="nmap-target-input" placeholder="host or IP (e.g., scanme.nmap.org)" style="flex:1; padding:6px; font-size:13px;" />
                            <button id="nmap-geolocate-btn" class="action-button" style="padding:6px 10px;">Geolocate & Fly</button>
                            <button id="nmap-chicago-btn" class="action-button" style="padding:6px 10px; background:#3a6fc4;">Chicago</button>
                            <button id="nmap-scan-btn" class="action-button" style="padding:6px 10px; background:#22c55e; color:#fff;">Scan</button>
                        </div>

                        <div style="display:flex; gap:8px; align-items:center; margin:6px 0 12px 0; flex-wrap:wrap;">
                            <input id="nmap-ports-input" placeholder="ports (e.g., 80,443 or top/all)" style="padding:6px; font-size:12px; width:180px;" />
                            <select id="nmap-timing-select" style="padding:6px; font-size:12px;">
                                <option value="">Timing</option>
                                <option value="1">T1 (paranoid)</option>
                                <option value="2">T2 (polite)</option>
                                <option value="3">T3 (normal)</option>
                                <option value="4">T4 (aggressive)</option>
                                <option value="5">T5 (insane)</option>
                            </select>
                            <label style="font-size:12px;"><input type="checkbox" id="nmap-script-scan"/> NSE Scripts</label>
                            <label style="font-size:12px;"><input type="checkbox" id="nmap-os-fingerprint"/> OS Fingerprint</label>
                            <label style="font-size:12px;"><input type="checkbox" id="nmap-vuln-scan"/> Vulnerability Scan</label>
                            <label style="font-size:12px;"><input type="checkbox" id="nmap-rf-correlation"/> RF Correlation</label>
                            <label style="font-size:12px;"><input type="checkbox" id="nmap-hypergraph"/> Hypergraph</label>
                        </div>

                        <div style="display:flex; gap:8px; align-items:center; margin:6px 0 12px 0;">
                            <label style="font-size:12px;"><input type="checkbox" id="nmap-traceroute"/> Run Traceroute</label>
                            <label style="font-size:12px;"><input type="checkbox" id="nmap-ndpi"/> NDPI Correlate</label>
                            <span style="flex:1"></span>
                            <button id="nmap-advanced-help" class="action-button" style="padding:4px 8px; font-size:11px;">Help</button>
                        </div>
                        <div id="nmap-history" style="max-height:180px; overflow:auto; font-size:12px; border-top:1px solid rgba(255,255,255,0.03); padding-top:8px;"></div>
                    </div>
                </div>
                
                <!-- Network Infrastructure Tab -->
                <div class="tab-panel" id="network-panel">
                    <div class="status-section">
                        <div class="status-header">
                            <h3 class="status-title">Network Infrastructure</h3>
                            <span class="status-count" id="network-elements-count">0</span>
                        </div>
                        <div style="display: flex; justify-content: space-between; margin-bottom: 10px;">
                            <button id="scanNetworkBtn" class="action-button" style="background-color: #3a6fc4; font-size: 12px;">Scan Infrastructure</button>
                            <button id="trackViolatorsBtn" class="action-button" style="background-color: #c93840; font-size: 12px;">Track FCC Violators</button>
                            <button id="captureNetworkBtn" class="action-button" style="background-color: #2a9d3a; font-size: 12px;">Capture Traffic</button>
                        </div>
                    </div>

                    <div class="settings-group">
                        <h4>Network Layers</h4>
                        <div class="settings-item">
                            <label>
                                <input type="checkbox" id="toggleUnderseaCables" checked> Show Undersea Cables
                            </label>
                        </div>
                        <div class="settings-item">
                            <label>
                                <input type="checkbox" id="toggleSatellites" checked> Show Satellites
                            </label>
                        </div>
                        <div class="settings-item">
                            <label>
                                <input type="checkbox" id="toggleCellTowers" checked> Show 5G/Cell Towers
                            </label>
                        </div>
                        <div class="settings-item">
                            <label>
                                <input type="checkbox" id="toggleFiberBackbones" checked> Show Fiber Backbones
                            </label>
                        </div>
                        <div class="settings-group" id="satellites-controls" style="margin-top:8px;">
                            <h4>Satellites</h4>
                            <div class="settings-item">
                                <button id="searchSatellitesBtn" class="action-button" style="background:#3a6fc4;">🔭 Search This Area</button>
                                <button id="clearSatelliteResultsBtn" class="action-button" style="margin-left:8px;">Clear</button>
                            </div>
                            <div id="satellite-results-list" style="max-height:200px; overflow:auto; font-size:12px; margin-top:8px; background:rgba(0,0,0,0.15); padding:6px; border-radius:4px;">
                                <div style="color:#888;">No satellites searched yet</div>
                            </div>
                        </div>

                        
                        <!-- AUTO-RECONNAISSANCE TOGGLE -->
                        <div class="settings-item">
                            <label>
                                <input type="checkbox" id="toggleReconEntities"> Show Recon Entities
                            </label>
                            <span class="status-count" id="recon-entity-count" style="margin-left: 8px; font-size: 10px;">0</span>
                            <span class="status-count" id="recon-alert-count" style="margin-left: 4px; font-size: 10px; color: #ff6b6b;">⚠️0</span>
                        </div>
                        <div style="margin-left: 20px; display: none;" id="reconFilters">
                            <div style="margin: 5px 0; font-size: 11px;">
                                <label><input type="checkbox" id="reconShowRings" checked> Show Proximity Rings</label>
                            </div>
                            <div style="margin: 5px 0; font-size: 11px;">
                                <label><input type="checkbox" id="reconShowLabels" checked> Show Entity Labels</label>
                            </div>
                            <div style="margin: 5px 0; font-size: 11px;">
                                <label><input type="checkbox" id="reconAutoUpdate"> Auto-update (Simulate)</label>
                            </div>
                            <div style="margin: 5px 0;">
                                <button id="reconSetReference" class="action-button" style="font-size: 10px; padding: 4px 8px;">📍 Set Reference Point</button>
                            </div>
                            <div style="margin: 5px 0;">
                                <button id="reconCheckAlerts" class="action-button" style="font-size: 10px; padding: 4px 8px;">⚠️ Check Alerts</button>
                            </div>
                            
                            <!-- Alert List -->
                            <div style="margin-top: 8px; max-height: 150px; overflow-y: auto;">
                                <div style="font-size: 10px; color: #4a9eff; margin-bottom: 5px;">Proximity Alerts:</div>
                                <div id="recon-alert-list" style="font-size: 10px;">
                                    <div class="no-alerts" style="color: #888;">No active alerts</div>
                                </div>
                            </div>
                        </div>
                        
                        <!-- LOS ANALYSIS TOGGLE -->
                        <div class="settings-item">
                            <label>
                                <input type="checkbox" id="toggleLOSAnalysis"> 📡 LOS Analysis
                            </label>
                            <span class="status-count" id="los-viewshed-count" style="margin-left: 8px; font-size: 10px;">0</span>
                        </div>
                        <div style="margin-left: 20px; display: none;" id="losFilters">
                            <div style="margin: 5px 0; font-size: 11px;">
                                <label>FOV: <span id="losFovValue">60</span>°:</label>
                                <input type="range" id="losFovSlider" min="30" max="180" value="60" style="width: 80px; margin-left: 5px;">
                            </div>
                            <div style="margin: 5px 0; font-size: 11px;">
                                <label>Range: <span id="losRangeValue">20</span> km:</label>
                                <input type="range" id="losRangeSlider" min="5" max="100" value="20" style="width: 80px; margin-left: 5px;">
                            </div>
                            <div style="margin: 5px 0;">
                                <button id="losAddTowerViewshed" class="action-button" style="font-size: 10px; padding: 4px 8px;">🗼 Add Tower LOS</button>
                            </div>
                            <div style="margin: 5px 0;">
                                <button id="losClearAll" class="action-button" style="font-size: 10px; padding: 4px 8px;">❌ Clear All LOS</button>
                            </div>
                        </div>
                        
                        <div class="settings-item">
                            <label>
                                <input type="checkbox" id="showHypergraphOverlay"> Hypergraph Overlay
                            </label>
                            <div style="margin-left: 20px; margin-top: 5px; font-size: 10px; color: #aaa;">RF signal hypergraph interactions</div>
                        </div>
                        <div style="margin-left: 20px; display: none;" id="hypergraphFilters">
                            <div style="margin: 5px 0; font-size: 11px;">
                                <label>Cardinality ≤ <span id="cardinalityValue">5</span>:</label>
                                <input type="range" id="hypergraphCardinalityFilter" min="2" max="5" value="5" style="width: 80px; margin-left: 5px;">
                            </div>
                            <div style="margin: 5px 0; font-size: 11px;">
                                <label>Strength ≥ <span id="strengthValue">-90</span> dBm:</label>
                                <input type="range" id="hypergraphStrengthFilter" min="-120" max="-40" value="-90" style="width: 80px; margin-left: 5px;">
                            </div>
                        </div>
                    </div>

                    <div id="network-infra-details" style="margin-top: 15px; padding: 10px; background-color: rgba(45, 100, 160, 0.1); border-radius: 5px; border-left: 3px solid #3a6fc4;">
                        <h3 style="font-size: 14px; margin-top: 0; color: #3a6fc4;">Network Infrastructure</h3>
                        <p style="font-size: 12px; margin: 5px 0;">Select a network element on the map to view details. The network infrastructure visualization helps track FCC violators that jump between hardline and radio connections.</p>
                    </div>

                    <div class="status-section" style="margin-top: 15px;">
                        <div class="status-header">
                            <h3 class="status-title">Cross-infrastructure Violations</h3>
                        </div>
                        <ul class="command-list" id="cross-network-violations">
                            <!-- Cross-network violations will be added here -->
                        </ul>
                    </div>
                    
                    <!-- Hypergraph Metrics Dashboard -->
                    <div id="hypergraph-metrics" style="display: none; margin-top: 15px; padding: 10px; background-color: rgba(74, 158, 255, 0.1); border-radius: 5px; border-left: 3px solid #4a9eff;">
                        <h4 style="font-size: 12px; margin: 0 0 10px 0; color: #4a9eff;">📊 RF Hypergraph Metrics</h4>
                        
                        <div class="analysis-grid" style="display: grid; grid-template-columns: 1fr 1fr; gap: 5px; margin-bottom: 10px;">
                            <div class="analysis-item" style="font-size: 10px;">
                                <span class="analysis-label">RF Nodes:</span>
                                <span class="analysis-value" id="hypergraphNodes">0</span>
                            </div>
                            <div class="analysis-item" style="font-size: 10px;">
                                <span class="analysis-label">Hyperedges:</span>
                                <span class="analysis-value" id="hypergraphEdges">0</span>
                            </div>
                            <div class="analysis-item" style="font-size: 10px;">
                                <span class="analysis-label">Session:</span>
                                <span class="analysis-value" id="hypergraphSession" style="font-size: 9px;">-</span>
                            </div>
                            <div class="analysis-item" style="font-size: 10px;">
                                <span class="analysis-label">Status:</span>
                                <span class="analysis-value" id="hypergraphStatus">❌</span>
                            </div>
                        </div>
                        
                        <div class="frequency-bands" style="margin: 8px 0;">
                            <h5 style="font-size: 10px; margin: 0 0 5px 0; color: #4a9eff;">Frequency Bands</h5>
                            <div id="frequencyBandChart" style="font-size: 9px; color: #aaa;">No data</div>
                        </div>
                        
                        <div class="central-nodes" style="margin: 8px 0;">
                            <h5 style="font-size: 10px; margin: 0 0 5px 0; color: #4a9eff;">Key RF Nodes</h5>
                            <div id="centralNodesList" style="font-size: 9px; color: #aaa;">No central nodes</div>
                        </div>
                        
                        <div style="margin-top: 8px; display: flex; gap: 5px; flex-wrap: wrap;">
                            <button id="generateTestData" class="control-button" style="flex: 1; padding: 4px 8px; font-size: 9px; background: #4a9eff; color: white; border: none; border-radius: 3px; cursor: pointer;">Generate Test</button>
                            <button id="resetHypergraph" class="control-button" style="flex: 1; padding: 4px 8px; font-size: 9px; background: #ff6b6b; color: white; border: none; border-radius: 3px; cursor: pointer;">Reset</button>
                        </div>
                        <div style="margin-top: 5px; display: flex; gap: 5px; flex-wrap: wrap;">
                            <button id="scanNetworkHypergraph" class="control-button" style="flex: 1; padding: 4px 8px; font-size: 9px; background: #22c55e; color: white; border: none; border-radius: 3px; cursor: pointer;" title="Scan local network with nmap">🔍 Scan Network</button>
                            <button id="quickScanHypergraph" class="control-button" style="flex: 1; padding: 4px 8px; font-size: 9px; background: #f59e0b; color: white; border: none; border-radius: 3px; cursor: pointer;" title="Quick ping sweep">⚡ Quick Scan</button>
                        </div>
                        <div style="margin-top: 5px;">
                            <input type="text" id="networkScanTarget" placeholder="Target (e.g., 192.168.1.0/24)" style="width: 100%; padding: 4px 6px; font-size: 9px; background: #252525; color: #fff; border: 1px solid #444; border-radius: 3px; box-sizing: border-box;">
                        </div>
                    </div>
                </div>

                <!-- AIS Traffic Control Panel -->
                <div class="tab-panel" id="ais-panel">
                    <h3>🚢 AIS Traffic Control</h3>
                    <div class="panel-content">
                        <!-- Show AIS Vessels Checkbox -->
                        <div class="settings-item">
                            <label>
                                <input type="checkbox" id="toggleAISVessels" checked> Show AIS Vessels
                            </label>
                            <span class="status-count" id="ais-vessel-count" style="margin-left: 8px; font-size: 10px;">0</span>
                        </div>
                        <div style="margin-left: 20px; display: none;" id="aisFilters">
                            <div style="margin: 5px 0; font-size: 11px;">
                                <label><input type="checkbox" id="aisShowTrails" checked> Show Vessel Trails</label>
                            </div>
                            <div style="margin: 5px 0; font-size: 11px;">
                                <label><input type="checkbox" id="aisShowLabels" checked> Show Vessel Names</label>
                            </div>
                            <div style="margin: 5px 0; font-size: 11px;">
                                <label><input type="checkbox" id="aisAutoUpdate"> Auto-update Positions</label>
                            </div>
                            
                            <!-- VESSEL TYPE FILTERS -->
                            <div style="margin: 8px 0; padding: 5px; background: rgba(0,0,0,0.2); border-radius: 3px;">
                                <div style="font-size: 10px; color: #4a9eff; margin-bottom: 5px;">Filter by Vessel Type:</div>
                                <div id="vesselTypeFilters" style="font-size: 10px;">
                                    <div style="margin: 2px 0;"><label><input type="checkbox" class="vesselTypeFilter" value="Cargo" checked> Cargo Ships</label></div>
                                    <div style="margin: 2px 0;"><label><input type="checkbox" class="vesselTypeFilter" value="Tanker" checked> Tankers</label></div>
                                    <div style="margin: 2px 0;"><label><input type="checkbox" class="vesselTypeFilter" value="Passenger" checked> Passenger</label></div>
                                    <div style="margin: 2px 0;"><label><input type="checkbox" class="vesselTypeFilter" value="Fishing" checked> Fishing</label></div>
                                    <div style="margin: 2px 0;"><label><input type="checkbox" class="vesselTypeFilter" value="Tug" checked> Tugs</label></div>
                                    <div style="margin: 2px 0;"><label><input type="checkbox" class="vesselTypeFilter" value="Pilot" checked> Pilot</label></div>
                                    <div style="margin: 2px 0;"><label><input type="checkbox" class="vesselTypeFilter" value="Other" checked> Other</label></div>
                                </div>
                                <div style="margin-top: 5px;">
                                    <button id="aisSelectAllTypes" class="action-button" style="font-size: 9px; padding: 2px 6px;">Select All</button>
                                    <button id="aisClearAllTypes" class="action-button" style="font-size: 9px; padding: 2px 6px;">Clear All</button>
                                </div>
                            </div>

                                <!-- VESSEL LIST PAGINATION -->
                                <div id="aisVesselsPagination" style="margin: 8px 0; padding: 5px; background: rgba(0,0,0,0.12); border-radius: 3px; display: none; font-size: 10px;">
                                    <button id="aisPrevPage" class="action-button" style="font-size: 10px; padding: 2px 6px;">◀ Prev</button>
                                    <span id="aisPageInfo" style="margin: 0 8px; color: #ddd;">Page 1</span>
                                    <button id="aisNextPage" class="action-button" style="font-size: 10px; padding: 2px 6px;">Next ▶</button>
                                    <label style="margin-left: 8px; color: #999;">Per page:</label>
                                    <input id="aisPerPageInput" type="number" min="1" max="1000" value="100" style="width: 70px; margin-left: 6px; font-size: 10px; padding: 2px;">
                                </div>
                            
                            <!-- AIS SEARCH -->
                            <div style="margin: 8px 0; padding: 5px; background: rgba(0,0,0,0.2); border-radius: 3px;">
                                <div style="font-size: 10px; color: #4a9eff; margin-bottom: 5px;">Search AIS Records:</div>
                                <div style="display: flex; gap: 3px; margin-bottom: 5px;">
                                    <input type="text" id="aisSearchInput" placeholder="MMSI, name, callsign..." 
                                           style="flex: 1; font-size: 10px; padding: 2px 4px; background: rgba(255,255,255,0.1); border: 1px solid #555; color: white;">
                                    <select id="aisSearchType" style="font-size: 10px; padding: 2px; background: rgba(255,255,255,0.1); border: 1px solid #555; color: black;">
                                        <option value="all">All Types</option>
                                        <option value="cargo">Cargo</option>
                                        <option value="tanker">Tanker</option>
                                        <option value="passenger">Passenger</option>
                                        <option value="fishing">Fishing</option>
                                        <option value="tug">Tug</option>
                                        <option value="pilot">Pilot</option>
                                    </select>
                                </div>
                                <div style="display: flex; gap: 3px;">
                                    <button id="aisSearchBtn" class="action-button" style="font-size: 9px; padding: 2px 6px; flex: 1;">🔍 Search</button>
                                    <button id="aisClearSearchBtn" class="action-button" style="font-size: 9px; padding: 2px 6px;">Clear</button>
                                </div>
                                <div id="aisSearchResults" style="margin-top: 5px; max-height: 150px; overflow-y: auto; font-size: 9px; display: none;">
                                    <div id="aisSearchStats" style="color: #888; margin-bottom: 5px;"></div>
                                    <div id="aisSearchList"></div>
                                </div>
                            </div>
                            
                            <!-- SEARCH IN AREA -->
                            <div style="margin: 5px 0;">
                                <button id="aisSearchInArea" class="action-button" style="font-size: 10px; padding: 4px 8px; width: 100%;">🔍 Search in this Area</button>
                            </div>
                            <div style="margin: 5px 0;">
                                <button id="aisLoadAllRecords" class="action-button" style="font-size: 10px; padding: 4px 8px; width: 100%;">📥 Load All AIS Records</button>
                            </div>
                            
                            <div style="margin: 5px 0;">
                                <button id="aisCorrelateRF" class="action-button" style="font-size: 10px; padding: 4px 8px;">🔍 Correlate with RF</button>
                            </div>

                            <div style="margin-top: 15px; padding-top: 10px; border-top: 1px solid rgba(255,255,255,0.1);">
                                 <div style="font-size: 10px; color: #4a9eff; margin-bottom: 5px;">Actions:</div>
                                 <button onclick="window.AISVisualization.promoteAllToRecon()" style="width: 100%; background: rgba(74, 158, 255, 0.15); border: 1px solid #4a9eff; color: white; padding: 6px; border-radius: 3px; cursor: pointer; font-size: 11px; margin-bottom: 5px;">
                                    💾 Save All to Recon
                                 </button>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Missiles Tab - Enhanced with Hypersonic Defense -->
                <div class="tab-panel" id="missiles-panel">
                    <div class="status-section">
                        <div class="status-header">
                            <h3 class="status-title">🚀 Hypersonic Defense</h3>
                            <div class="status-indicator status-active">
                                <div class="status-dot"></div>
                                <span>MULTISCOPIC RADAR: ACTIVE</span>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Missile Control Panel -->
                    <div class="settings-group" style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                        <div style="background-color: rgba(30, 30, 30, 0.9); border-radius: 8px; padding: 15px; border: 1px solid #333;">
                            <h4 style="color: #ff9f1c; margin: 0 0 15px 0; font-size: 0.9rem; border-bottom: 1px solid #444; padding-bottom: 8px;">Sensor Configuration</h4>
                            
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
                                <span style="font-size: 0.85rem; color: #ccc;">Primary X-Band</span>
                                <label style="position: relative; display: inline-block; width: 40px; height: 24px;">
                                    <input type="checkbox" id="primaryXBand" checked style="opacity: 0; width: 0; height: 0;">
                                    <span style="position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ff3c38; transition: .4s; border-radius: 24px;"></span>
                                </label>
                            </div>
                            
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
                                <span style="font-size: 0.85rem; color: #ccc;">Secondary Array</span>
                                <label style="position: relative; display: inline-block; width: 40px; height: 24px;">
                                    <input type="checkbox" id="secondaryArray" checked style="opacity: 0; width: 0; height: 0;">
                                    <span style="position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ff3c38; transition: .4s; border-radius: 24px;"></span>
                                </label>
                            </div>
                            
                            <div style="margin: 15px 0;">
                                <label style="display: flex; justify-content: space-between; font-size: 0.85rem; margin-bottom: 8px; color: #ccc;">Baseline Distance <span style="color: #ff9f1c; font-family: monospace;" id="baselineValue">2.5</span> km</label>
                                <input type="range" id="baselineSlider" min="1" max="5" step="0.1" value="2.5" style="width: 100%; height: 6px; background: #444; border-radius: 5px; outline: none; -webkit-appearance: none;">
                            </div>
                            
                            <div style="margin: 15px 0;">
                                <label style="display: flex; justify-content: space-between; font-size: 0.85rem; margin-bottom: 8px; color: #ccc;">Sensor Count <span style="color: #ff9f1c; font-family: monospace;" id="sensorCountValue">4</span></label>
                                <input type="range" id="sensorCountSlider" min="2" max="8" step="1" value="4" style="width: 100%; height: 6px; background: #444; border-radius: 5px; outline: none; -webkit-appearance: none;">
                            </div>
                        </div>
                        
                        <div style="background-color: rgba(30, 30, 30, 0.9); border-radius: 8px; padding: 15px; border: 1px solid #333;">
                            <h4 style="color: #ff9f1c; margin: 0 0 15px 0; font-size: 0.9rem; border-bottom: 1px solid #444; padding-bottom: 8px;">Tracking Parameters</h4>
                            
                            <div style="margin: 15px 0;">
                                <label style="display: flex; justify-content: space-between; font-size: 0.85rem; margin-bottom: 8px; color: #ccc;">Resolution <span style="color: #ff9f1c; font-family: monospace;" id="resolutionValue">0.5</span> m</label>
                                <input type="range" id="resolutionSlider" min="0.1" max="2.0" step="0.1" value="0.5" style="width: 100%; height: 6px; background: #444; border-radius: 5px; outline: none; -webkit-appearance: none;">
                            </div>
                            
                            <div style="margin: 15px 0;">
                                <label style="display: flex; justify-content: space-between; font-size: 0.85rem; margin-bottom: 8px; color: #ccc;">Jink Threshold <span style="color: #ff9f1c; font-family: monospace;" id="jinkThresholdValue">15</span> G</label>
                                <input type="range" id="jinkThresholdSlider" min="5" max="30" step="1" value="15" style="width: 100%; height: 6px; background: #444; border-radius: 5px; outline: none; -webkit-appearance: none;">
                            </div>
                            
                            <div style="margin: 15px 0;">
                                <label style="display: flex; justify-content: space-between; font-size: 0.85rem; margin-bottom: 8px; color: #ccc;">Prediction Time <span style="color: #ff9f1c; font-family: monospace;" id="predictionTimeValue">2.5</span> s</label>
                                <input type="range" id="predictionTimeSlider" min="1" max="5" step="0.1" value="2.5" style="width: 100%; height: 6px; background: #444; border-radius: 5px; outline: none; -webkit-appearance: none;">
                            </div>
                        </div>
                    </div>
                    
                    <!-- Target Telemetry -->
                    <div class="settings-group" style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin: 20px 0;">
                        <div style="background-color: rgba(30, 30, 30, 0.9); border-radius: 8px; padding: 15px; border: 1px solid #333;">
                            <h4 style="color: #ff9f1c; margin: 0 0 15px 0; font-size: 0.9rem;">Target Telemetry</h4>
                            
                            <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px; margin-bottom: 15px;">
                                <div style="background-color: rgba(37, 37, 37, 0.9); border-radius: 6px; padding: 10px; text-align: center; border: 1px solid #444;">
                                    <div style="font-size: 1.2rem; font-weight: 600; margin: 5px 0; color: #ff9f1c; font-family: monospace;" id="velocityValue">2,140</div>
                                    <div style="font-size: 0.8rem; color: #ccc;">Velocity (m/s)</div>
                                </div>
                                <div style="background-color: rgba(37, 37, 37, 0.9); border-radius: 6px; padding: 10px; text-align: center; border: 1px solid #444;">
                                    <div style="font-size: 1.2rem; font-weight: 600; margin: 5px 0; color: #ff9f1c; font-family: monospace;" id="altitudeValue">24,800</div>
                                    <div style="font-size: 0.8rem; color: #ccc;">Altitude (m)</div>
                                </div>
                                <div style="background-color: rgba(37, 37, 37, 0.9); border-radius: 6px; padding: 10px; text-align: center; border: 1px solid #444;">
                                    <div style="font-size: 1.2rem; font-weight: 600; margin: 5px 0; color: #ff9f1c; font-family: monospace;" id="machValue">6.3</div>
                                    <div style="font-size: 0.8rem; color: #ccc;">Mach Number</div>
                                </div>
                                <div style="background-color: rgba(37, 37, 37, 0.9); border-radius: 6px; padding: 10px; text-align: center; border: 1px solid #444;">
                                    <div style="font-size: 1.2rem; font-weight: 600; margin: 5px 0; color: #ff9f1c; font-family: monospace;" id="trackQualityValue">0.87</div>
                                    <div style="font-size: 0.8rem; color: #ccc;">Track Quality</div>
                                </div>
                            </div>
                            
                            <!-- Plasma Sheath Data -->
                            <div style="margin-top: 15px;">
                                <h4 style="color: #ff9f1c; margin: 15px 0 10px 0; font-size: 0.85rem;">Plasma Sheath Model</h4>
                                <div style="display: flex; justify-content: space-between; margin-bottom: 8px; font-size: 0.8rem;">
                                    <span style="color: #ccc;">Electron Density:</span>
                                    <span style="font-family: monospace; color: #ff9f1c;" id="electronDensity">2.4×10¹⁶ m⁻³</span>
                                </div>
                                <div style="display: flex; justify-content: space-between; margin-bottom: 8px; font-size: 0.8rem;">
                                    <span style="color: #ccc;">Plasma Frequency:</span>
                                    <span style="font-family: monospace; color: #ff9f1c;" id="plasmaFrequency">14.2 GHz</span>
                                </div>
                                <div style="display: flex; justify-content: space-between; margin-bottom: 8px; font-size: 0.8rem;">
                                    <span style="color: #ccc;">RF Attenuation:</span>
                                    <span style="font-family: monospace; color: #ff9f1c;" id="rfAttenuation">-23 dB</span>
                                </div>
                            </div>
                        </div>
                        
                        <div style="background-color: rgba(30, 30, 30, 0.9); border-radius: 8px; padding: 15px; border: 1px solid #333;">
                            <h4 style="color: #ff9f1c; margin: 0 0 15px 0; font-size: 0.9rem;">Multiscopic Analysis</h4>
                            <div style="background-color: rgba(37, 37, 37, 0.9); border-radius: 6px; padding: 10px; min-height: 120px; border: 1px solid #444; margin-bottom: 10px;">
                                <div id="rfVisualization" style="width: 100%; height: 100px;"></div>
                            </div>
                            
                            <div style="background-color: rgba(37, 37, 37, 0.9); border-radius: 6px; padding: 10px; min-height: 120px; border: 1px solid #444;">
                                <div id="plasmaVisualization" style="width: 100%; height: 100px;"></div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Action Buttons -->
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 20px;">
                        <button id="generateTargetsBtn" class="action-button" style="background-color: #2a9d3a;">Generate Targets</button>
                        <button id="engageTracking" class="action-button" style="background-color: #ff3c38;">Engage Multiscopic Tracking</button>
                        <button id="resetTracking" class="action-button">Reset</button>
                        <button id="launchMissileBtn" class="action-button" style="background-color: #c0392b;">🚀 LAUNCH MISSILE</button>
                    </div>
                    
                    <!-- Active Sensors Panel -->
                    <div class="settings-group">
                        <h4>Active Sensors</h4>
                        <div id="sensorPanel" style="display: flex; flex-direction: column; gap: 8px;">
                            <div style="display: flex; align-items: center; font-size: 0.85rem; color: #ccc;">
                                <span style="display: inline-block; width: 8px; height: 8px; border-radius: 50%; margin-right: 8px; background-color: #33cc33; box-shadow: 0 0 3px #33cc33;"></span>
                                Sensor 1 (Primary)
                            </div>
                            <div style="font-size: 0.75rem; color: #999; margin-left: 16px;">X-Band, Offset: 0.0 ns</div>
                            
                            <div style="display: flex; align-items: center; font-size: 0.85rem; color: #ccc;">
                                <span style="display: inline-block; width: 8px; height: 8px; border-radius: 50%; margin-right: 8px; background-color: #33cc33; box-shadow: 0 0 3px #33cc33;"></span>
                                Sensor 2 (North)
                            </div>
                            <div style="font-size: 0.75rem; color: #999; margin-left: 16px;">X-Band, Offset: 1.4 ns</div>
                            
                            <div style="display: flex; align-items: center; font-size: 0.85rem; color: #ccc;">
                                <span style="display: inline-block; width: 8px; height: 8px; border-radius: 50%; margin-right: 8px; background-color: #33cc33; box-shadow: 0 0 3px #33cc33;"></span>
                                Sensor 3 (East)
                            </div>
                            <div style="font-size: 0.75rem; color: #999; margin-left: 16px;">X-Band, Offset: 2.1 ns</div>
                            
                            <div style="display: flex; align-items: center; font-size: 0.85rem; color: #ccc;">
                                <span style="display: inline-block; width: 8px; height: 8px; border-radius: 50%; margin-right: 8px; background-color: #ffcc00; box-shadow: 0 0 3px #ffcc00;"></span>
                                Sensor 4 (West)
                            </div>
                            <div style="font-size: 0.75rem; color: #999; margin-left: 16px;">X-Band, Offset: 0.7 ns</div>
                        </div>
                    </div>
                    
                    <!-- Mission Timeline -->
                    <div class="settings-group" style="background-color: rgba(37, 37, 37, 0.9); border-radius: 6px; padding: 15px; margin: 20px 0; border: 1px solid #444;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                            <h4 style="font-size: 0.9rem; margin: 0; color: #ff9f1c;">Mission Timeline</h4>
                            <span style="font-size: 0.8rem; color: #ff9f1c; font-family: monospace;" id="missionTime">T+00:00:00</span>
                        </div>
                        
                        <div style="height: 8px; background-color: #444; border-radius: 4px; margin-bottom: 10px; overflow: hidden; position: relative;">
                            <div style="height: 100%; width: 0%; background-color: #ff3c38; border-radius: 4px; transition: width 0.5s ease;" id="timelineProgress"></div>
                        </div>
                        
                        <div style="display: flex; justify-content: space-between; font-size: 0.7rem; color: #888;">
                            <span>Launch</span>
                            <span>Midcourse</span>
                            <span>Terminal</span>
                            <span>Impact</span>
                        </div>
                    </div>
                    
                        <!-- Mission Control -->
                        <div class="settings-group" style="background-color: rgba(28,28,28,0.95); border-radius:6px; padding:12px; margin:12px 0; border:1px solid #333;">
                            <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;">
                                <h4 style="font-size:0.9rem; margin:0; color:#7bd389;">Mission Control</h4>
                                <span id="missionStatus" style="font-size:0.8rem; color:#ccc; font-family: monospace;">idle</span>
                            </div>

                            <div style="display:flex; gap:8px; margin-bottom:8px;">
                                <input id="missionIdInput" placeholder="mission id" style="flex:1; padding:6px; background:#111; color:#fff; border:1px solid #444; border-radius:4px;" />
                                <button id="missionJoinBtn" style="padding:6px 10px; background:#264653; color:#fff; border-radius:4px; border: none;">Join</button>
                                <button id="missionLeaveBtn" style="padding:6px 10px; background:#9d0208; color:#fff; border-radius:4px; border: none;">Leave</button>
                            </div>

                            <div style="display:flex; gap:8px; align-items:center;">
                                <label style="font-size:0.8rem; color:#aaa;">Auto-subscribe</label>
                                <input id="missionAutoSubscribe" type="checkbox" />
                                <button id="missionSubscribeBtn" style="padding:6px 10px; background:#2a9d8f; color:#fff; border-radius:4px; border: none;">Subscribe</button>
                            </div>
                        </div>
                    
                    <!-- Target List -->
                    <div class="settings-group">
                        <h4>Generated Targets</h4>
                        <div id="missile-targets-list">
                            <div class="list-placeholder">No targets generated</div>
                        </div>
                    </div>
                </div>
                
                <!-- URH Tab -->
                <div class="tab-panel" id="urh-panel">
                    <div class="status-section">
                        <div class="status-header">
                            <h3 class="status-title">Universal Radio Hacker</h3>
                            <div class="status-indicator status-inactive" id="urh-status-indicator">
                                <div class="status-dot"></div>
                                <span id="urh-status-text">DISCONNECTED</span>
                            </div>
                        </div>
                        <div style="display: flex; justify-content: space-between; margin-bottom: 10px;">
                            <button id="urh-connect-btn" class="action-button" style="background-color: #3a6fc4; font-size: 12px;">Connect</button>
                        </div>
                    </div>
                    
                    <div class="urh-settings-group">
                        <h4>Signal Acquisition</h4>
                        <div class="urh-settings-item">
                            <label>Signal Source:</label>
                            <select id="urh-signal-source" class="urh-settings-input">
                                <option value="RTL-SDR">RTL-SDR</option>
                                <option value="HackRF">HackRF</option>
                                <option value="BladeRF">BladeRF</option>
                                <option value="USRP">USRP</option>
                                <option value="LimeSDR">LimeSDR</option>
                            </select>
                        </div>
                        <div class="urh-settings-item">
                            <label>Frequency:</label>
                            <input type="text" id="urh-frequency" class="urh-settings-input" value="433.92M">
                        </div>
                        <div class="urh-settings-item">
                            <label>Modulation:</label>
                            <select id="urh-modulation" class="urh-settings-input">
                                <option value="ASK">ASK</option>
                                <option value="FSK">FSK</option>
                                <option value="PSK">PSK</option>
                                <option value="GFSK">GFSK</option>
                                <option value="OOK">OOK</option>
                            </select>
                        </div>
                        <div class="urh-settings-item">
                            <label>Decoding:</label>
                            <select id="urh-decoding" class="urh-settings-input">
                                <option value="1">Manchester</option>
                                <option value="2">NRZ</option>
                                <option value="3">Differential Manchester</option>
                            </select>
                        </div>
                    </div>
                    
                    <div class="urh-actions">
                        <button id="urh-analyze-btn" class="action-button" disabled>Analyze Signal</button>
                        <button id="urh-decode-btn" class="action-button" disabled>Decode Protocol</button>
                        <button id="urh-sniff-btn" class="action-button" disabled>Start Sniffing</button>
                        <button id="urh-fuzz-btn" class="action-button" disabled>Start Fuzzing</button>
                    </div>
                    
                    <div class="urh-tab-buttons">
                        <button class="urh-tab-button active" data-urhtab="signals">Signals</button>
                        <button class="urh-tab-button" data-urhtab="protocols">Protocols</button>
                        <button class="urh-tab-button" data-urhtab="fuzzing">Fuzzing</button>
                    </div>
                    
                    <div class="urh-tab-panel active" id="urh-signals-panel">
                        <h4>Captured Signals</h4>
                        <div id="urh-signal-list" class="urh-list">
                            <div class="list-placeholder">No signals captured</div>
                        </div>
                        
                        <div class="urh-details-container">
                            <h3>Signal Details</h3>
                            <div id="urh-signal-details">
                                <p>Select a signal to view details</p>
                            </div>
                        </div>
                    </div>
                    
                    <div class="urh-tab-panel" id="urh-protocols-panel">
                        <h4>Analyzed Protocols</h4>
                        <div id="urh-protocol-list" class="urh-list">
                            <div class="list-placeholder">No protocols analyzed</div>
                        </div>
                        
                        <div class="urh-details-container">
                            <h3>Protocol Details</h3>
                            <div id="urh-protocol-details">
                                <p>Select a protocol to view details</p>
                            </div>
                        </div>
                    </div>
                    
                    <div class="urh-tab-panel" id="urh-fuzzing-panel">
                        <h4>Fuzzing Results</h4>
                        <div id="urh-fuzzing-results" class="urh-fuzzing-results">
                            <div class="list-placeholder">No fuzzing results yet</div>
                        </div>
                    </div>
                </div>
                
                <!-- Metrics Explorer Tab -->
                <div class="tab-panel" id="metrics-panel">
                    <div class="status-section">
                        <div class="status-header">
                            <h3 class="status-title">📊 Metrics Explorer</h3>
                            <span class="status-badge" id="metrics-db-status">SQLite</span>
                        </div>
                        <p style="font-size: 11px; color: #888; margin: 5px 0;">Explore logged metrics from the SQLite database</p>
                    </div>
                    
                    <!-- Metrics Summary -->
                    <div class="metrics-explorer-section">
                        <h4>📁 Metrics Summary</h4>
                        <div class="metrics-summary-grid" id="metrics-summary">
                            <div class="metrics-summary-item">
                                <span class="summary-label">Total Metrics</span>
                                <span class="summary-value" id="total-metrics-count">--</span>
                            </div>
                            <div class="metrics-summary-item">
                                <span class="summary-label">Interactions</span>
                                <span class="summary-value" id="total-interactions-count">--</span>
                            </div>
                            <div class="metrics-summary-item">
                                <span class="summary-label">Session Duration</span>
                                <span class="summary-value" id="session-duration">--</span>
                            </div>
                        </div>
                        
                        <div class="metrics-by-module" id="metrics-by-module">
                            <h5>By Module</h5>
                            <div class="module-bars" id="module-bars">
                                <!-- Populated dynamically -->
                            </div>
                        </div>
                    </div>
                    
                    <!-- Metrics Filters -->
                    <div class="metrics-explorer-section">
                        <h4>🔍 Query Metrics</h4>
                        <div class="metrics-filters">
                            <div class="filter-row">
                                <label>Module:</label>
                                <select id="metrics-filter-module" class="metrics-filter-input">
                                    <option value="">All Modules</option>
                                    <option value="recon">Recon</option>
                                    <option value="ais">AIS</option>
                                    <option value="render">Render</option>
                                    <option value="viewshed">Viewshed</option>
                                    <option value="propagation">Propagation</option>
                                    <option value="ndpi">NDPI</option>
                                    <option value="ndpi_protocol">NDPI Protocols</option>
                                    <option value="nmap">Nmap</option>
                                    <option value="hypergraph">Hypergraph</option>
                                    <option value="browser">Browser</option>
                                </select>
                            </div>
                            <div class="filter-row">
                                <label>Metric:</label>
                                <select id="metrics-filter-name" class="metrics-filter-input">
                                    <option value="">All Metrics</option>
                                </select>
                            </div>
                            <div class="filter-row">
                                <label>Limit:</label>
                                <select id="metrics-filter-limit" class="metrics-filter-input">
                                    <option value="20">Last 20</option>
                                    <option value="50" selected>Last 50</option>
                                    <option value="100">Last 100</option>
                                    <option value="500">Last 500</option>
                                </select>
                            </div>
                            <button class="action-button" id="refresh-metrics-btn" style="width: 100%; margin-top: 8px;">
                                🔄 Refresh Metrics
                            </button>
                        </div>
                    </div>
                    
                    <!-- Recent Metrics Table -->
                    <div class="metrics-explorer-section">
                        <h4>📈 Recent Metrics</h4>
                        <div class="metrics-table-container">
                            <table class="metrics-table" id="metrics-table">
                                <thead>
                                    <tr>
                                        <th>Time</th>
                                        <th>Module</th>
                                        <th>Metric</th>
                                        <th>Value</th>
                                    </tr>
                                </thead>
                                <tbody id="metrics-table-body">
                                    <tr>
                                        <td colspan="4" style="text-align: center; color: #888;">Loading...</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                    </div>
                    
                    <!-- User Interactions -->
                    <div class="metrics-explorer-section">
                        <h4>👤 User Interactions</h4>
                        <div class="interactions-list" id="interactions-list">
                            <div style="color: #888; text-align: center; padding: 10px;">Loading...</div>
                        </div>
                    </div>
                    
                    <!-- Live Stats -->
                    <div class="metrics-explorer-section">
                        <h4>⚡ Live Session Stats</h4>
                        <div class="live-stats-grid" id="live-stats">
                            <div class="live-stat">
                                <span class="live-stat-label">Heap Used</span>
                                <span class="live-stat-value" id="live-heap-used">--</span>
                            </div>
                            <div class="live-stat">
                                <span class="live-stat-label">Entity Count</span>
                                <span class="live-stat-value" id="live-entity-count">--</span>
                            </div>
                            <div class="live-stat">
                                <span class="live-stat-label">Vessel Count</span>
                                <span class="live-stat-value" id="live-vessel-count">--</span>
                            </div>
                            <div class="live-stat">
                                <span class="live-stat-label">Update Rate</span>
                                <span class="live-stat-value" id="live-update-rate">--</span>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- RF Propagation Analysis Tab -->
                <div class="tab-panel" id="propagation-panel">
                    <div class="status-section">
                        <div class="status-header">
                            <h3 class="status-title">📶 RF Propagation Analysis</h3>
                            <span class="status-badge" id="propagation-status">ITU-R P.452</span>
                        </div>
                        <p style="font-size: 11px; color: #888; margin: 5px 0;">Terrain-aware RF propagation modeling with knife-edge diffraction</p>
                    </div>
                    
                    <!-- Atmospheric Conditions -->
                    <div class="metrics-explorer-section">
                        <h4>🌡️ Atmospheric Conditions</h4>
                        <div class="metrics-summary-grid">
                            <div class="metrics-summary-item">
                                <span class="summary-label">K-Factor</span>
                                <span class="summary-value" id="atm-k-factor">1.333</span>
                            </div>
                            <div class="metrics-summary-item">
                                <span class="summary-label">Refractivity</span>
                                <span class="summary-value" id="atm-refractivity">315 N</span>
                            </div>
                            <div class="metrics-summary-item">
                                <span class="summary-label">Condition</span>
                                <span class="summary-value" id="atm-condition">Standard</span>
                            </div>
                        </div>
                        
                        <div class="metrics-filters" style="margin-top: 10px;">
                            <div class="filter-row">
                                <label>Humidity:</label>
                                <input type="range" id="atm-humidity" min="0" max="100" value="50" class="metrics-filter-input" style="flex:2">
                                <span id="atm-humidity-val" style="width:40px; text-align:right">50%</span>
                            </div>
                            <div class="filter-row">
                                <label>Temp:</label>
                                <input type="range" id="atm-temp" min="-20" max="50" value="15" class="metrics-filter-input" style="flex:2">
                                <span id="atm-temp-val" style="width:40px; text-align:right">15°C</span>
                            </div>
                            <div class="filter-row">
                                <label>Gradient:</label>
                                <select id="atm-gradient" class="metrics-filter-input">
                                    <option value="-40" selected>Standard (-40 N/km)</option>
                                    <option value="-157">Super-refractive (-157 N/km)</option>
                                    <option value="-20">Sub-refractive (-20 N/km)</option>
                                    <option value="-80">Enhanced (-80 N/km)</option>
                                </select>
                            </div>
                            <button class="action-button" id="apply-atmosphere-btn" style="width: 100%; margin-top: 8px;">
                                Apply Atmospheric Settings
                            </button>
                        </div>
                    </div>
                    
                    <!-- Path Analysis Tool -->
                    <div class="metrics-explorer-section">
                        <h4>📍 Link Budget Calculator</h4>
                        <div class="metrics-filters">
                            <div style="font-size: 10px; color: #4a9eff; margin-bottom: 5px;">TRANSMITTER</div>
                            <div class="filter-row">
                                <label>Lat:</label>
                                <input type="number" id="tx-lat" value="36.1627" step="0.0001" class="metrics-filter-input">
                            </div>
                            <div class="filter-row">
                                <label>Lon:</label>
                                <input type="number" id="tx-lon" value="-86.7816" step="0.0001" class="metrics-filter-input">
                            </div>
                            <div class="filter-row">
                                <label>Height:</label>
                                <input type="number" id="tx-height" value="50" step="1" class="metrics-filter-input">
                                <span style="color:#888;font-size:10px">m</span>
                            </div>
                            <div class="filter-row">
                                <label>Freq:</label>
                                <input type="number" id="tx-freq" value="900" step="1" class="metrics-filter-input">
                                <span style="color:#888;font-size:10px">MHz</span>
                            </div>
                            <div class="filter-row">
                                <label>Power:</label>
                                <input type="number" id="tx-power" value="30" step="1" class="metrics-filter-input">
                                <span style="color:#888;font-size:10px">dBm</span>
                            </div>
                            
                            <div style="font-size: 10px; color: #00d4ff; margin: 10px 0 5px 0;">RECEIVER</div>
                            <div class="filter-row">
                                <label>Lat:</label>
                                <input type="number" id="rx-lat" value="36.1527" step="0.0001" class="metrics-filter-input">
                            </div>
                            <div class="filter-row">
                                <label>Lon:</label>
                                <input type="number" id="rx-lon" value="-86.7916" step="0.0001" class="metrics-filter-input">
                            </div>
                            <div class="filter-row">
                                <label>Height:</label>
                                <input type="number" id="rx-height" value="2" step="1" class="metrics-filter-input">
                                <span style="color:#888;font-size:10px">m</span>
                            </div>
                            <div class="filter-row">
                                <label>Sens:</label>
                                <input type="number" id="rx-sensitivity" value="-100" step="1" class="metrics-filter-input">
                                <span style="color:#888;font-size:10px">dBm</span>
                            </div>
                            
                            <button class="action-button" id="calculate-path-btn" style="width: 100%; margin-top: 10px; background: linear-gradient(135deg, #4a9eff, #00d4ff);">
                                📊 Calculate Path Loss
                            </button>
                            <button class="action-button" id="visualize-path-btn" style="width: 100%; margin-top: 5px;">
                                🗺️ Visualize on Map
                            </button>
                        </div>
                    </div>
                    
                    <!-- Path Analysis Results -->
                    <div class="metrics-explorer-section">
                        <h4>📈 Analysis Results</h4>
                        <div id="path-analysis-results" style="font-size: 11px;">
                            <div style="color: #888; text-align: center; padding: 15px;">
                                Configure TX/RX parameters and click "Calculate Path Loss"
                            </div>
                        </div>
                    </div>
                    
                    <!-- Recent Propagation Calculations -->
                    <div class="metrics-explorer-section">
                        <h4>📋 Recent Calculations</h4>
                        <div class="metrics-table-container" style="max-height: 150px;">
                            <table class="metrics-table" id="propagation-history-table">
                                <thead>
                                    <tr>
                                        <th>Time</th>
                                        <th>Distance</th>
                                        <th>Path Loss</th>
                                        <th>Margin</th>
                                    </tr>
                                </thead>
                                <tbody id="propagation-history-body">
                                    <tr>
                                        <td colspan="4" style="text-align: center; color: #888;">No calculations yet</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        <button class="action-button" id="clear-paths-btn" style="width: 100%; margin-top: 8px;">
                            🗑️ Clear All Paths
                        </button>
                    </div>
                </div>
                
                <!-- RF Hypergraph Tab - Enhanced Visualization -->
                <div class="tab-panel" id="hypergraph-panel">
                    <div class="status-section">
                        <div class="status-header">
                            <h3>RF Hypergraph Network Visualization</h3>
                            <span class="status-badge status-active">ACTIVE</span>
                        </div>
                        <p>Advanced RF signal hypergraph analysis with higher-order interactions</p>
                    </div>
                    
                    <div class="hypergraph-controls">
                        <div class="control-section">
                            <h4>Visualization Controls</h4>
                            
                            <div class="toggle-row">
                                <span class="toggle-label">Higher-Order Interactions</span>
                                <label class="toggle-switch">
                                    <input type="checkbox" id="toggle-hyperedges" checked>
                                    <span class="toggle-slider"></span>
                                </label>
                            </div>
                            
                            <div class="toggle-row">
                                <span class="toggle-label">Node Labels</span>
                                <label class="toggle-switch">
                                    <input type="checkbox" id="toggle-labels" checked>
                                    <span class="toggle-slider"></span>
                                </label>
                            </div>
                            
                            <div class="toggle-row">
                                <span class="toggle-label">Color by Frequency</span>
                                <label class="toggle-switch">
                                    <input type="checkbox" id="toggle-color-freq" checked>
                                    <span class="toggle-slider"></span>
                                </label>
                            </div>
                            
                            <div class="slider-control">
                                <label>Hyperedge Opacity: <span id="opacity-value">0.3</span></label>
                                <input type="range" id="hyperedge-opacity" min="0" max="1" step="0.05" value="0.3">
                            </div>
                        </div>
                        
                        <div class="control-section">
                            <h4>Actions</h4>
                            <button class="command-button primary" id="reset-hypergraph-view">Reset Camera View</button>
                            <button class="command-button secondary" id="generate-hypergraph-data">Generate Test Data</button>
                            <button class="command-button secondary" id="simulate-pcap-ingest" style="background:#4a9eff; color:#fff;">Run PCAP Simulation</button>
                            <button class="command-button secondary" id="start-hypergraph-collection">Start Collection</button>
                            <button class="command-button danger" id="stop-hypergraph-collection" disabled>Stop Collection</button>
                        </div>
                        
                        <div class="control-section">
                            <h4>Nmap Network Scanning</h4>
                            <div style="margin-bottom: 10px;">
                                <label style="display: block; margin-bottom: 5px; font-size: 12px;">Target Network:</label>
                                <input type="text" id="nmap-target-network" placeholder="192.168.1.0/24" 
                                       style="width: 100%; padding: 5px; background: #2c2c2c; border: 1px solid #555; color: white; border-radius: 3px;">
                            </div>
                            
                            <div style="margin-bottom: 10px;">
                                <label style="display: block; margin-bottom: 5px; font-size: 12px;">Scan Type:</label>
                                <select id="nmap-scan-type" style="width: 100%; padding: 5px; background: #2c2c2c; border: 1px solid #555; color: white; border-radius: 3px;">
                                    <option value="SYN">SYN Scan (Fast)</option>
                                    <option value="TCP_CONNECT">TCP Connect</option>
                                    <option value="UDP">UDP Scan</option>
                                    <option value="PING">Ping Sweep</option>
                                    <option value="SERVICE_DETECTION">Service Detection</option>
                                </select>
                            </div>
                            
                            <div style="margin-bottom: 10px;">
                                <div style="display: flex; gap: 5px; font-size: 11px;">
                                    <label><input type="checkbox" id="nmap-service-detection" checked> Service Detection</label>
                                    <label><input type="checkbox" id="nmap-os-detection"> OS Detection</label>
                                    <label><input type="checkbox" id="nmap-rf-correlation" checked> RF Correlation</label>
                                </div>
                            </div>
                            
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 5px;">
                                <button class="command-button primary" id="start-nmap-scan">🔍 Start Nmap</button>
                                <button class="command-button secondary" id="clear-nmap-data">Clear Results</button>
                            </div>
                            
                            <div style="margin-top: 10px; font-size: 11px; color: #888;">
                                <div id="nmap-status">Ready to scan</div>
                                <div id="nmap-progress" style="display: none; margin-top: 5px;">
                                    <div style="background: #333; height: 4px; border-radius: 2px; overflow: hidden;">
                                        <div id="nmap-progress-bar" style="background: #4CAF50; height: 100%; width: 0%; transition: width 0.3s;"></div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="hypergraph-stats">
                        <div class="metrics-grid">
                            <div class="metric">
                                <div class="metric-value" id="hypergraph-nodes">0</div>
                                <div class="metric-label">Nodes</div>
                            </div>
                            <div class="metric">
                                <div class="metric-value" id="hypergraph-edges">0</div>
                                <div class="metric-label">Hyperedges</div>
                            </div>
                            <div class="metric">
                                <div class="metric-value" id="max-cardinality">0</div>
                                <div class="metric-label">Max Cardinality</div>
                            </div>
                            <div class="metric">
                                <div class="metric-value" id="collection-time">0s</div>
                                <div class="metric-label">Collection Time</div>
                            </div>
                        </div>
                        
                        <div class="frequency-bands">
                            <h4>Frequency Band Legend</h4>
                            <div class="band-legend">
                                <div class="band-item">
                                    <span class="freq-band" style="background-color: hsl(0, 100%, 50%)"></span> VLF/LF
                                </div>
                                <div class="band-item">
                                    <span class="freq-band" style="background-color: hsl(60, 100%, 50%)"></span> MF
                                </div>
                                <div class="band-item">
                                    <span class="freq-band" style="background-color: hsl(120, 100%, 50%)"></span> HF
                                </div>
                                <div class="band-item">
                                    <span class="freq-band" style="background-color: hsl(180, 100%, 50%)"></span> VHF
                                </div>
                                <div class="band-item">
                                    <span class="freq-band" style="background-color: hsl(240, 100%, 50%)"></span> UHF
                                </div>
                                <div class="band-item">
                                    <span class="freq-band" style="background-color: hsl(300, 100%, 50%)"></span> SHF/EHF
                                </div>
                            </div>
                        </div>
                        
                        <div class="central-nodes">
                            <h4>High Centrality Nodes</h4>
                            <div id="central-nodes-list">Loading nodes...</div>
                        </div>
                    </div>
                </div>
                
                <!-- Settings Tab -->
                <!-- Points of Interest Panel -->
                <div class="tab-panel" id="poi-panel">
                    <div class="status-section">
                        <div class="status-header">
                            <h3 class="status-title">📍 Points of Interest</h3>
                            <span class="status-badge" id="poi-status-badge">ACTIVE</span>
                        </div>
                        <p style="font-size: 11px; color: #888; margin: 5px 0;">Manage and visualize geographic points of interest from KMZ/KML files</p>
                    </div>
                    
                    <!-- POI Statistics -->
                    <div class="metrics-explorer-section">
                        <h4>📊 POI Statistics</h4>
                        <div class="metrics-summary-grid">
                            <div class="metrics-summary-item">
                                <span class="summary-label">Total POIs</span>
                                <span class="summary-value" id="poi-count">0</span>
                            </div>
                            <div class="metrics-summary-item">
                                <span class="summary-label">Categories</span>
                                <span class="summary-value" id="poi-category-count">0</span>
                            </div>
                            <div class="metrics-summary-item">
                                <span class="summary-label">Visible</span>
                                <span class="summary-value" id="poi-visible-count">0</span>
                            </div>
                        </div>
                    </div>
                    
                    <!-- POI Display Controls -->
                    <div class="metrics-explorer-section">
                        <h4>🎛️ Display Controls</h4>
                        <div class="settings-item">
                            <label>
                                <input type="checkbox" id="togglePOIs" checked> Show POIs on Map
                            </label>
                        </div>
                        <div class="settings-item">
                            <label>
                                <input type="checkbox" id="togglePOILabels" checked> Show POI Labels
                            </label>
                        </div>
                        <div class="settings-actions" style="margin-top: 10px;">
                            <button class="action-button" id="flyToAllPOIsBtn" style="width: 100%;">📍 Fly to All POIs</button>
                        </div>
                        <div class="settings-actions" style="margin-top: 5px;">
                            <button class="action-button" id="reloadPOIsBtn" style="width: 100%;">🔄 Reload POIs from Database</button>
                        </div>
                    </div>
                    
                    <!-- Add New POI -->
                    <div class="metrics-explorer-section">
                        <h4>➕ Add New Point of Interest</h4>
                        <div class="metrics-filters">
                            <div class="filter-row">
                                <label>Name:</label>
                                <input type="text" id="new-poi-name" placeholder="POI Name" class="metrics-filter-input" style="flex: 2;">
                            </div>
                            <div class="filter-row">
                                <label>Latitude:</label>
                                <input type="number" id="new-poi-lat" placeholder="37.7749" step="0.0001" class="metrics-filter-input" style="flex: 2;">
                            </div>
                            <div class="filter-row">
                                <label>Longitude:</label>
                                <input type="number" id="new-poi-lon" placeholder="-122.4194" step="0.0001" class="metrics-filter-input" style="flex: 2;">
                            </div>
                            <div class="filter-row">
                                <label>Category:</label>
                                <select id="new-poi-category" class="metrics-filter-input" style="flex: 2;">
                                    <option value="intelligence">🔴 Intelligence</option>
                                    <option value="military">🟤 Military</option>
                                    <option value="infrastructure">🟠 Infrastructure</option>
                                    <option value="commercial">🔵 Commercial</option>
                                    <option value="government">🟣 Government</option>
                                    <option value="transportation">🔷 Transportation</option>
                                    <option value="manual" selected>⚪ Manual</option>
                                    <option value="general">⬜ General</option>
                                </select>
                            </div>
                            <div class="filter-row">
                                <label>Description:</label>
                                <input type="text" id="new-poi-description" placeholder="Optional description" class="metrics-filter-input" style="flex: 2;">
                            </div>
                            <button class="action-button" id="add-poi-btn" style="width: 100%; margin-top: 10px; background: linear-gradient(135deg, #4a9eff, #00d4ff);">
                                ➕ Add Point of Interest
                            </button>
                            <button class="action-button" id="pick-location-btn" style="width: 100%; margin-top: 5px;">
                                🎯 Pick Location from Map
                            </button>
                        </div>
                    </div>
                    
                    <!-- POI List -->
                    <div class="metrics-explorer-section">
                        <h4>📋 POI List</h4>
                        <div id="poi-list-container" style="max-height: 300px; overflow-y: auto;">
                            <div class="poi-list" id="poi-list">
                                <div style="color: #888; text-align: center; padding: 15px; font-size: 11px;">
                                    Loading points of interest...
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Category Filter -->
                    <div class="metrics-explorer-section">
                        <h4>🏷️ Category Filters</h4>
                        <div id="poi-category-filters" style="display: flex; flex-wrap: wrap; gap: 5px;">
                            <!-- Populated dynamically -->
                        </div>
                    </div>
                    
                    <!-- Import KMZ -->
                    <div class="metrics-explorer-section">
                        <h4>📁 Import from KMZ/KML</h4>
                        <div class="metrics-filters">
                            <div class="filter-row">
                                <label>File Path:</label>
                                <input type="text" id="import-kmz-path" placeholder="/path/to/file.kmz" class="metrics-filter-input" style="flex: 2;">
                            </div>
                            <div class="filter-row">
                                <label>Category:</label>
                                <select id="import-kmz-category" class="metrics-filter-input" style="flex: 2;">
                                    <option value="imported" selected>Imported</option>
                                    <option value="intelligence">Intelligence</option>
                                    <option value="military">Military</option>
                                    <option value="infrastructure">Infrastructure</option>
                                </select>
                            </div>
                            <button class="action-button" id="import-kmz-btn" style="width: 100%; margin-top: 10px;">
                                📥 Import KMZ File
                            </button>
                        </div>
                    </div>
                </div>
                
                <!-- Operators Panel - Multi-User Collaboration -->
                <div class="tab-panel" id="operators-panel">
                    <div class="status-section">
                        <div class="status-header">
                            <h3 class="status-title">👥 Operators</h3>
                            <button class="close-panel" onclick="showPanel('drones')">×</button>
                        </div>
                        <p style="font-size: 11px; color: #888; margin: 5px 0;">Multi-user collaboration and real-time entity synchronization</p>
                    </div>
                    
                    <!-- Connection Status -->
                    <div class="metrics-explorer-section">
                        <h4>📡 Connection Status</h4>
                        <div class="metrics-summary-grid">
                            <div class="metrics-summary-item">
                                <span class="summary-label">Entity Sync</span>
                                <span class="summary-value" id="operator-sync-status">Offline</span>
                            </div>
                            <div class="metrics-summary-item">
                                <span class="summary-label">Cached Entities</span>
                                <span class="summary-value" id="operator-cached-count">0</span>
                            </div>
                            <div class="metrics-summary-item">
                                <span class="summary-label">Active Operators</span>
                                <span class="summary-value" id="operator-active-count">0</span>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Current Session -->
                    <div class="metrics-explorer-section">
                        <h4>👤 Current Session</h4>
                        <div id="operator-session-info">
                            <div style="padding: 10px; background: rgba(42, 42, 42, 0.8); border-radius: 4px; text-align: center;">
                                <p style="color: #888; margin: 0 0 10px 0;">Not logged in</p>
                                <button class="action-button" onclick="showOperatorLoginDialog()" style="width: 100%;">
                                    🔐 Login / Register
                                </button>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Active Operators -->
                    <div class="metrics-explorer-section">
                        <h4>👥 Active Operators</h4>
                        <div style="margin-bottom: 10px;">
                            <label style="font-size: 11px;">
                                <input type="checkbox" id="show-operator-presence" checked onchange="OperatorPresence.toggleVisibility(this.checked)">
                                Show operator positions on map
                            </label>
                        </div>
                        <div id="operator-presence-list" style="max-height: 200px; overflow-y: auto;">
                            <div class="empty-message" style="text-align: center; color: #888; padding: 20px;">
                                No active operators
                            </div>
                        </div>
                        <button class="action-button" onclick="OperatorPresence.fetchActiveOperators()" style="width: 100%; margin-top: 10px;">
                            🔄 Refresh
                        </button>
                    </div>
                    
                    <!-- Entity Stream Events -->
                    <div class="metrics-explorer-section">
                        <h4>📊 Entity Stream</h4>
                        <div id="entity-stream-log" style="max-height: 150px; overflow-y: auto; background: rgba(0,0,0,0.3); border-radius: 4px; padding: 8px; font-size: 10px; font-family: monospace;">
                            <div style="color: #888;">Waiting for events...</div>
                        </div>
                    </div>
                    
                    <!-- Rooms/Channels Section -->
                    <div class="metrics-explorer-section">
                        <h4>🏠 Rooms / Channels</h4>
                        <div style="margin-bottom: 10px;">
                            <div style="display: flex; gap: 5px; margin-bottom: 10px;">
                                <button class="small-btn" onclick="RoomManager.fetchRooms()" title="Refresh room list">🔄</button>
                                <button class="small-btn primary" onclick="showCreateRoomDialog()" title="Create new room">+ New Room</button>
                            </div>
                        </div>
                        
                        <!-- My Rooms -->
                        <div style="margin-bottom: 10px;">
                            <label style="font-size: 11px; color: #0f0;">My Rooms:</label>
                            <div id="joined-rooms-list" style="max-height: 120px; overflow-y: auto; margin-top: 5px;">
                                <div class="empty-message" style="text-align: center; color: #888; padding: 10px; font-size: 11px;">
                                    Not in any rooms
                                </div>
                            </div>
                        </div>
                        
                        <!-- Available Rooms -->
                        <div style="margin-bottom: 10px;">
                            <label style="font-size: 11px; color: #888;">Available Rooms:</label>
                            <div id="available-rooms-list" style="max-height: 150px; overflow-y: auto; margin-top: 5px;">
                                <div class="empty-message" style="text-align: center; color: #888; padding: 10px; font-size: 11px;">
                                    No rooms available
                                </div>
                            </div>
                        </div>
                        
                        <!-- Current Room -->
                        <div style="margin-top: 10px; padding: 8px; background: rgba(0,100,0,0.2); border-radius: 4px;">
                            <label style="font-size: 10px; color: #888;">Active Room:</label>
                            <div id="current-room-name" style="font-weight: bold; color: #0f0;">No room selected</div>
                        </div>
                    </div>
                    
                    <!-- Room Chat -->
                    <div class="metrics-explorer-section">
                        <h4>💬 Room Chat</h4>
                        <div id="room-chat-log" style="max-height: 150px; overflow-y: auto; background: rgba(0,0,0,0.3); border-radius: 4px; padding: 8px; font-size: 11px; margin-bottom: 10px;">
                            <div style="color: #888;">Join a room to chat...</div>
                        </div>
                        <div style="display: flex; gap: 5px;">
                            <input type="text" id="room-chat-input" placeholder="Type message..." 
                                   style="flex: 1; padding: 6px; background: rgba(30,30,30,0.9); border: 1px solid #444; border-radius: 4px; color: #fff; font-size: 11px;"
                                   onkeypress="if(event.key==='Enter') sendRoomChatMessage()">
                            <button class="small-btn primary" onclick="sendRoomChatMessage()">Send</button>
                        </div>
                    </div>
                    
                    <!-- Publish Test Entity -->
                    <div class="metrics-explorer-section">
                        <h4>🧪 Test Entity Publishing</h4>
                        <div class="metrics-filters">
                            <div class="filter-row">
                                <label>Entity ID:</label>
                                <input type="text" id="test-entity-id" placeholder="test-entity-1" class="metrics-filter-input">
                            </div>
                            <div class="filter-row">
                                <label>Type:</label>
                                <select id="test-entity-type" class="metrics-filter-input">
                                    <option value="marker">Marker</option>
                                    <option value="target">Target</option>
                                    <option value="asset">Asset</option>
                                    <option value="waypoint">Waypoint</option>
                                </select>
                            </div>
                            <button class="action-button" onclick="publishTestEntity()" style="width: 100%; margin-top: 10px;">
                                📤 Publish Test Entity
                            </button>
                        </div>
                    </div>
                </div>
                
                <div class="tab-panel" id="settings-panel">
                    <div class="status-section">
                        <div class="status-header">
                            <h3 class="status-title">System Settings</h3>
                        </div>
                    </div>
                    <div class="settings-group">
                        <h4>Connection</h4>
                        <div class="settings-item">
                            <label for="serverUrl">Server URL:</label>
                            <input type="text" id="serverUrl" value="ws://localhost:8080" class="settings-input">
                        </div>
                        <div class="settings-actions">
                            <button class="action-button" id="connectButton">Connect</button>
                            <button class="action-button" id="disconnectButton">Disconnect</button>
                        </div>
                    </div>
                    <div class="settings-group">
                        <h4>Display Options</h4>
                        <div class="settings-item">
                            <label>
                                <input type="checkbox" id="toggleDrones" checked> Show Drones
                            </label>
                        </div>
                        <div class="settings-item">
                            <label>
                                <input type="checkbox" id="toggleSignals" checked> Show Signals
                            </label>
                        </div>
                        <div class="settings-item">
                            <label>
                                <input type="checkbox" id="toggleViolations" checked> Show Violations
                            </label>
                        </div>
                        <div class="settings-item">
                            <label>
                                <input type="checkbox" id="togglePaths" checked> Show Flight Paths
                            </label>
                        </div>
                        <div class="settings-item">
                            <label>
                                <input type="checkbox" id="togglePredictions" checked> Show Predictions
                            </label>
                        </div>
                    </div>
                    <div class="settings-group">
                        <h4>Performance & Error Recovery</h4>
                        <div class="settings-item">
                            <label>
                                <input type="checkbox" id="toggleMinimalGlobe"> Use Minimal Globe Mode
                            </label>
                            <div class="setting-description">
                                Disables advanced rendering features to avoid errors
                            </div>
                        </div>
                        <div class="settings-item">
                            <button class="action-button" id="switchToMinimalBtn">Switch to Minimal Globe</button>
                            <div class="setting-description">
                                Use if experiencing "Rectangle.north" rendering errors
                            </div>
                        </div>
                        <div class="settings-item">
                            <button class="action-button" id="reloadBtn">Reload Visualization</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Spectrogram Visualization Container -->
    <div id="spectrogramContainer" style="display: none;">
        <div id="spectrogramControls">
            <button class="spec-control" id="playBtn" title="Play/Pause">
                <span>▶ Play</span>
            </button>
            <button class="spec-control" id="zoomToSelectionBtn" title="Zoom to Selection">
                <span>🔍 Zoom</span>
            </button>
            <button class="spec-control" id="resetZoomBtn" title="Reset Zoom">
                <span>↩ Reset</span>
            </button>
            <div class="spec-control">
                <span id="currentFrequency">Freq: 0.00 MHz</span>
            </div>
            <div id="zoomControls">
                <button class="spec-control" id="zoomInBtn">+</button>
                <button class="spec-control" id="zoomOutBtn">-</button>
            </div>
        </div>
        <canvas id="spectrogramCanvas"></canvas>
        <div id="selectionOverlay"></div>
        <div id="currentPositionMarker" class="cursor-marker"></div>
        <div id="timeMarker"></div>
        <div id="spectrumRange">
            <div id="leftHandle" class="range-handle"></div>
            <div id="rightHandle" class="range-handle"></div>
        </div>
        <div id="frequencyScale">
            <span>-1.0 MHz</span>
            <span>-0.5 MHz</span>
            <span>0 MHz</span>
            <span>+0.5 MHz</span>
            <span>+1.0 MHz</span>
        </div>
    </div>

    <!-- Notifications Container -->
    <div id="notifications-container" class="notifications"></div>

    <!-- Command Console -->
    <div id="command-console">
        <div id="console-output">
            <div class="console-line">
                <span class="console-timestamp">[15:22:38]</span>
                <span class="console-response">System initialized. SDR WebSocket Manager active.</span>
            </div>
            <div class="console-line">
                <span class="console-timestamp">[15:22:43]</span>
                <span class="console-response">CUDA RF Processor initialized successfully.</span>
            </div>
            <div class="console-line">
                <span class="console-timestamp">[15:23:12]</span>
                <span class="console-command">> drone connect 01</span>
            </div>
            <div class="console-line">
                <span class="console-timestamp">[15:23:13]</span>
                <span class="console-response">Connected to Drone 01. Status: READY</span>
            </div>
            <div class="console-line">
                <span class="console-timestamp">[15:23:54]</span>
                <span class="console-alert">ALERT: New FCC violation detected at 162.475 MHz</span>
            </div>
        </div>
        <div id="console-input-container">
            <span id="console-prompt">&gt;</span>
            <input type="text" id="console-input" placeholder="Type command...">
        </div>
    </div>

    <script src="cesium-visualization.js"></script>
    <script src="cesium-helpers.js"></script>
    <script src="cesium-patches.js"></script>
    <script src="cesium-error-handler.js"></script>
    <script src="notification-system.js"></script>
    <script src="coordinate-validation.js"></script>
    <script src="coordinate-error-handler.js"></script>
    <script src="cesium-ellipse-fix.js"></script>
    <script src="cesium-error-debugger.js"></script>
    <script src="ionosphere-visualization.js"></script>
    <script src="ionosphere-data-enhancer.js"></script>
	    <!-- Essential RF SCYTHE components only (loaded once) -->
	    <script src="mock-api.js"></script>
    <script src="network-infrastructure.js"></script>
    <script src="urh-integration.js"></script>
    
    <!-- Initialize loading overlay -->
    <div id="loadingOverlay" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.8); display: flex; justify-content: center; align-items: center; z-index: 9999; color: white; font-size: 24px;">
        <div style="display: flex; flex-direction: column; align-items: center;">
            <div style="border: 5px solid rgba(255, 255, 255, 0.3); border-radius: 50%; border-top: 5px solid #58a6ff; width: 50px; height: 50px; animation: spin 1s linear infinite; margin-bottom: 20px;"></div>
            <h2>Loading Command Operations Center...</h2>
            <p>Initializing visualization components...</p>
        </div>
    </div>
    <style>
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .hidden { display: none !important; }
    </style>
    <script>
        // Initialize the application like LHC page
        document.addEventListener('DOMContentLoaded', function() {
            console.log('Initializing Command Ops Visualization...');
            
            // ===== EARLY INITIALIZATION: Dropdown Menu =====
            // This must run FIRST before any other components to ensure menu is always responsive
            // It does NOT depend on URH, operator system, or any other module
            (function initDropdownMenuEarly() {
                const menuButton = document.getElementById('menu-toggle');
                const dropdownMenu = document.getElementById('dropdown-menu');
                
                if (menuButton && dropdownMenu) {
                    // Remove any existing listeners to prevent duplicates
                    const newMenuButton = menuButton.cloneNode(true);
                    menuButton.parentNode.replaceChild(newMenuButton, menuButton);
                    
                    newMenuButton.addEventListener('click', function(e) {
                        e.preventDefault();
                        e.stopPropagation();
                        const isVisible = dropdownMenu.classList.contains('show');
                        dropdownMenu.classList.toggle('show');
                        console.log('[Menu] Dropdown toggled:', !isVisible);
                    });
                    
                    // Close dropdown when clicking outside
                    document.addEventListener('click', function(event) {
                        const currentMenuButton = document.getElementById('menu-toggle');
                        if (currentMenuButton && !currentMenuButton.contains(event.target) && !dropdownMenu.contains(event.target)) {
                            dropdownMenu.classList.remove('show');
                        }
                    });
                    
                    // Close dropdown when a menu item is clicked
                    dropdownMenu.querySelectorAll('.dropdown-item').forEach(item => {
                        item.addEventListener('click', function() {
                            dropdownMenu.classList.remove('show');
                        });
                    });
                    
                    // Make sure menu container is always visible (fallback for operator system issues)
                    const navMenu = dropdownMenu.closest('.nav-menu');
                    if (navMenu) {
                        navMenu.style.display = 'block';
                        navMenu.style.visibility = 'visible';
                    }
                    
                    console.log('[Menu] Dropdown menu initialized early - always visible regardless of operator status');
                } else {
                    console.error('[Menu] CRITICAL: Menu elements not found! Menu will not work.');
                    // Retry after a short delay in case elements are loaded later
                    setTimeout(function() {
                        const retryButton = document.getElementById('menu-toggle');
                        const retryDropdown = document.getElementById('dropdown-menu');
                        if (retryButton && retryDropdown) {
                            retryButton.addEventListener('click', function(e) {
                                e.preventDefault();
                                e.stopPropagation();
                                retryDropdown.classList.toggle('show');
                                console.log('[Menu] Dropdown toggled (retry):', retryDropdown.classList.contains('show'));
                            });
                            console.log('[Menu] Dropdown menu initialized on retry');
                        }
                    }, 1000);
                }
            })();
            
            // Initialize loading indicator
            const loadingOverlay = document.getElementById('loadingOverlay');
            
            // Initialize Cesium fixes
            if (window.Cesium && RF_SCYTHE.initCesiumFixes) {
                RF_SCYTHE.initCesiumFixes();
            }
            
            // Check if cesiumContainer exists before initialization
            const cesiumContainer = document.getElementById('cesiumContainer');
            if (!cesiumContainer) {
                console.error('cesiumContainer element not found! Cannot initialize Cesium.');
                return;
            }
            
            // Delay heavy initialization to let the UI render first
            setTimeout(() => {
                try {
                    initializeCesiumViewer();
                    console.log('Cesium viewer initialized');
                } catch (error) {
                    console.error('Error initializing Cesium:', error);
                    
                    // Show error to user
                    cesiumContainer.innerHTML = `
                        <div style="padding: 20px; background-color: #2c3e50; color: white; text-align: center;">
                            <h3>Globe Initialization Error</h3>
                            <p>Failed to initialize Cesium viewer: ${error.message}</p>
                            <button onclick="location.reload()" style="padding: 10px 20px; background: #3498db; color: white; border: none; border-radius: 5px; cursor: pointer;">Reload Page</button>
                        </div>
                    `;
                }
                
                // Continue with other initializations after Cesium is loaded
                setTimeout(() => {
                    try {
                        // Initialize other components
                        if (typeof initializeNetworkInfrastructure === 'function') {
                            initializeNetworkInfrastructure();
                        }
                        if (typeof initializeURHIntegration === 'function') {
                            initializeURHIntegration();
                        }
                        
                        // NOTE: Camera navigation controls are initialized later in the main 
                        // DOMContentLoaded handler AFTER the viewer is actually created
                        
                        console.log('All components initialized');
                    } catch (error) {
                        console.error('Error initializing components:', error);
                    }
                    
                    // Hide loading overlay when everything is initialized
                    if (loadingOverlay) {
                        loadingOverlay.classList.add('hidden');
                    }
                }, 500);
            }, 100);
        });
        
        // ============================================
        // CAMERA NAVIGATION CONTROLS
        // ============================================
        
        // Initialize camera navigation controls (compass, zoom, tilt)
        function initializeCameraNavigationControls() {
            if (!viewer || !viewer.scene || !viewer.camera) {
                console.warn('[CameraNav] Viewer not available for camera controls');
                return false;
            }
            
            console.log('[CameraNav] Initializing camera navigation controls...');
            
            // Get control elements with debug logging
            const compassNeedle = document.getElementById('compass-needle');
            const resetNorthBtn = document.getElementById('reset-north-btn');
            const zoomInBtn = document.getElementById('zoom-in-btn');
            const zoomOutBtn = document.getElementById('zoom-out-btn');
            const zoomHomeBtn = document.getElementById('zoom-home-btn');
            const tiltUpBtn = document.getElementById('tilt-up-btn');
            const tiltDownBtn = document.getElementById('tilt-down-btn');
            const rotateLeftBtn = document.getElementById('rotate-left-btn');
            const rotateRightBtn = document.getElementById('rotate-right-btn');
            const unlockCameraBtn = document.getElementById('unlock-camera-btn');
            
            // Debug: log which elements were found
            console.log('[CameraNav] Elements found:', {
                compassNeedle: !!compassNeedle,
                resetNorthBtn: !!resetNorthBtn,
                zoomInBtn: !!zoomInBtn,
                zoomOutBtn: !!zoomOutBtn,
                zoomHomeBtn: !!zoomHomeBtn,
                tiltUpBtn: !!tiltUpBtn,
                tiltDownBtn: !!tiltDownBtn,
                rotateLeftBtn: !!rotateLeftBtn,
                rotateRightBtn: !!rotateRightBtn,
                unlockCameraBtn: !!unlockCameraBtn
            });
            
            // Track camera lock state
            window.cameraLocked = false;
            
            // Helper: Ensure camera is in inertial frame before manipulation
            // This is CRITICAL - rotation/tilt APIs only work when camera is free
            function ensureCameraFree() {
                // Reset to identity transform (frees from lookAt mode)
                viewer.camera.lookAtTransform(Cesium.Matrix4.IDENTITY);
                // Clear tracked entity
                viewer.trackedEntity = undefined;
                // Re-enable all controller inputs
                const ctrl = viewer.scene.screenSpaceCameraController;
                ctrl.enableRotate = true;
                ctrl.enableTilt = true;
                ctrl.enableZoom = true;
                ctrl.enableTranslate = true;
                ctrl.enableLook = true;
                window.cameraLocked = false;
            }
            
            // Make ensureCameraFree globally available for all modules
            window.ensureCameraFree = ensureCameraFree;
            
            // Helper: Fly to with auto-reset on complete
            function flyToWithReset(options) {
                options = options || {};
                // Unlock camera before flight (trackedEntity / lookAtTransform can override animation)
                try { ensureCameraFree(); } catch (e) {}

                // Render kicker for requestRenderMode (required for visible camera flights when requestRenderMode=true)
                let __rk = null;
                function __rkStart(ms){
                    try{
                        if (!viewer || !viewer.scene || !viewer.scene.requestRenderMode) return;
                        const t0 = performance.now();
                        __rk = setInterval(function(){
                            try { viewer.scene.requestRender(); } catch(e){}
                            if ((performance.now()-t0) > ms){
                                try { clearInterval(__rk); } catch(e){}
                                __rk = null;
                            }
                        }, 16);
                        try { viewer.scene.requestRender(); } catch(e){}
                    }catch(e){}
                }
                function __rkStop(){ if(__rk){ try{ clearInterval(__rk);}catch(e){} __rk=null; } }
                __rkStart(((options.duration || 2.0) * 1000) + 750);

                const originalComplete = options.complete;
                const originalCancel = options.cancel;
                options.complete = function() {
                    __rkStop();
                    try { ensureCameraFree(); } catch (e) {}
                    if (originalComplete) originalComplete();
                };
                options.cancel = function() {
                    __rkStop();
                    try { ensureCameraFree(); } catch (e) {}
                    if (originalCancel) originalCancel();
                };
                viewer.camera.flyTo(options);
            }
            
            // Make flyToWithReset globally available for all modules
            window.flyToWithReset = flyToWithReset;
            
            // Update compass needle rotation based on camera heading
            function updateCompass() {
                if (compassNeedle && viewer && viewer.camera) {
                    const heading = viewer.camera.heading;
                    const degrees = Cesium.Math.toDegrees(heading);
                    compassNeedle.style.transform = `translate(-50%, -100%) rotate(${degrees}deg)`;
                }
            }
            
            // Register compass update on each render
            viewer.scene.postRender.addEventListener(updateCompass);
            
            // Reset to North orientation
            if (resetNorthBtn) {
                resetNorthBtn.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    console.log('[CameraNav] Reset North clicked');
                    ensureCameraFree();
                    flyToWithReset({
                        destination: viewer.camera.position,
                        orientation: {
                            heading: 0,
                            pitch: viewer.camera.pitch,
                            roll: 0
                        },
                        duration: 0.5
                    });
                });
                console.log('[CameraNav] Reset North button listener attached');
            }
            
            // Zoom in - uses direct API, works after ensureCameraFree
            if (zoomInBtn) {
                zoomInBtn.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    console.log('[CameraNav] Zoom In clicked');
                    ensureCameraFree();
                    const cameraHeight = viewer.camera.positionCartographic.height;
                    const zoomAmount = cameraHeight * 0.4; // Zoom in by 40%
                    viewer.camera.zoomIn(zoomAmount);
                });
                console.log('[CameraNav] Zoom In button listener attached');
            }
            
            // Zoom out - uses direct API
            if (zoomOutBtn) {
                zoomOutBtn.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    console.log('[CameraNav] Zoom Out clicked');
                    ensureCameraFree();
                    const cameraHeight = viewer.camera.positionCartographic.height;
                    const zoomAmount = cameraHeight * 0.6; // Zoom out by 60%
                    viewer.camera.zoomOut(zoomAmount);
                });
                console.log('[CameraNav] Zoom Out button listener attached');
            }
            
            // Reset view to home position
            if (zoomHomeBtn) {
                zoomHomeBtn.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    console.log('[CameraNav] Home clicked');
                    ensureCameraFree();
                    flyToWithReset({
                        destination: Cesium.Cartesian3.fromDegrees(-74.0, 40.7, 1000000),
                        orientation: {
                            heading: 0,
                            pitch: Cesium.Math.toRadians(-45),
                            roll: 0
                        },
                        duration: 2.0
                    });
                });
                console.log('[CameraNav] Home button listener attached');
            }
            
            // Tilt up (look more towards horizon) - use lookUp for instant response
            if (tiltUpBtn) {
                tiltUpBtn.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    console.log('[CameraNav] Tilt Up clicked');
                    ensureCameraFree();
                    // lookUp tilts the camera up (towards horizon)
                    viewer.camera.lookUp(Cesium.Math.toRadians(15));
                    console.log('[CameraNav] Tilt Up executed, new pitch:', Cesium.Math.toDegrees(viewer.camera.pitch));
                });
                console.log('[CameraNav] Tilt Up button listener attached');
            }
            
            // Tilt down (look more towards ground) - use lookDown for instant response
            if (tiltDownBtn) {
                tiltDownBtn.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    console.log('[CameraNav] Tilt Down clicked');
                    ensureCameraFree();
                    // lookDown tilts the camera down (towards ground)
                    viewer.camera.lookDown(Cesium.Math.toRadians(15));
                    console.log('[CameraNav] Tilt Down executed, new pitch:', Cesium.Math.toDegrees(viewer.camera.pitch));
                });
                console.log('[CameraNav] Tilt Down button listener attached');
            }
            
            // Rotate left - use rotateLeft for instant response
            if (rotateLeftBtn) {
                rotateLeftBtn.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    console.log('[CameraNav] Rotate Left clicked');
                    ensureCameraFree();
                    // rotateLeft rotates camera heading counter-clockwise
                    viewer.camera.rotateLeft(Cesium.Math.toRadians(45));
                    console.log('[CameraNav] Rotate Left executed, new heading:', Cesium.Math.toDegrees(viewer.camera.heading));
                });
                console.log('[CameraNav] Rotate Left button listener attached');
            }
            
            // Rotate right - use rotateRight for instant response
            if (rotateRightBtn) {
                rotateRightBtn.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    console.log('[CameraNav] Rotate Right clicked');
                    ensureCameraFree();
                    // rotateRight rotates camera heading clockwise
                    viewer.camera.rotateRight(Cesium.Math.toRadians(45));
                    console.log('[CameraNav] Rotate Right executed, new heading:', Cesium.Math.toDegrees(viewer.camera.heading));
                });
                console.log('[CameraNav] Rotate Right button listener attached');
            }
            
            // Unlock camera button
            if (unlockCameraBtn) {
                unlockCameraBtn.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    console.log('[CameraNav] Unlock Camera clicked');
                    ensureCameraFree();
                    unlockCameraBtn.style.display = 'none';
                    addConsoleMessage('Camera unlocked - free navigation enabled', 'info');
                });
                console.log('[CameraNav] Unlock button listener attached');
            }
            
            // Make ensureCameraFree globally available for other flyTo calls
            window.ensureCameraFree = ensureCameraFree;
            window.flyToWithReset = flyToWithReset;
            
            console.log('[CameraNav] Camera navigation controls initialized successfully');
            return true;
        }
        
        // Reset camera transform and re-enable user control (called after flyTo)
        function resetCameraTransform() {
            if (!viewer || !viewer.camera) return;
            
            try {
                // Reset to identity transform (frees the camera from lookAt mode)
                viewer.camera.lookAtTransform(Cesium.Matrix4.IDENTITY);
                
                // Clear any tracked entity that might lock the camera
                viewer.trackedEntity = undefined;
                
                // Re-enable all camera controls
                const controller = viewer.scene.screenSpaceCameraController;
                controller.enableRotate = true;
                controller.enableTilt = true;
                controller.enableZoom = true;
                controller.enableTranslate = true;
                controller.enableLook = true;
                
                // Hide unlock button if visible
                const unlockBtn = document.getElementById('unlock-camera-btn');
                if (unlockBtn) {
                    unlockBtn.style.display = 'none';
                }
                
                window.cameraLocked = false;
                
                // Trigger altitude changed event to update hierarchical layers
                if (window.HierarchicalRenderManager) {
                    HierarchicalRenderManager.updateVisibilityForAltitude();
                }
            } catch (error) {
                console.warn('[CameraNav] Error resetting camera transform:', error);
            }
        }
        
        // Show unlock button when camera is locked after flyTo
        function showCameraUnlockButton() {
            const unlockBtn = document.getElementById('unlock-camera-btn');
            if (unlockBtn) {
                unlockBtn.style.display = 'block';
                window.cameraLocked = true;
            }
        }
        
        // Make resetCameraTransform globally available
        window.resetCameraTransform = resetCameraTransform;
        window.showCameraUnlockButton = showCameraUnlockButton;
        
        // Global flyToWithReset - use this for ALL camera flyTo operations
        // Automatically resets camera transform after flight completes
        window.flyToWithReset = function(options) {
            if (!viewer || !viewer.camera) {
                console.warn('[CameraNav] Cannot flyTo - viewer not ready');
                return;
            }

            // --- Render & camera-unlock kicker (fixes "flyTo logs but camera doesn’t move" in requestRenderMode / trackedEntity states) ---
            options = options || {};
            // Proactively unlock camera BEFORE starting flight (trackedEntity / lookAtTransform can override animation)
            try {
                if (typeof window.resetCameraTransform === 'function') {
                    window.resetCameraTransform();
                } else if (typeof window.ensureCameraFree === 'function') {
                    window.ensureCameraFree();
                } else {
                    viewer.camera.lookAtTransform(Cesium.Matrix4.IDENTITY);
                    viewer.trackedEntity = undefined;
                    const ctrl0 = viewer.scene && viewer.scene.screenSpaceCameraController;
                    if (ctrl0) {
                        ctrl0.enableRotate = true;
                        ctrl0.enableTilt = true;
                        ctrl0.enableZoom = true;
                        ctrl0.enableTranslate = true;
                        ctrl0.enableLook = true;
                    }
                    window.cameraLocked = false;
                }
            } catch (e) {
                console.warn('[CameraNav] pre-fly unlock failed:', e);
            }

            // If requestRenderMode is enabled, Cesium will NOT always animate camera flights unless we request renders.
            let __renderKickerId = null;
            function __startRenderKicker(ms) {
                try {
                    if (!viewer || !viewer.scene || !viewer.scene.requestRenderMode) return;
                    const t0 = performance.now();
                    // ~60fps render requests for the duration of the flight
                    __renderKickerId = setInterval(function() {
                        try { viewer.scene.requestRender(); } catch (e) {}
                        if ((performance.now() - t0) > ms) {
                            try { clearInterval(__renderKickerId); } catch (e) {}
                            __renderKickerId = null;
                        }
                    }, 16);
                    try { viewer.scene.requestRender(); } catch (e) {}
                } catch (e) {
                    console.warn('[CameraNav] render kicker failed:', e);
                }
            }
            function __stopRenderKicker() {
                if (__renderKickerId) {
                    try { clearInterval(__renderKickerId); } catch (e) {}
                    __renderKickerId = null;
                }
            }
            __startRenderKicker(((options.duration || 3.0) * 1000) + 750);
const originalComplete = options.complete;
            const originalCancel = options.cancel;
            options.complete = function() {
                __stopRenderKicker();
                // Always reset camera transform after flyTo
                if (typeof window.resetCameraTransform === 'function') {
                    window.resetCameraTransform();
                } else {
                    // Inline fallback
                    viewer.camera.lookAtTransform(Cesium.Matrix4.IDENTITY);
                    viewer.trackedEntity = undefined;
                    const ctrl = viewer.scene.screenSpaceCameraController;
                    ctrl.enableRotate = true;
                    ctrl.enableTilt = true;
                    ctrl.enableZoom = true;
                    ctrl.enableTranslate = true;
                    ctrl.enableLook = true;
                }
                
                // Call original complete callback if provided
                if (originalComplete) {
                    try {
                        originalComplete();
                    } catch (e) {
                        console.warn('[CameraNav] Error in flyTo complete callback:', e);
                    }
                }            };

            // Ensure we also clean up when a flight is canceled
            options.cancel = function() {
                __stopRenderKicker();
                try {
                    if (typeof window.resetCameraTransform === 'function') window.resetCameraTransform();
                } catch (e) {}
                if (originalCancel) {
                    try { originalCancel(); } catch (e) { console.warn('[CameraNav] Error in flyTo cancel callback:', e); }
                }
            };

            try {
                // Debug: log requested destination and current camera position
                try {
                    var dest = options.destination;
                    var destCarto = null;
                    if (dest && dest.x !== undefined && dest.y !== undefined && dest.z !== undefined) {
                        destCarto = Cesium.Cartographic.fromCartesian(dest);
                    }
                    var currentCarto = Cesium.Cartographic.fromCartesian(viewer.camera.position);
                    console.log('[CameraNav] flyToWithReset requested', {
                        destinationCartesian: !!dest,
                        destinationLatLon: destCarto ? [Cesium.Math.toDegrees(destCarto.latitude).toFixed(6), Cesium.Math.toDegrees(destCarto.longitude).toFixed(6), Math.round(destCarto.height)] : null,
                        currentLatLon: currentCarto ? [Cesium.Math.toDegrees(currentCarto.latitude).toFixed(6), Cesium.Math.toDegrees(currentCarto.longitude).toFixed(6), Math.round(currentCarto.height)] : null,
                        optionsOrientation: options.orientation || null,
                        duration: options.duration || null
                    });
                } catch (dbgErr) {
                    console.debug('[CameraNav] Debugging flyTo destination failed:', dbgErr);
                }

                // Prefer viewer.flyTo with a temporary entity (Track-style) so camera remains free afterward.
                try {
                    // Build destination Cartesian3 if needed
                    let dest = options.destination;
                    let createdTemp = false;
                    let tempEntity = null;

                    if (!dest && options.lat !== undefined && options.lon !== undefined) {
                        dest = Cesium.Cartesian3.fromDegrees(options.lon, options.lat, options.height || 1000);
                    }

                    if (dest && dest.x !== undefined && dest.y !== undefined && dest.z !== undefined) {
                        // Create an invisible temporary entity at the destination and fly to it
                        tempEntity = viewer.entities.add({
                            position: dest,
                            point: { pixelSize: 1, color: Cesium.Color.TRANSPARENT }
                        });
                        createdTemp = true;
                    }

                    // Ensure we are not tracking an entity so user retains free camera control after fly
                    try { viewer.trackedEntity = undefined; } catch (e) { /* ignore */ }

                    // Build fly options for viewer.flyTo; reuse the wrapped options.complete to reset transforms
                    const flyToOpts = {
                        offset: options.offset || new Cesium.HeadingPitchRange(Cesium.Math.toRadians(0), Cesium.Math.toRadians(-45), options.range || 1000),
                        duration: options.duration || 2.5,
                        complete: function() {
                            try {
                                if (createdTemp && tempEntity) viewer.entities.remove(tempEntity);
                            } catch (e) { /* swallow */ }
                            // Call the same complete wrapper that resets camera transform
                            try {
                                if (typeof options.complete === 'function') options.complete();
                            } catch (e) {
                                console.warn('[CameraNav] flyToWithReset complete wrapper error:', e);
                            }
                        }
                    };

                    if (tempEntity) {
                        viewer.flyTo(tempEntity, flyToOpts);
                    } else {
                        // If we couldn't produce an entity target, fall back to camera.flyTo
                        viewer.camera.flyTo(options);
                    }
                } catch (e) {
                    console.warn('[CameraNav] flyToWithReset fallback to camera.flyTo after failure:', e);
                    try { viewer.camera.flyTo(options); } catch (err) { console.warn('[CameraNav] camera.flyTo also failed:', err); }
                }
            } catch (e) {
                console.warn('[CameraNav] flyToWithReset failed to invoke camera.flyTo:', e);
            }
        };
        
        // Global viewer reference
        let viewer;
        let ionosphereData = null;
        let signalPaths = [];
        
        // Missile demo variables
        let activeMissile = null;
        let plasmaSheath = null;
        let telemetryInterval = null;
        let trackingDrones = [];
        let droneTrackingActive = false;
        
        // Missile orientation calculation
        function getMissileOrientation(position, velocity) {
            if (!velocity || Cesium.Cartesian3.magnitude(velocity) < 0.1) {
                return Cesium.Quaternion.IDENTITY;
            }
            
            const normalizedVelocity = Cesium.Cartesian3.normalize(velocity, new Cesium.Cartesian3());
            const surface = Cesium.Ellipsoid.WGS84.geodeticSurfaceNormal(position);
            const east = Cesium.Cartesian3.cross(Cesium.Cartesian3.UNIT_Z, surface, new Cesium.Cartesian3());
            
            if (Cesium.Cartesian3.magnitude(east) < 0.1) {
                Cesium.Cartesian3.cross(surface, Cesium.Cartesian3.UNIT_Y, east);
            }
            Cesium.Cartesian3.normalize(east, east);
            
            const north = Cesium.Cartesian3.cross(surface, east, new Cesium.Cartesian3());
            const transform = Cesium.Matrix4.fromColumnMajorArray([
                east.x, east.y, east.z, 0,
                north.x, north.y, north.z, 0,
                surface.x, surface.y, surface.z, 0,
                0, 0, 0, 1
            ]);
            
            const velocityInTransform = Cesium.Matrix4.multiplyByPointAsVector(
                Cesium.Matrix4.inverse(transform, new Cesium.Matrix4()),
                normalizedVelocity,
                new Cesium.Cartesian3()
            );
            
            const heading = Math.atan2(velocityInTransform.x, velocityInTransform.y);
            const pitch = Math.asin(-velocityInTransform.z);
            
            return Cesium.Transforms.headingPitchRollQuaternion(
                position, 
                new Cesium.HeadingPitchRoll(heading, pitch, 0)
            );
        }
        
        // Launch hypersonic missile with tracking drones
        function launchHypersonicMissile() {
            console.log('Launching hypersonic missile with drone tracking...');
            
            // Clear existing entities
            if (activeMissile) {
                viewer.entities.remove(activeMissile);
                activeMissile = null;
            }
            
            clearTrackingDrones();
            
            const startPosition = Cesium.Cartesian3.fromDegrees(-123.0, 38.0, 20000);
            const endPosition = Cesium.Cartesian3.fromDegrees(-74.0, 40.7, 500);
            
            const direction = Cesium.Cartesian3.subtract(endPosition, startPosition, new Cesium.Cartesian3());
            const distance = Cesium.Cartesian3.magnitude(direction);
            Cesium.Cartesian3.normalize(direction, direction);
            
            const speed = 2400; // Mach 7
            const flightTimeSeconds = distance / speed;
            
            const start = Cesium.JulianDate.now();
            const end = Cesium.JulianDate.addSeconds(start, flightTimeSeconds, new Cesium.JulianDate());
            
            viewer.clock.startTime = start.clone();
            viewer.clock.stopTime = end.clone();
            viewer.clock.currentTime = start.clone();
            viewer.clock.clockRange = Cesium.ClockRange.LOOP_STOP;
            viewer.clock.multiplier = 1.0;
            
            const initialVelocity = Cesium.Cartesian3.multiplyByScalar(direction, speed, new Cesium.Cartesian3());
            
            // Create missile entity
            activeMissile = viewer.entities.add({
                name: "Hypersonic Missile",
                position: new Cesium.SampledPositionProperty(),
                model: {
                    uri: 'data:application/json;base64,' + btoa(JSON.stringify({
                        asset: { version: "2.0" },
                        scene: 0,
                        scenes: [{ nodes: [0] }],
                        nodes: [{ mesh: 0 }],
                        meshes: [{ primitives: [{ attributes: { POSITION: 0 }, indices: 1 }] }],
                        accessors: [
                            { bufferView: 0, componentType: 5126, count: 8, type: "VEC3", max: [1, 1, 4], min: [-1, -1, 0] },
                            { bufferView: 1, componentType: 5123, count: 36, type: "SCALAR" }
                        ],
                        bufferViews: [
                            { buffer: 0, byteOffset: 0, byteLength: 96 },
                            { buffer: 0, byteOffset: 96, byteLength: 72 }
                        ],
                        buffers: [{ byteLength: 168 }]
                    })),
                    minimumPixelSize: 32,
                    scale: 10.0,
                    color: Cesium.Color.ORANGE
                },
                orientation: new Cesium.CallbackProperty(function(time) {
                    const position = activeMissile.position.getValue(time);
                    if (!position) return Cesium.Quaternion.IDENTITY;
                    
                    const velocity = activeMissile.velocity ? activeMissile.velocity.getValue(time) : initialVelocity;
                    return getMissileOrientation(position, velocity);
                }, false),
                velocity: new Cesium.SampledPositionProperty(),
                path: {
                    resolution: 1,
                    material: Cesium.Color.RED.withAlpha(0.7),
                    width: 5,
                    leadTime: 0,
                    trailTime: flightTimeSeconds
                }
            });
            
            // Create trajectory
            const positionProperty = activeMissile.position;
            const samplesCount = 100;
            
            for (let i = 0; i <= samplesCount; i++) {
                const t = i / samplesCount;
                const time = Cesium.JulianDate.addSeconds(start, t * flightTimeSeconds, new Cesium.JulianDate());
                
                const pos = new Cesium.Cartesian3();
                Cesium.Cartesian3.lerp(startPosition, endPosition, t, pos);
                
                // Add slight arc
                const arcFactor = t * (1.0 - t);
                const upVector = Cesium.Cartesian3.normalize(pos, new Cesium.Cartesian3());
                const arcVector = Cesium.Cartesian3.multiplyByScalar(upVector, arcFactor * 5000, new Cesium.Cartesian3());
                Cesium.Cartesian3.add(pos, arcVector, pos);
                
                positionProperty.addSample(time, pos);
                
                if (i > 0) {
                    const prevTime = Cesium.JulianDate.addSeconds(start, (i-1) / samplesCount * flightTimeSeconds, new Cesium.JulianDate());
                    const prevPos = positionProperty.getValue(prevTime);
                    const dt = Cesium.JulianDate.secondsDifference(time, prevTime);
                    const velocity = Cesium.Cartesian3.subtract(pos, prevPos, new Cesium.Cartesian3());
                    Cesium.Cartesian3.multiplyByScalar(velocity, 1/dt, velocity);
                    activeMissile.velocity.addSample(time, velocity);
                } else {
                    activeMissile.velocity.addSample(time, initialVelocity);
                }
            }
            
            // Deploy tracking drones
            setTimeout(() => deployTrackingDrones(), 2000);
            
            console.log('Hypersonic missile launched successfully');
            
            // Auto-generate targets if none exist
            if (window.activeMissileTargets.length === 0) {
                generateMissileTargets();
            }
        }
        
        // Target generation functions for missiles
        window.activeMissileTargets = window.activeMissileTargets || [];
        
        function generateMissileTargets() {
            console.log('Starting generateMissileTargets function...');
            
            if (!viewer) {
                console.error('Cesium viewer not available for target generation');
                showNotification('Error', 'Cesium viewer not ready for target generation', 'error');
                return;
            }
            
            console.log('Generating missile targets...');
            
            // Clear existing targets
            if (window.activeMissileTargets && window.activeMissileTargets.length > 0) {
                console.log(`Clearing ${window.activeMissileTargets.length} existing targets`);
                window.activeMissileTargets.forEach(target => {
                    if (target.entity && viewer.entities.contains(target.entity)) {
                        viewer.entities.remove(target.entity);
                    }
                });
            }
            window.activeMissileTargets = [];
            
            // Generate RF signal targets (high priority)
            const rfTargets = [
                { lat: 37.7749, lon: -122.4194, type: 'rf_signal', freq: 433.92, power: 0.8, modulation: 'FM', description: 'Unauthorized FM transmission', priority: 'HIGH' },
                { lat: 40.7128, lon: -74.0060, type: 'rf_signal', freq: 162.475, power: 0.9, modulation: 'AM', description: 'Illegal maritime frequency use', priority: 'CRITICAL' },
                { lat: 34.0522, lon: -118.2437, type: 'rf_signal', freq: 27.185, power: 0.7, modulation: 'SSB', description: 'Unlicensed CB operation', priority: 'MEDIUM' }
            ];
            
            // Generate FCC violation targets (critical priority)
            const violationTargets = [
                { lat: 41.8781, lon: -87.6298, type: 'violation', freq: 121.5, description: 'Emergency frequency interference', priority: 'CRITICAL' },
                { lat: 29.7604, lon: -95.3698, type: 'violation', freq: 156.8, description: 'Maritime distress frequency abuse', priority: 'HIGH' },
                { lat: 39.7392, lon: -104.9903, type: 'violation', freq: 243.0, description: 'Military frequency intrusion', priority: 'CRITICAL' }
            ];
            
            // Add targets to the globe and tracking array
            console.log('Adding RF signal targets to globe...');
            rfTargets.forEach((target, index) => {
                console.log(`Creating RF target ${index + 1}:`, target);
                try {
                    const entity = addMissileTarget(viewer, target.lat, target.lon, target.freq, target.description, target.type, target.priority);
                    if (entity) {
                        window.activeMissileTargets.push({
                            entity: entity,
                            lat: target.lat,
                            lon: target.lon,
                            type: target.type,
                            priority: target.priority,
                            description: target.description,
                            freq: target.freq
                        });
                        console.log(`RF target ${index + 1} added successfully`);
                    } else {
                        console.error(`Failed to create RF target ${index + 1}`);
                    }
                } catch (error) {
                    console.error(`Error creating RF target ${index + 1}:`, error);
                }
            });
            
            console.log('Adding violation targets to globe...');
            violationTargets.forEach((target, index) => {
                console.log(`Creating violation target ${index + 1}:`, target);
                try {
                    const entity = addMissileTarget(viewer, target.lat, target.lon, target.freq, target.description, target.type, target.priority);
                    if (entity) {
                        window.activeMissileTargets.push({
                            entity: entity,
                            lat: target.lat,
                            lon: target.lon,
                            type: target.type,
                            priority: target.priority,
                            description: target.description,
                            freq: target.freq
                        });
                        console.log(`Violation target ${index + 1} added successfully`);
                    } else {
                        console.error(`Failed to create violation target ${index + 1}`);
                    }
                } catch (error) {
                    console.error(`Error creating violation target ${index + 1}:`, error);
                }
            });
            
            console.log(`Generated ${window.activeMissileTargets.length} missile targets total`);
            updateMissileTargetsList();
            
            // Show success notification
            showNotification('Targets Generated', `Successfully generated ${window.activeMissileTargets.length} CUDA-enhanced targets`, 'success');
        }
        
        function addMissileTarget(viewer, lat, lon, freq, description, type, priority) {
            console.log(`Creating missile target: ${type} at ${lat}, ${lon} with freq ${freq}`);
            
            // Input validation
            if (!viewer || typeof lat !== 'number' || typeof lon !== 'number' || isNaN(lat) || isNaN(lon)) {
                console.warn('Invalid parameters for missile target', { viewer: !!viewer, lat, lon, freq });
                return null;
            }
            
            // Validate coordinates
            if (lat < -90 || lat > 90 || lon < -180 || lon > 180) {
                console.warn('Invalid lat/lon values for missile target', { lat, lon });
                return null;
            }
            
            try {
                console.log('Calculating CUDA-inspired visual properties...');
                const targetColor = getTargetColor(type, priority);
                const frequencyColor = getFrequencyBasedColor(freq);
                const targetSize = getPrioritySize(priority);
                const altitude = type === 'violation' ? 200 : 100;
                
                // CUDA-inspired volumetric effect calculation
                const volumetricIntensity = calculateVolumetricIntensity(freq, priority);
                const pulseFrequency = getFrequencyPulse(freq);
                
                console.log('CUDA visual properties calculated:', {
                    targetColor: targetColor.toString(),
                    frequencyColor: frequencyColor.toString(),
                    volumetricIntensity,
                    pulseFrequency
                });
                
                const cartesian = Cesium.Cartesian3.fromDegrees(lon, lat, altitude);
                console.log('Created cartesian position:', cartesian);
                
                // Create main target entity with enhanced visual effects
                console.log('Creating Cesium entity...');
                const targetEntity = viewer.entities.add({
                    position: cartesian,
                    point: {
                        pixelSize: targetSize,
                        color: targetColor,
                        outlineColor: frequencyColor,
                        outlineWidth: 3,
                        heightReference: Cesium.HeightReference.RELATIVE_TO_GROUND,
                        scaleByDistance: new Cesium.NearFarScalar(1.5e2, 2.0, 1.5e7, 0.5),
                        // CUDA-inspired pulsing effect
                        distanceDisplayCondition: new Cesium.DistanceDisplayCondition(0.0, 1.5e7)
                    },
                    label: {
                        text: `🎯 TARGET\n${priority} PRIORITY\n${freq.toFixed(3)} MHz\n${description}`,
                        font: '14px sans-serif',
                        fillColor: frequencyColor,
                        outlineColor: Cesium.Color.BLACK,
                        outlineWidth: 2,
                        style: Cesium.LabelStyle.FILL_AND_OUTLINE,
                        verticalOrigin: Cesium.VerticalOrigin.BOTTOM,
                        horizontalOrigin: Cesium.HorizontalOrigin.CENTER,
                        pixelOffset: new Cesium.Cartesian2(0, -20),
                        heightReference: Cesium.HeightReference.RELATIVE_TO_GROUND,
                        // Enhanced visibility with distance scaling
                        scaleByDistance: new Cesium.NearFarScalar(1.5e2, 1.2, 1.5e7, 0.6)
                    },
                    // Volumetric cylinder with CUDA-inspired rendering
                    cylinder: {
                        length: altitude * 2,
                        topRadius: 50 * volumetricIntensity,
                        bottomRadius: 100 * volumetricIntensity,
                        material: new Cesium.ColorMaterialProperty(
                            frequencyColor.withAlpha(0.3 * volumetricIntensity)
                        ),
                        outline: true,
                        outlineColor: targetColor
                    },
                    // CUDA-style frequency visualization sphere
                    ellipsoid: {
                        radii: new Cesium.Cartesian3(
                            30 + freq * 0.5, 
                            30 + freq * 0.5, 
                            30 + freq * 0.5
                        ),
                        material: new Cesium.ColorMaterialProperty(
                            frequencyColor.withAlpha(0.15)
                        ),
                        outline: true,
                        outlineColor: frequencyColor.withAlpha(0.8),
                        heightReference: Cesium.HeightReference.RELATIVE_TO_GROUND
                    }
                });
                
                console.log('Basic entity created, adding CUDA-inspired effects...');
                
                // Add frequency-based pulsing animation
                addTargetPulseAnimation(targetEntity, pulseFrequency, frequencyColor, targetColor);
                console.log('Pulse animation added');
                
                // Add volumetric ray marching effect
                addVolumetricRayEffect(viewer, cartesian, freq, priority);
                console.log('Volumetric ray effects added');
                
                console.log('Target entity created successfully with all CUDA effects');
                return targetEntity;
            } catch (error) {
                console.error('Error creating missile target:', error);
                return null;
            }
        }
        
        // CUDA-inspired frequency-based color mapping
        function getFrequencyBasedColor(freq) {
            // Map frequency to visible spectrum (similar to CUDA volumetric rendering)
            const normalizedFreq = (freq % 1000) / 1000; // Normalize to 0-1
            
            if (normalizedFreq < 0.2) {
                // Low frequencies - Red (like infrared)
                return Cesium.Color.fromCssColorString(`hsl(0, 100%, ${50 + normalizedFreq * 50}%)`);
            } else if (normalizedFreq < 0.4) {
                // Medium-low frequencies - Orange to Yellow
                return Cesium.Color.fromCssColorString(`hsl(${normalizedFreq * 60}, 100%, 60%)`);
            } else if (normalizedFreq < 0.6) {
                // Medium frequencies - Green
                return Cesium.Color.fromCssColorString(`hsl(120, 100%, ${40 + normalizedFreq * 40}%)`);
            } else if (normalizedFreq < 0.8) {
                // High frequencies - Blue to Cyan
                return Cesium.Color.fromCssColorString(`hsl(${180 + normalizedFreq * 60}, 100%, 60%)`);
            } else {
                // Very high frequencies - Purple to Magenta (like UV)
                return Cesium.Color.fromCssColorString(`hsl(${270 + normalizedFreq * 60}, 100%, 70%)`);
            }
        }
        
        // Calculate volumetric intensity based on CUDA ray marching principles
        function calculateVolumetricIntensity(freq, priority) {
            let baseIntensity = 0.5;
            
            // Frequency contribution (higher frequencies = more intense)
            baseIntensity += Math.min(freq / 1000, 1.0) * 0.3;
            
            // Priority contribution
            switch(priority) {
                case 'CRITICAL': baseIntensity += 0.5; break;
                case 'HIGH': baseIntensity += 0.3; break;
                case 'MEDIUM': baseIntensity += 0.15; break;
                default: baseIntensity += 0.1;
            }
            
            return Math.min(baseIntensity, 1.5); // Cap at 1.5x
        }
        
        // Get frequency-based pulse rate
        function getFrequencyPulse(freq) {
            // Higher frequencies pulse faster (like actual RF signals)
            return Math.max(0.5, Math.min(freq / 200, 5.0));
        }
        
        // Add CUDA-inspired pulsing animation
        function addTargetPulseAnimation(entity, pulseFreq, frequencyColor, priorityColor) {
            if (!entity || !entity.point) return;
            
            // Create pulsing effect using Cesium's callback properties
            entity.point.color = new Cesium.CallbackProperty(function(time) {
                const seconds = Cesium.JulianDate.toDate(time).getTime() / 1000;
                const pulse = Math.sin(seconds * pulseFreq * Math.PI) * 0.3 + 0.7;
                
                // Blend between frequency color and priority color based on pulse
                return Cesium.Color.lerp(
                    frequencyColor.withAlpha(pulse),
                    priorityColor.withAlpha(pulse * 1.2),
                    pulse,
                    new Cesium.Color()
                );
            }, false);
            
            // Pulse the outline as well
            entity.point.outlineWidth = new Cesium.CallbackProperty(function(time) {
                const seconds = Cesium.JulianDate.toDate(time).getTime() / 1000;
                const pulse = Math.sin(seconds * pulseFreq * Math.PI * 1.5) * 0.5 + 0.5;
                return 3 + pulse * 2; // 3-5 pixel outline
            }, false);
        }
        
        // Add volumetric ray marching effect (CUDA-style)
        function addVolumetricRayEffect(viewer, position, freq, priority) {
            // Create multiple concentric spheres for volumetric effect
            const numLayers = priority === 'CRITICAL' ? 4 : (priority === 'HIGH' ? 3 : 2);
            const baseRadius = 20;
            const frequencyColor = getFrequencyBasedColor(freq);
            
            for (let i = 0; i < numLayers; i++) {
                const layerAlpha = (1.0 - i / numLayers) * 0.1;
                const layerRadius = baseRadius * (1 + i * 0.5);
                
                viewer.entities.add({
                    position: position,
                    ellipsoid: {
                        radii: new Cesium.Cartesian3(layerRadius, layerRadius, layerRadius),
                        material: new Cesium.ColorMaterialProperty(
                            frequencyColor.withAlpha(layerAlpha)
                        ),
                        heightReference: Cesium.HeightReference.RELATIVE_TO_GROUND
                    }
                });
            }
            
            // Add scanning beam effect for critical targets
            if (priority === 'CRITICAL') {
                addScanningBeamEffect(viewer, position, frequencyColor);
            }
        }
        
        // Add scanning beam effect (inspired by CUDA ray casting)
        function addScanningBeamEffect(viewer, position, color) {
            const scanHeight = 500; // Height of scanning beam
            const scanRadius = 100; // Radius of scan area
            
            viewer.entities.add({
                position: position,
                cylinder: {
                    length: scanHeight,
                    topRadius: 5,
                    bottomRadius: scanRadius,
                    material: new Cesium.ColorMaterialProperty(
                        color.withAlpha(0.05)
                    ),
                    outline: true,
                    outlineColor: color.withAlpha(0.3),
                    heightReference: Cesium.HeightReference.RELATIVE_TO_GROUND
                }
            });
        }
        
        function getTargetColor(type, priority) {
            if (priority === 'CRITICAL') return Cesium.Color.RED;
            if (priority === 'HIGH') return Cesium.Color.ORANGE;
            if (priority === 'MEDIUM') return Cesium.Color.YELLOW;
            return Cesium.Color.LIGHTBLUE;
        }
        
        function getPrioritySize(priority) {
            if (priority === 'CRITICAL') return 20;
            if (priority === 'HIGH') return 16;
            if (priority === 'MEDIUM') return 12;
            return 10;
        }
        
        function updateMissileTargetsList() {
            const targetsList = document.getElementById('missile-targets-list');
            if (!targetsList) return;
            
            if (window.activeMissileTargets.length === 0) {
                targetsList.innerHTML = '<div class="list-placeholder">No targets available</div>';
                return;
            }
            
            targetsList.innerHTML = '';
            window.activeMissileTargets.forEach((target, index) => {
                const targetItem = document.createElement('div');
                targetItem.className = 'signal-card target-card';
                targetItem.innerHTML = `
                    <div class="list-item-header">
                        <span class="list-item-title">🎯 Target ${index + 1}</span>
                        <span class="priority-badge ${target.priority.toLowerCase()}">${target.priority}</span>
                    </div>
                    <div class="feature-value">
                        <span class="feature-name">Type:</span>
                        <span>${target.type.replace('_', ' ').toUpperCase()}</span>
                    </div>
                    <div class="feature-value">
                        <span class="feature-name">Frequency:</span>
                        <span>${target.freq.toFixed(3)} MHz</span>
                    </div>
                    <div class="feature-value">
                        <span class="feature-name">Location:</span>
                        <span>${target.lat.toFixed(4)}, ${target.lon.toFixed(4)}</span>
                    </div>
                    <div class="feature-value">
                        <span class="feature-name">Description:</span>
                        <span style="font-size: 11px;">${target.description}</span>
                    </div>
                    <div class="list-item-actions">
                        <button class="action-button" onclick="selectMissileTarget(${index})">Select</button>
                        <button class="action-button" onclick="launchAtTarget(${index})">Launch</button>
                        <button class="action-button danger" onclick="removeTarget(${index})">Remove</button>
                    </div>
                `;
                targetsList.appendChild(targetItem);
            });
        }
        
        // Helper function to launch a specific missile from the UI
        function launchSpecificMissile(missileId) {
            showNotification('Missile Launch', `Launching Hypersonic Missile ${missileId}`, 'warning');
            addConsoleMessage(`Launching missile ${missileId}...`, 'command');
            
            // Launch the missile
            launchHypersonicMissile();
            
            // Deploy tracking drones
            setTimeout(() => {
                deployTrackingDrones();
                addConsoleMessage(`Missile ${missileId} launched with tracking drone support`, 'response');
            }, 1000);
            
            // Update the missile status in the list
            const missilesList = document.getElementById('missiles-list');
            const missileCards = missilesList.querySelectorAll('.signal-card');
            missileCards.forEach(card => {
                const title = card.querySelector('.list-item-title');
                if (title && title.textContent.includes(`Missile ${missileId}`)) {
                    const statusSpan = card.querySelector('.feature-value span:last-child');
                    if (statusSpan && statusSpan.textContent.includes('Ready to Launch')) {
                        statusSpan.textContent = 'Launched - In Flight';
                    }
                    const statusDot = card.querySelector('.status-dot');
                    if (statusDot) {
                        statusDot.style.backgroundColor = 'var(--danger-red)';
                    }
                }
            });
        }
        
        // Deploy tracking drones to follow the missile
        function deployTrackingDrones() {
            if (!activeMissile) return;
            
            console.log('Deploying tracking drones...');
            clearTrackingDrones();
            
            const droneCount = 3;
            const dronePositions = [
                { offset: [-5000, -5000, 2000], name: "Drone Alpha" },
                { offset: [5000, -5000, 2000], name: "Drone Beta" },
                { offset: [0, -8000, 3000], name: "Drone Gamma" }
            ];
            
            dronePositions.forEach((droneConfig, index) => {
                const drone = createTrackingDrone(droneConfig.name, droneConfig.offset, index);
                if (drone) {
                    trackingDrones.push(drone);
                }
            });
            
            droneTrackingActive = true;
            startDroneTracking();
        }
        
        // Create a tracking drone entity
        function createTrackingDrone(name, offset, index) {
            if (!activeMissile) return null;
            
            const colors = [Cesium.Color.CYAN, Cesium.Color.LIME, Cesium.Color.YELLOW];
            const color = colors[index % colors.length];
            
            const drone = viewer.entities.add({
                name: name,
                position: new Cesium.CallbackProperty(function(time) {
                    const missilePos = activeMissile.position.getValue(time);
                    if (!missilePos) return Cesium.Cartesian3.ZERO;
                    
                    // Calculate drone position relative to missile
                    const offsetCartesian = Cesium.Cartesian3.fromElements(offset[0], offset[1], offset[2]);
                    return Cesium.Cartesian3.add(missilePos, offsetCartesian, new Cesium.Cartesian3());
                }, false),
                model: {
                    uri: 'data:application/json;base64,' + btoa(JSON.stringify({
                        asset: { version: "2.0" },
                        scene: 0,
                        scenes: [{ nodes: [0] }],
                        nodes: [{ mesh: 0 }],
                        meshes: [{ primitives: [{ attributes: { POSITION: 0 } }] }],
                        accessors: [{ bufferView: 0, componentType: 5126, count: 4, type: "VEC3" }],
                        bufferViews: [{ buffer: 0, byteOffset: 0, byteLength: 48 }],
                        buffers: [{ byteLength: 48 }]
                    })),
                    minimumPixelSize: 16,
                    scale: 5.0,
                    color: color
                },
                path: {
                    resolution: 1,
                    material: color.withAlpha(0.5),
                    width: 2,
                    leadTime: 0,
                    trailTime: 30
                },
                label: {
                    text: name,
                    font: '12pt sans-serif',
                    style: Cesium.LabelStyle.FILL_AND_OUTLINE,
                    outlineWidth: 2,
                    verticalOrigin: Cesium.VerticalOrigin.BOTTOM,
                    pixelOffset: new Cesium.Cartesian2(0, -20),
                    fillColor: color,
                    show: true
                },
                billboard: {
                    image: createDroneIcon(color),
                    scale: 0.8,
                    horizontalOrigin: Cesium.HorizontalOrigin.CENTER,
                    verticalOrigin: Cesium.VerticalOrigin.CENTER
                }
            });
            
            return drone;
        }
        
        // Create drone icon
        function createDroneIcon(color) {
            const canvas = document.createElement('canvas');
            canvas.width = 32;
            canvas.height = 32;
            const ctx = canvas.getContext('2d');
            
            // Draw drone shape
            ctx.fillStyle = color.toCssColorString();
            ctx.fillRect(12, 12, 8, 8);
            ctx.fillRect(4, 4, 6, 6);
            ctx.fillRect(22, 4, 6, 6);
            ctx.fillRect(4, 22, 6, 6);
            ctx.fillRect(22, 22, 6, 6);
            
            // Draw connecting lines
            ctx.strokeStyle = color.toCssColorString();
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(7, 7); ctx.lineTo(16, 16);
            ctx.moveTo(25, 7); ctx.lineTo(16, 16);
            ctx.moveTo(7, 25); ctx.lineTo(16, 16);
            ctx.moveTo(25, 25); ctx.lineTo(16, 16);
            ctx.stroke();
            
            return canvas.toDataURL();
        }
        
        // Start drone tracking behavior
        function startDroneTracking() {
            if (!droneTrackingActive || !activeMissile) return;
            
            // Update drone behaviors periodically
            const trackingInterval = setInterval(() => {
                if (!activeMissile || trackingDrones.length === 0) {
                    clearInterval(trackingInterval);
                    return;
                }
                
                // Simulate drone tracking telemetry
                trackingDrones.forEach((drone, index) => {
                    if (drone && !drone.isDestroyed) {
                        // Simulate tracking data
                        console.log(`${drone.name}: Tracking missile, distance: ${(5000 + Math.random() * 2000).toFixed(0)}m`);
                    }
                });
            }, 2000);
        }
        
        // Clear all tracking drones
        function clearTrackingDrones() {
            trackingDrones.forEach(drone => {
                if (drone && viewer.entities.contains(drone)) {
                    viewer.entities.remove(drone);
                }
            });
            trackingDrones = [];
            droneTrackingActive = false;
        }
        
        // Initialize Cesium viewer with error handling
        function initializeCesiumViewer() {
            try {
                if (!window.Cesium) {
                    throw new Error('Cesium not loaded');
                }
                
                // Check if cesiumContainer exists
                const cesiumContainer = document.getElementById('cesiumContainer');
                if (!cesiumContainer) {
                    throw new Error('cesiumContainer element not found');
                }
                
                console.log('Attempting to initialize Cesium viewer...');
                
                // Create viewer options with terrain provider compatibility
                const viewerOptions = {
                    timeline: false,
                    animation: false,
                    baseLayerPicker: false,
                    geocoder: false,
                    homeButton: false,
                    sceneModePicker: false,
                    navigationHelpButton: false,
                    navigationInstructionsInitiallyVisible: false,
                    infoBox: true,
                    selectionIndicator: true,
                    requestRenderMode: true,
                    maximumRenderTimeChange: Infinity
                };
                
                // For CesiumJS 1.108+, use the terrain option with async provider
                // For older versions, use terrainProvider
                let terrainConfigured = false;
                
                try {
                    // CesiumJS 1.108+ uses Cesium.Terrain.fromWorldTerrain() with 'terrain' option
                    if (Cesium.Terrain && typeof Cesium.Terrain.fromWorldTerrain === 'function') {
                        viewerOptions.terrain = Cesium.Terrain.fromWorldTerrain({
                            requestVertexNormals: true,
                            requestWaterMask: true
                        });
                        terrainConfigured = true;
                        console.log('[TERRAIN] Using Cesium.Terrain.fromWorldTerrain() (1.108+ API)');
                    }
                    // Fallback for older CesiumJS versions (< 1.108)
                    else if (typeof Cesium.createWorldTerrain === 'function') {
                        viewerOptions.terrainProvider = Cesium.createWorldTerrain({
                            requestVertexNormals: true,
                            requestWaterMask: true
                        });
                        terrainConfigured = true;
                        console.log('[TERRAIN] Using Cesium.createWorldTerrain() (legacy API)');
                    }
                    // Async API for CesiumJS 1.100-1.107
                    else if (typeof Cesium.createWorldTerrainAsync === 'function') {
                        Cesium.createWorldTerrainAsync({
                            requestVertexNormals: true,
                            requestWaterMask: true
                        }).then(function(terrainProvider) {
                            if (viewer && viewer.scene && viewer.scene.globe) {
                                viewer.terrainProvider = terrainProvider;
                                console.log('[TERRAIN] World terrain loaded via async API');
                            }
                        }).catch(function(err) {
                            console.warn('[TERRAIN] Failed to load async terrain:', err);
                        });
                        terrainConfigured = true;
                        console.log('[TERRAIN] Using Cesium.createWorldTerrainAsync()');
                    }
                } catch (terrainError) {
                    console.warn('[TERRAIN] Error configuring terrain:', terrainError.message);
                }
                
                // If terrain not configured, use ellipsoid (flat earth) as fallback
                if (!terrainConfigured) {
                    viewerOptions.terrainProvider = new Cesium.EllipsoidTerrainProvider();
                    console.log('[TERRAIN] Using EllipsoidTerrainProvider (no terrain elevation)');
                }
                
                viewer = new Cesium.Viewer('cesiumContainer', viewerOptions);
                window.viewer = viewer; // Ensure globally accessible via window.viewer for external scripts
                
                /*
                // FIX: Allow scripts in InfoBox iframe (required for "Save as Recon" button interaction)
                // Cesium defaults to a restrictive sandbox that blocks scripts in the InfoBox.
                // We must ensure the 'allow-scripts' permission is present.
                // REVERTED: This is risky and unreliable. Using parent DOM popup instead.
                */


                // Enhanced imagery loading with fallback handling
                (function setupImageryWithFallback() {
                    if (!viewer || !window.Cesium) return;
                    
                    // Set a lighter base color (visible if tiles fail) - light steel blue
                    viewer.scene.globe.baseColor = Cesium.Color.fromCssColorString('#4a6a8a');
                    
                    // ===== Camera zoom limits =====
                    // Adjusted to allow closer zooms (0.1km) and much larger global view (150,000km)
                    // Note: lowering minimum altitude may expose high-zoom tile sources to CORS issues
                    const cameraController = viewer.scene.screenSpaceCameraController;
                    cameraController.minimumZoomDistance = 100;   // 0.1km (100 m) minimum altitude
                    cameraController.maximumZoomDistance = 150000000; // 150,000km max (in meters)
                    console.log('[INIT] Camera zoom limits set: 0.1km - 150,000km');
                    
                    // Track if imagery loads successfully
                    let imageryLoaded = false;
                    
                    try {
                        viewer.imageryLayers.removeAll();
                        
                        // Use CORS-friendly Stadia Maps as primary provider (based on OSM data)
                        // This avoids the direct OSM CORS issues while maintaining similar visual style
                        try {
                            const stadiaProvider = new Cesium.UrlTemplateImageryProvider({
                                url: 'https://tiles.stadiamaps.com/tiles/osm_bright/{z}/{x}/{y}.png',
                                credit: 'Map tiles by Stadia Maps, data © OpenStreetMap contributors',
                                maximumLevel: 18 // Cap at level 18 to avoid missing high-zoom tiles
                            });
                            viewer.imageryLayers.addImageryProvider(stadiaProvider);
                            imageryLoaded = true;
                            console.log('[INIT] Using Stadia Maps (OSM Bright) as primary imagery - CORS-friendly');
                        } catch (stadiaError) {
                            console.warn('[INIT] Stadia Maps failed, trying OpenStreetMap:', stadiaError);
                            
                            // Fallback to OSM with limited zoom level
                            const osmProvider = new Cesium.OpenStreetMapImageryProvider({
                                url: 'https://a.tile.openstreetmap.org/',
                                maximumLevel: 17 // Limit to zoom 17 to avoid CORS-blocked level 20 tiles
                            });
                            
                            const osmLayer = viewer.imageryLayers.addImageryProvider(osmProvider);
                            
                            // Monitor tile loading
                            osmProvider.errorEvent.addEventListener(function(error) {
                                console.warn('[IMAGERY] OSM tile load error:', error);
                                if (!imageryLoaded) {
                                    console.log('[IMAGERY] Switching to fallback imagery...');
                                    setupFallbackImagery();
                                }
                            });
                            
                            // Mark as loaded after short delay
                            setTimeout(function() {
                                if (osmLayer && osmLayer.imageryProvider && osmLayer.imageryProvider.ready) {
                                    imageryLoaded = true;
                                    console.log('[INIT] OpenStreetMap imagery provider loaded successfully');
                                } else {
                                    setupFallbackImagery();
                                }
                            }, 3000);
                        }
                        
                        viewer.scene.requestRender();
                        
                    } catch (e) {
                        console.warn('[INIT] Primary imagery provider failed:', e);
                        setupFallbackImagery();
                    }
                    
                    function setupFallbackImagery() {
                        if (imageryLoaded) return;
                        
                        console.log('[IMAGERY] Setting up fallback imagery...');
                        
                        // Use a solid visible color as fallback
                        viewer.scene.globe.baseColor = Cesium.Color.fromCssColorString('#3a5a7a');
                        console.log('[IMAGERY] Using solid base color fallback (avoids CORS issues)');
                        
                        // Try Stamen terrain tiles (CORS-friendly) as secondary
                        try {
                            const stamenProvider = new Cesium.UrlTemplateImageryProvider({
                                url: 'https://tiles.stadiamaps.com/tiles/stamen_terrain/{z}/{x}/{y}.png',
                                credit: 'Map tiles by Stamen Design, under CC BY 3.0',
                                maximumLevel: 16 // Conservative zoom limit
                            });
                            viewer.imageryLayers.addImageryProvider(stamenProvider);
                            imageryLoaded = true;
                            console.log('[IMAGERY] Stamen terrain tiles loaded as fallback');
                        } catch (stamenError) {
                            console.log('[IMAGERY] Stamen tiles unavailable, using base color only');
                        }
                    }
                })();
                
                // Ensure globe is visible and properly configured
                viewer.scene.globe.show = true;
                viewer.scene.skyBox.show = true;
                viewer.scene.sun.show = true;
                viewer.scene.moon.show = true;
                viewer.scene.skyAtmosphere.show = true;
                
                // Set a reasonable initial camera position to see the globe
                viewer.camera.setView({
                    destination: Cesium.Cartesian3.fromDegrees(-122.4194, 37.7749, 15000000.0)
                });
                
                console.log('Cesium viewer configured with globe settings');
                
                // Set initial camera position
                viewer.camera.setView({
                    destination: Cesium.Cartesian3.fromDegrees(-74.0, 40.7, 1000000),
                    orientation: {
                        heading: 0.0,
                        pitch: -0.5,
                        roll: 0.0
                    }
                });
                
                // Enable lighting
                viewer.scene.globe.enableLighting = true;
                
                // Enhanced globe and atmosphere configuration for proper rendering
                viewer.scene.globe.enableLighting = true;
                viewer.scene.globe.depthTestAgainstTerrain = false;
                viewer.scene.globe.translucency.enabled = false;
                viewer.scene.globe.baseColor = Cesium.Color.DARKSLATEGRAY; // was #000000
                viewer.scene.skyBox.show = true;
                viewer.scene.skyAtmosphere.show = true;
                viewer.scene.fog.enabled = true;
                viewer.scene.fog.density = 0.0001;
                
                // Check if AtmosphereRenderingQuality exists in this Cesium version
                if (Cesium.AtmosphereRenderingQuality && Cesium.AtmosphereRenderingQuality.COMPLETE) {
                    viewer.scene.globe.atmosphereRenderingQuality = Cesium.AtmosphereRenderingQuality.COMPLETE;
                    viewer.scene.skyAtmosphere.atmosphereRenderingQuality = Cesium.AtmosphereRenderingQuality.COMPLETE;
                } else {
                    console.log('Using default atmosphere rendering for this Cesium version');
                }
                
                // Force globe rendering properties
                viewer.scene.globe.show = true;
                viewer.scene.globe.tileCacheSize = 1000;
                
                console.log('Cesium viewer successfully initialized with enhanced globe rendering');
                
                // Ensure viewer is visible
                if (viewer && viewer.cesiumWidget) {
                    viewer.cesiumWidget.creditContainer.style.display = 'none';
                    console.log('Cesium widget visibility confirmed');
                }
                return viewer;
            } catch (error) {
                console.error('Failed to initialize Cesium viewer:', error);
                
                // Try fallback initialization without patches
                try {
                    console.log('Attempting fallback Cesium initialization...');
                    const fallbackViewer = new Cesium.Viewer('cesiumContainer', {
                        baseLayerPicker: false,
                        fullscreenButton: false,
                        geocoder: false,
                        homeButton: false,
                        sceneModePicker: false,
                        selectionIndicator: true,
                        timeline: false,
                        animation: false,
                        creditContainer: document.createElement('div'),
                        infoBox: false,
                        navigationHelpButton: false
                    });
                    
                    // Basic globe setup
                    fallbackViewer.scene.globe.enableLighting = false;
                    fallbackViewer.camera.setView({
                        destination: Cesium.Cartesian3.fromDegrees(-122.4194, 37.7749, 10000000)
                    });
                    
                    console.log('Fallback Cesium viewer initialized successfully');
                    return fallbackViewer;
                } catch (fallbackError) {
                    console.error('Fallback initialization also failed:', fallbackError);
                    return null;
                }
            }
        }
        function checkWebGLSupport() {
            try {
                const canvas = document.createElement('canvas');
                return !!window.WebGLRenderingContext && 
                    (canvas.getContext('webgl') || canvas.getContext('experimental-webgl'));
            } catch (e) {
                console.error('Error checking WebGL support:', e);
                return false;
            }
        }
        
        // Example integration of sensor ping indicators
        document.addEventListener('DOMContentLoaded', () => {
            // Add an error handler for Cesium Canvas
            // Add debug styling to ensure visibility
            const container = document.getElementById('cesiumContainer');
            if (container) {
                container.style.position = 'relative';
                container.style.width = '100%';
                container.style.height = '100%';
                container.style.zIndex = '1';
                container.style.backgroundColor = '#000';
                console.log('Cesium container styled for visibility');
            }
            if (container) {
                container.addEventListener('error', function(event) {
                    console.warn('Canvas error prevented');
                    event.preventDefault();
                    return true;
                }, true);
            }
            
            // Monitor for rendering errors (Rectangle.north issue)
            let renderErrorCount = 0;
            const MAX_RENDER_ERRORS = 3;
            
            // Add a global error handler for the Rectangle.north issue
            window.addEventListener('error', function(event) {
                if (event.error && event.error.message && event.error.message.includes('read only property') && 
                    event.error.message.includes('north')) {
                    console.error('Rectangle.north read-only error detected');
                    renderErrorCount++;
                    
                    // If we hit multiple errors, try to fix entities
                    if (renderErrorCount >= MAX_RENDER_ERRORS && typeof RF_SCYTHE !== 'undefined') {
                        // Apply Rectangle.north fix
                        if (typeof RF_SCYTHE.patchComputeRectangle === 'function') {
                            RF_SCYTHE.patchComputeRectangle();
                            console.log('Applied Rectangle.north property fix after error');
                        }
                        
                        // Try to fix invalid entities
                        if (typeof RF_SCYTHE.fixEntitiesWithInvalidPositions === 'function' && typeof viewer !== 'undefined') {
                            const fixed = RF_SCYTHE.fixEntitiesWithInvalidPositions(viewer);
                            console.log(`Fixed ${fixed} entities with potential rendering issues`);
                        }
                        
                        // Switch to safe ionosphere visualization
                        if (typeof RF_SCYTHE.initSafeIonosphereVisualization === 'function' && typeof viewer !== 'undefined') {
                            // Remove existing ionosphere entities
                            removeIonosphereLayers();
                            
                            // Create safe ionosphere visualization
                            window.safeIonosphere = RF_SCYTHE.initSafeIonosphereVisualization(viewer, {
                                useSafeEllipses: true,
                                enablePoles: false,
                                avoidProblematicLatitudes: true,
                                debug: false,
                                labelLayers: true
                            });
                            
                            console.log('Switched to safe ionosphere visualization after errors');
                        }
                    }
                }
            });
            
            // Use a try-catch for the entire initialization
            try {
                // Initialize the viewer with error handling
                console.log('Attempting to initialize Cesium viewer...');
                
                // Check if WebGL is properly supported before initializing
                if (!checkWebGLSupport()) {
                    throw new Error('WebGL is not supported or enabled in this browser');
                }
                
                // Try to initialize Cesium with our safe minimal viewer first
                if (typeof RF_SCYTHE !== 'undefined' && typeof RF_SCYTHE.initializeMinimalViewer === 'function') {
                    console.log('Using minimal viewer with error prevention...');
                    viewer = RF_SCYTHE.initializeMinimalViewer('cesiumContainer');
                    
                    if (!viewer) {
                        console.warn('Minimal viewer initialization failed, falling back to standard viewer');
                        viewer = initializeCesiumViewer();
                    }
                } else {
                    // Fall back to standard initialization
                    viewer = initializeCesiumViewer();
                }
                
                // If viewer still null, show error message
                if (!viewer) {
                    throw new Error('Failed to initialize Cesium viewer');
                }
                
                // Add render error handler specifically for Rectangle.north issues
                viewer.scene.renderError.addEventListener(function(scene, error) {
                    console.error("Cesium render error:", error.message);
                    
                    // Check if it's the Rectangle.north error
                    if (error.message && error.message.includes("read only property") && 
                        (error.message.includes("north") || error.message.includes("Rectangle"))) {
                        console.warn("Rectangle.north read-only error detected during rendering");
                        
                        // Apply Rectangle.north fix
                        if (typeof RF_SCYTHE !== 'undefined' && typeof RF_SCYTHE.patchComputeRectangle === 'function') {
                            RF_SCYTHE.patchComputeRectangle();
                            console.log("Applied Rectangle.north property fix after render error");
                            
                            // Try to patch the EllipseGeometry as well
                            if (typeof RF_SCYTHE.patchCesiumEllipses === 'function') {
                                RF_SCYTHE.patchCesiumEllipses();
                            }
                        }
                        
                        // Try to fix problematic entities
                        try {
                            // Remove ionosphere entities which often cause the issue
                            removeIonosphereLayers();
                            
                            // Create safer ionosphere if needed and not already created
                            if (!window.safeIonosphere && 
                                typeof RF_SCYTHE !== 'undefined' && 
                                typeof RF_SCYTHE.initSafeIonosphereVisualization === 'function') {
                                
                                window.safeIonosphere = RF_SCYTHE.initSafeIonosphereVisualization(viewer, {
                                    useSafeEllipses: true,
                                    enablePoles: false,
                                    avoidProblematicLatitudes: true,
                                    debug: false,
                                    labelLayers: false  // Don't add labels automatically
                                });
                                
                                console.log("Created safe ionosphere visualization after render error");
                                addConsoleMessage("Switched to enhanced ionosphere visualization to fix rendering issues", "response");
                            }
                        } catch (fixError) {
                            console.error("Error attempting to fix render error:", fixError);
                        }
                    }
                });
                
                // Add global flag for fallback visualization
                window.RF_SCYTHE_USE_FALLBACKS = true;
    
                // Initialize rendering error detection
            try {
                // Initialize the Cesium ellipse patch
                if (typeof RF_SCYTHE.patchCesiumEllipses === 'function') {
                    RF_SCYTHE.patchCesiumEllipses();
                }
                
                // Initialize the Rectangle.fromCartesianArray patch
                if (typeof RF_SCYTHE.patchRectangleFromCartesianArray === 'function') {
                    RF_SCYTHE.patchRectangleFromCartesianArray();
                }
                
                // Initialize the rendering error detector
                if (typeof RF_SCYTHE.initializeRenderingErrorDetection === 'function') {
                    RF_SCYTHE.initializeRenderingErrorDetection(viewer);
                }
                
                // Run a pre-emptive check for invalid entities
                setTimeout(() => {
                    if (typeof RF_SCYTHE.fixEntitiesWithInvalidPositions === 'function') {
                        const fixed = RF_SCYTHE.fixEntitiesWithInvalidPositions(viewer);
                        if (fixed > 0) {
                            console.log(`Pre-emptively fixed ${fixed} entities with invalid positions`);
                            addConsoleMessage(`Fixed ${fixed} entities with potential rendering issues`, 'response');
                        }
                    }
                }, 5000);
                
                console.log('Successfully initialized error prevention systems');
                addConsoleMessage('Rendering error prevention systems initialized', 'response');
            } catch (error) {
                console.error('Error initializing error prevention systems:', error);
            }

            // Initialize ionosphere data and visualization
            try {
                // Apply Rectangle.north fix first
                if (typeof RF_SCYTHE.patchComputeRectangle === "function") {
                    RF_SCYTHE.patchComputeRectangle();
                    console.log("Applied Rectangle.north property fix");
                }
                
                // Try the standard ionosphere visualization first with viewer
                const ionosphereViz = (typeof initializeIonosphereVisualization === 'function') ? initializeIonosphereVisualization(viewer) : null;
                window.ionosphereVisualization = ionosphereViz;
                
                console.log("Standard ionosphere visualization initialized");
            } catch (error) {
                console.error('Error initializing ionosphere visualization:', error);
                
                // Fallback to safe ionosphere visualization
                try {
                    if (typeof RF_SCYTHE.initSafeIonosphereVisualization === "function") {
                        console.log("Using safe ionosphere visualization as fallback");
                        const safeIonosphere = RF_SCYTHE.initSafeIonosphereVisualization(viewer, {
                            useSafeEllipses: true,
                            enablePoles: false,
                            avoidProblematicLatitudes: true,
                            debug: false,
                            labelLayers: true
                        });
                        
                        // Store in global scope for access
                        window.safeIonosphere = safeIonosphere;
                        
                        console.log("Safe ionosphere visualization initialized successfully");
                        addConsoleMessage("Using enhanced ionosphere visualization", "response");
                    } else {
                        console.error("Safe ionosphere visualization not available");
                    }
                } catch (safeIonoError) {
                    console.error("Error in safe ionosphere visualization:", safeIonoError);
                }
            }

            // Function to remove ionosphere layers
            function removeIonosphereLayers() {
                try {
                    console.log("Removing existing ionosphere layers...");
                    
                    // Remove entities with "Ionosphere" in their name
                    const entitiesToRemove = [];
                    viewer.entities.values.forEach(entity => {
                        if (entity.name && entity.name.includes('Ionosphere')) {
                            entitiesToRemove.push(entity);
                        }
                    });
                    
                    entitiesToRemove.forEach(entity => {
                        viewer.entities.remove(entity);
                    });
                    
                    console.log(`Removed ${entitiesToRemove.length} ionosphere entities`);
                    
                    // Clear any global ionosphere objects
                    ionosphereData = null;
                    signalPaths = [];
                    
                    console.log("Ionosphere layers removed successfully");
                } catch (error) {
                    console.error("Error removing ionosphere layers:", error);
                }
            }

            // Add a new status indicator for ionosphere
            const operationalStatus = document.getElementById('operational-status');
            const ionosphereStatus = document.createElement('div');
            ionosphereStatus.className = 'status-indicator status-inactive';
            ionosphereStatus.innerHTML = `
                <div class="status-dot"></div>
                <span>IONOSPHERE MODEL</span>
            `;
            operationalStatus.appendChild(ionosphereStatus);
            
            // Add ionosphere controls to settings panel
            const settingsGroup = document.querySelector('#settings-panel .settings-group:last-child');
            const ionosphereControls = document.createElement('div');
            ionosphereControls.className = 'settings-group';
            ionosphereControls.innerHTML = `
                <h4>Ionosphere Model</h4>
                <div class="settings-item">
                    <label>
                        <input type="checkbox" id="toggleIonosphere"> Show Ionospheric Layers
                    </label>
                </div>
                <div class="settings-item">
                    <label>
                        <input type="checkbox" id="toggleSignalPaths"> Show Signal Paths
                    </label>
                </div>
                <div class="settings-item">
                    <button class="action-button" id="updateIonosphereBtn">Update Ionosphere Data</button>
                </div>
            `;
            settingsGroup.parentNode.insertBefore(ionosphereControls, settingsGroup.nextSibling);
            
            // Initialize ionosphere data and visualization
            // Skip this second call since we already initialized it above with fallback handling
            // initializeIonosphereVisualization();
            
            // Initialize STRF satellite tracking
            let strfBridge = (typeof initializeSTRFBridge === 'function') ? initializeSTRFBridge(viewer) : null;
            
            // Initialize RF directional tracking
            let rfTracking = initializeRFTracking(viewer, {
                serverUrl: 'ws://localhost:8765/ws',
                autoConnect: false  // Don't connect automatically at startup
            });
            window.rfTracking = rfTracking;  // Make available globally
            
            // Initialize RF voxel visualization
            let rfVoxels = initializeRFVoxelVisualization(viewer, {
                serverUrl: 'ws://localhost:8766/ws',
                autoConnect: false,  // Don't connect automatically at startup
                position: Cesium.Cartesian3.fromDegrees(-122.4194, 37.7749, 1000), // San Francisco
                voxelSize: 100  // Size in meters of each voxel
            });
            window.rfVoxels = rfVoxels;  // Make available globally
            
            // Initialize RF hypergraph visualization system
            try {
                initializeCesiumHypergraph();
                console.log('RF Hypergraph visualization system initialized');
            } catch (error) {
                console.error('Error initializing RF hypergraph system:', error);
            }
            
            // Initialize Hierarchical Render Manager for clustering and LOD
            try {
                if (typeof HierarchicalRenderManager !== 'undefined') {
                    HierarchicalRenderManager.initialize(viewer);
                    window.hierarchicalRenderer = HierarchicalRenderManager;
                    console.log('Hierarchical Render Manager initialized (clustering enabled)');
                }
            } catch (error) {
                console.error('Error initializing Hierarchical Render Manager:', error);
            }
            
            // Initialize ViewshedManager for LOS RF analysis
            try {
                if (typeof ViewshedManager !== 'undefined') {
                    ViewshedManager.initialize(viewer);
                    window.viewshedManager = ViewshedManager;
                    console.log('ViewshedManager initialized for LOS analysis');
                }
            } catch (error) {
                console.error('Error initializing ViewshedManager:', error);
            }
            
            // Initialize RFPropagationManager for terrain-aware propagation modeling
            try {
                if (typeof RFPropagationManager !== 'undefined') {
                    RFPropagationManager.initialize(viewer);
                    window.rfPropagationManager = RFPropagationManager;
                    console.log('RFPropagationManager initialized with ITU-R P.452 terrain modeling');
                    
                    // Link to ViewshedManager if available
                    if (window.viewshedManager) {
                        window.viewshedManager.propagationManager = RFPropagationManager;
                        console.log('ViewshedManager linked to RFPropagationManager for terrain-aware LOS');
                    }
                }
            } catch (error) {
                console.error('Error initializing RFPropagationManager:', error);
            }
            
            // Initialize POI Visualization
            try {
                if (typeof POIVisualization !== 'undefined') {
                    POIVisualization.initialize(viewer);
                    window.poiViz = POIVisualization;
                    console.log('POI visualization system initialized');
                    
                    // Check POI status from API
                    fetch('/api/poi/status')
                        .then(response => response.json())
                        .then(data => {
                            if (data.status === 'ok') {
                                const countEl = document.getElementById('poi-count');
                                if (countEl) {
                                    countEl.textContent = data.total_pois;
                                }
                                console.log(`POI system loaded with ${data.total_pois} points in ${data.categories.length} categories`);
                                addConsoleMessage(`POI System: ${data.total_pois} points of interest loaded`, 'info');
                            }
                        })
                        .catch(err => console.warn('Could not fetch POI status:', err));
                }
            } catch (error) {
                console.error('Error initializing POI visualization:', error);
            }
            
            // Initialize AIS Vessel Visualization
            try {
                if (typeof AISVisualization !== 'undefined') {
                    AISVisualization.initialize(viewer);
                    window.aisViz = AISVisualization;
                    console.log('AIS Vessel visualization system initialized');
                    
                    // Check AIS status from API
                    fetch('/api/ais/status')
                        .then(response => response.json())
                        .then(data => {
                            if (data.status === 'ok') {
                                const countEl = document.getElementById('ais-vessel-count');
                                if (countEl) {
                                    countEl.textContent = data.vessel_count;
                                }
                                console.log(`AIS tracking ${data.vessel_count} vessels from ${data.total_records} records`);
                            }
                        })
                        .catch(err => console.warn('Could not fetch AIS status:', err));
                }
            } catch (error) {
                console.error('Error initializing AIS vessel visualization:', error);
            }
            
            // Initialize Operator Session Management
            try {
                if (typeof OperatorSession !== 'undefined') {
                    OperatorSession.init();
                    console.log('Operator Session Manager initialized');
                    
                    // Initialize WebSocket detection
                    if (typeof WebSocketSync !== 'undefined') {
                        WebSocketSync.init();
                    }
                    
                    // Initialize AIS Streaming Manager
                    if (typeof AISStreamManager !== 'undefined') {
                        AISStreamManager.init();
                        console.log('AIS Stream Manager initialized');
                    }
                    
                    // Update sync indicator based on EntitySync status
                    if (typeof EntitySync !== 'undefined') {
                        EntitySync.on('connected', function() {
                            updateSyncIndicator(true);
                            updateOperatorPanelStats();
                        });
                        
                        EntitySync.on('error', function() {
                            updateSyncIndicator(false);
                        });
                        
                        // Log entity events to the stream log
                        EntitySync.on('entity', function(data) {
                            logEntityEvent(data);
                            updateOperatorPanelStats();
                            
                            // Handle room messages
                            if (data.event_type === 'ROOM_MESSAGE' || data.eventType === 'ROOM_MESSAGE') {
                                addRoomChatMessage(data.entity_data || data);
                            }
                        });
                    }
                    
                    // Initialize Operator Presence
                    if (typeof OperatorPresence !== 'undefined') {
                        OperatorPresence.initialize(viewer);
                        console.log('Operator Presence tracking initialized');
                    }
                    
                    // Initialize Room Manager
                    if (typeof RoomManager !== 'undefined') {
                        RoomManager.fetchRooms();
                        
                        // Handle room events
                        RoomManager.on('room_joined', function(data) {
                            RoomManager.fetchMyRooms();
                            if (data.room) {
                                RoomManager.setCurrentRoom(data.room.room_id);
                            }
                        });
                        
                        console.log('Room Manager initialized');
                    }
                    
                    // Check operator system status
                    fetch('/api/operator/stats')
                        .then(response => response.json())
                        .then(data => {
                            if (data.status === 'ok') {
                                console.log(`Operator system ready: ${data.stats.total_operators} operators, ${data.stats.active_sessions} sessions`);
                                addConsoleMessage(`👥 Operator system: ${data.stats.total_operators} registered, ${data.stats.active_sessions} online`, 'info');
                            }
                        })
                        .catch(err => console.warn('Operator system not available:', err));
                }
            } catch (error) {
                console.error('Error initializing Operator Session:', error);
            }
            
            // Initialize Auto-Reconnaissance Visualization
            try {
                if (typeof AutoReconVisualization !== 'undefined') {
                    AutoReconVisualization.initialize(viewer);
                    window.reconViz = AutoReconVisualization;
                    console.log('Auto-Reconnaissance visualization system initialized');
                    
                    // Check recon status from API
                    fetch('/api/recon/status')
                        .then(response => response.json())
                        .then(data => {
                            if (data.status === 'ok') {
                                const countEl = document.getElementById('recon-entity-count');
                                if (countEl) {
                                    countEl.textContent = data.entity_count;
                                }
                                const alertEl = document.getElementById('recon-alert-count');
                                if (alertEl) {
                                    alertEl.textContent = '⚠️' + data.alert_count;
                                }
                                console.log(`Recon tracking ${data.entity_count} entities with ${data.alert_count} active alerts`);
                            }
                        })
                        .catch(err => console.warn('Could not fetch recon status:', err));
                }
            } catch (error) {
                console.error('Error initializing Auto-Reconnaissance visualization:', error);
            }
            
            // Initialize RF beamforming visualization
            let rfBeamforming = initializeBeamformingVisualization(viewer, {
                visible: false  // Don't show initially
            });
            window.rfBeamforming = rfBeamforming;  // Make available globally
            
            // Initialize integrated RF visualization (combines tracking, voxels and beamforming)
            try {
                let rfIntegrated = initializeIntegratedRFVisualization(viewer, {
                    serverUrl: 'ws://localhost:8765/ws',  // Same port as tracking
                    autoConnect: false  // Don't connect automatically at startup
                });
            } catch (error) {
                console.error('Error initializing integrated RF visualization:', error);
            }
            
            // ============================================
            // INITIALIZE CAMERA NAVIGATION CONTROLS
            // This MUST happen AFTER the viewer is created
            // ============================================
            try {
                if (viewer && viewer.scene && viewer.camera) {
                    initializeCameraNavigationControls();
                    console.log('[CameraNav] Camera controls initialized after viewer creation');
                } else {
                    console.error('[CameraNav] Viewer not available for camera controls - will retry');
                    // Retry after a short delay
                    setTimeout(() => {
                        if (viewer && viewer.scene && viewer.camera) {
                            initializeCameraNavigationControls();
                            console.log('[CameraNav] Camera controls initialized on retry');
                        } else {
                            console.error('[CameraNav] Viewer still not available after retry');
                        }
                    }, 1000);
                }
            } catch (error) {
                console.error('Error initializing camera navigation controls:', error);
            }
            
            // Initialize real-world network infrastructure data 
            // Enhanced Real-World Undersea Cables Database
            if (typeof RF_SCYTHE === 'undefined') {
                window.RF_SCYTHE = {};
            }
            
            // Comprehensive Real-World Submarine Cable Network
            RF_SCYTHE.realWorldSubmarineCables = {
                // Major Transoceanic Cables
                transoceanic: [
                    {
                        name: "MAREA",
                        path: [
                            [39.5085, -76.1701], // Virginia Beach, US
                            [39.0, -60.0],       // Mid-Atlantic waypoint
                            [42.0, -40.0],       // Atlantic crossing
                            [45.0, -20.0],       // European approach
                            [39.7684, -9.5007]   // Sopelana, Spain
                        ],
                        owner: "Microsoft/Facebook",
                        length: 6600,
                        capacity: "160 Tbps",
                        status: "Active",
                        type: "Transoceanic",
                        year: 2017,
                        landingPoints: "Virginia Beach (US), Sopelana (Spain)"
                    },
                    {
                        name: "Dunant",
                        path: [
                            [39.5085, -76.1701], // Virginia Beach, US
                            [39.0, -55.0],       // Atlantic waypoint 1
                            [42.0, -35.0],       // Atlantic waypoint 2
                            [45.0, -15.0],       // European approach
                            [47.2184, -2.2130]   // Saint-Hilaire-de-Riez, France
                        ],
                        owner: "Google",
                        length: 6400,
                        capacity: "250 Tbps",
                        status: "Active",
                        type: "Transoceanic",
                        year: 2020,
                        landingPoints: "Virginia Beach (US), Saint-Hilaire-de-Riez (France)"
                    },
                    {
                        name: "TAT-14",
                        path: [
                            [40.7282, -74.0776], // New York
                            [42.0, -50.0],       // Atlantic crossing 1
                            [45.0, -30.0],       // Atlantic crossing 2
                            [50.0, -15.0],       // Atlantic crossing 3
                            [51.5074, -0.1278],  // London
                            [52.3702, 4.8952],   // Amsterdam
                            [53.5511, 9.9937]    // Hamburg
                        ],
                        owner: "Consortium",
                        length: 15428,
                        capacity: "40 Gbps",
                        status: "Active",
                        type: "Transoceanic",
                        year: 2000,
                        landingPoints: "New York (US), London (UK), Amsterdam (NL), Hamburg (DE)"
                    }
                ],
                // Major Pacific Cables
                pacific: [
                    {
                        name: "FASTER",
                        path: [
                            [35.6762, 139.6503], // Tokyo
                            [35.0, 155.0],       // Pacific crossing 1
                            [30.0, 170.0],       // Pacific crossing 2
                            [40.0, -140.0],      // Pacific crossing 3
                            [37.7749, -122.4194] // San Francisco
                        ],
                        owner: "Google/NEC",
                        length: 11629,
                        capacity: "60 Tbps",
                        status: "Active",
                        type: "Transpacific",
                        year: 2016,
                        landingPoints: "Tokyo (Japan), San Francisco (US)"
                    },
                    {
                        name: "PLCN (Pacific Light Cable Network)",
                        path: [
                            [22.3964, 114.1095], // Hong Kong
                            [25.0, 130.0],       // Taiwan Strait
                            [30.0, 140.0],       // Pacific crossing 1
                            [35.0, 160.0],       // Pacific crossing 2
                            [40.0, -150.0],      // Pacific crossing 3
                            [34.0522, -118.2437] // Los Angeles
                        ],
                        owner: "Facebook/Google",
                        length: 12971,
                        capacity: "144 Tbps",
                        status: "Active",
                        type: "Transpacific",
                        year: 2018,
                        landingPoints: "Hong Kong, Los Angeles (US)"
                    },
                    {
                        name: "TPC-5",
                        path: [
                            [21.3099, -157.8581], // Honolulu
                            [25.0, -140.0],       // Pacific crossing 1
                            [30.0, -125.0],       // Pacific crossing 2
                            [37.7749, -122.4194]  // San Francisco
                        ],
                        owner: "AT&T",
                        length: 8900,
                        capacity: "280 Gbps",
                        status: "Active",
                        type: "Pacific Regional",
                        year: 1996,
                        landingPoints: "Honolulu (US), San Francisco (US)"
                    }
                ],
                // European Regional Cables
                european: [
                    {
                        name: "NorthSea Connect",
                        path: [
                            [51.5074, -0.1278],  // London
                            [52.0, 2.0],         // North Sea crossing
                            [53.0, 5.0],         // Dutch waters
                            [52.3702, 4.8952]    // Amsterdam
                        ],
                        owner: "Vodafone/Delta",
                        length: 700,
                        capacity: "8 Tbps",
                        status: "Active",
                        type: "Regional",
                        year: 2021,
                        landingPoints: "London (UK), Amsterdam (NL)"
                    },
                    {
                        name: "UK-Germany 6",
                        path: [
                            [51.5074, -0.1278],  // London
                            [52.0, 1.0],         // English Channel
                            [52.5, 3.0],         // North Sea
                            [53.5511, 9.9937]    // Hamburg
                        ],
                        owner: "Global Crossing",
                        length: 720,
                        capacity: "2.5 Tbps",
                        status: "Active",
                        type: "Regional",
                        year: 2001,
                        landingPoints: "London (UK), Hamburg (DE)"
                    }
                ],
                // Asian Regional Cables
                asian: [
                    {
                        name: "SEA-ME-WE 5",
                        path: [
                            [1.3521, 103.8198],  // Singapore
                            [6.0, 100.0],        // Malacca Strait
                            [13.0736, 80.2707],  // Chennai
                            [18.9388, 72.8354],  // Mumbai
                            [25.2048, 55.2708],  // Dubai
                            [29.3759, 47.9774],  // Kuwait
                            [30.0444, 31.2357],  // Cairo
                            [43.2965, 5.3698]    // Marseille
                        ],
                        owner: "Consortium",
                        length: 20000,
                        capacity: "24 Tbps",
                        status: "Active",
                        type: "Intercontinental",
                        year: 2017,
                        landingPoints: "Singapore, Chennai (IN), Mumbai (IN), Dubai (AE), Kuwait, Cairo (EG), Marseille (FR)"
                    },
                    {
                        name: "APCN-2 (Asia Pacific Cable Network 2)",
                        path: [
                            [35.6762, 139.6503], // Tokyo
                            [35.0, 130.0],       // Korea Strait
                            [37.5665, 126.9780], // Seoul
                            [39.0, 120.0],       // Yellow Sea
                            [39.9042, 116.4074], // Beijing
                            [31.2304, 121.4737], // Shanghai
                            [22.3964, 114.1095], // Hong Kong
                            [14.5995, 120.9842], // Manila
                            [1.3521, 103.8198]   // Singapore
                        ],
                        owner: "Consortium",
                        length: 19000,
                        capacity: "2.56 Tbps",
                        status: "Active",
                        type: "Regional Ring",
                        year: 2001,
                        landingPoints: "Tokyo (JP), Seoul (KR), Beijing (CN), Shanghai (CN), Hong Kong, Manila (PH), Singapore"
                    }
                ],
                // Caribbean and Americas Regional
                americas: [
                    {
                        name: "CFX-1 (Caribbean Fiber Exchange)",
                        path: [
                            [25.7617, -80.1918], // Miami
                            [24.5, -79.0],       // Bahamas
                            [18.2208, -66.5901], // Puerto Rico
                            [17.9, -62.8],       // Lesser Antilles
                            [12.2, -61.2],       // Grenada
                            [10.5, -61.4]        // Trinidad
                        ],
                        owner: "Columbus Networks",
                        length: 3200,
                        capacity: "40 Gbps",
                        status: "Active",
                        type: "Regional",
                        year: 2007,
                        landingPoints: "Miami (US), Nassau (BS), San Juan (PR), St. George's (GD), Port of Spain (TT)"
                    },
                    {
                        name: "UNISUR",
                        path: [
                            [-12.0464, -77.0428], // Lima, Peru
                            [-15.0, -75.0],       // Peru coast
                            [-20.0, -70.0],       // Chile approach
                            [-33.4489, -70.6693], // Santiago, Chile
                            [-34.5, -58.0],       // Argentina approach
                            [-34.6118, -58.3960]  // Buenos Aires
                        ],
                        owner: "Telefonica",
                        length: 25000,
                        capacity: "20 Tbps",
                        status: "Active",
                        type: "Regional",
                        year: 2012,
                        landingPoints: "Lima (PE), Santiago (CL), Buenos Aires (AR)"
                    }
                ],
                // Australian and Oceania
                oceania: [
                    {
                        name: "Southern Cross NEXT",
                        path: [
                            [-33.8688, 151.2093], // Sydney
                            [-35.0, 160.0],       // Tasman Sea
                            [-36.8485, 174.7633], // Auckland
                            [-30.0, -160.0],      // Pacific crossing
                            [21.3099, -157.8581], // Honolulu
                            [37.7749, -122.4194]  // San Francisco
                        ],
                        owner: "Spark New Zealand",
                        length: 28900,
                        capacity: "72 Tbps",
                        status: "Active",
                        type: "Transpacific",
                        year: 2021,
                        landingPoints: "Sydney (AU), Auckland (NZ), Honolulu (US), San Francisco (US)"
                    }
                ],
                // African Regional
                african: [
                    {
                        name: "WACS (West Africa Cable System)",
                        path: [
                            [51.5074, -0.1278],   // London
                            [38.7223, -9.1393],   // Lisbon
                            [28.1, -15.5],        // Canary Islands
                            [14.6928, -17.4467],  // Dakar
                            [6.5244, 3.3792],     // Lagos
                            [-8.8390, 13.2894],   // Luanda
                            [-33.9249, 18.4241]   // Cape Town
                        ],
                        owner: "Consortium",
                        length: 14530,
                        capacity: "5.12 Tbps",
                        status: "Active",
                        type: "Coastal",
                        year: 2012,
                        landingPoints: "London (UK), Lisbon (PT), Dakar (SN), Lagos (NG), Luanda (AO), Cape Town (ZA)"
                    }
                ]
            };

            // Real-world satellite constellation database based on current TLE data
            RF_SCYTHE.realWorldSatelliteConstellations = {
                gps: [
                    {
                        name: "GPS BIIF-12 (PRN 32)",
                        position: [-95.2, 29.7, 20200],
                        operator: "US Air Force",
                        type: "Navigation",
                        frequency: "L1/L2/L5",
                        orbit: "MEO",
                        altitude: 20200,
                        coverage: "Global",
                        status: "Active",
                        launchDate: "2016-02-05",
                        mission: "Global Positioning System"
                    },
                    {
                        name: "GPS BIII-6 (PRN 28)",
                        position: [-110.5, 35.2, 20200],
                        operator: "US Space Force",
                        type: "Navigation",
                        frequency: "L1/L2/L5",
                        orbit: "MEO",
                        altitude: 20200,
                        coverage: "Global",
                        status: "Active",
                        launchDate: "2023-01-18",
                        mission: "GPS Block III Navigation"
                    },
                    {
                        name: "GPS BIIR-13 (PRN 02)",
                        position: [-75.8, 40.1, 20200],
                        operator: "US Air Force",
                        type: "Navigation",
                        frequency: "L1/L2",
                        orbit: "MEO",
                        altitude: 20200,
                        coverage: "Global",
                        status: "Active",
                        launchDate: "2004-11-06",
                        mission: "Global Positioning System"
                    }
                ],
                starlink: [
                    {
                        name: "Starlink-24856",
                        position: [-122.4, 37.8, 550],
                        operator: "SpaceX",
                        type: "Communications",
                        frequency: "Ku/Ka Band",
                        orbit: "LEO",
                        altitude: 550,
                        coverage: "Global Broadband",
                        status: "Active",
                        launchDate: "2022-05-13",
                        mission: "Satellite Internet Constellation",
                        rfSignalStrength: 88,
                        algorithmicRisk: 0.65,
                        dataFlowRate: 8500,
                        manipulationIndicators: {
                            regularBursts: true,
                            asymmetricFlows: 0.75,
                            knownSignatures: true
                        }
                    },
                    {
                        name: "Starlink-31045",
                        position: [-87.6, 41.9, 550],
                        operator: "SpaceX",
                        type: "Communications",
                        frequency: "Ku/Ka Band",
                        orbit: "LEO",
                        altitude: 550,
                        coverage: "Global Broadband",
                        status: "Active",
                        launchDate: "2023-02-17",
                        mission: "Satellite Internet Constellation",
                        rfSignalStrength: 94,
                        algorithmicRisk: 0.58,
                        dataFlowRate: 9200,
                        manipulationIndicators: {
                            regularBursts: true,
                            asymmetricFlows: 0.68,
                            knownSignatures: false
                        }
                    },
                    {
                        name: "Starlink-27485",
                        position: [-0.1, 51.5, 550],
                        operator: "SpaceX",
                        type: "Communications",
                        frequency: "Ku/Ka Band",
                        orbit: "LEO",
                        altitude: 550,
                        coverage: "Global Broadband",
                        status: "Active",
                        launchDate: "2022-11-12",
                        mission: "Satellite Internet Constellation",
                        rfSignalStrength: 91,
                        algorithmicRisk: 0.72,
                        dataFlowRate: 7800,
                        manipulationIndicators: {
                            regularBursts: true,
                            asymmetricFlows: 0.82,
                            knownSignatures: true
                        }
                    },
                    {
                        name: "Starlink-35621",
                        position: [139.7, 35.7, 550],
                        operator: "SpaceX",
                        type: "Communications",
                        frequency: "Ku/Ka Band",
                        orbit: "LEO",
                        altitude: 550,
                        coverage: "Global Broadband",
                        status: "Active",
                        launchDate: "2023-06-23",
                        mission: "Satellite Internet Constellation",
                        rfSignalStrength: 96,
                        algorithmicRisk: 0.45,
                        dataFlowRate: 9800,
                        manipulationIndicators: {
                            regularBursts: false,
                            asymmetricFlows: 0.55,
                            knownSignatures: false
                        }
                    }
                ],
                communications: [
                    {
                        name: "Intelsat-21",
                        position: [-58.0, 0, 35786],
                        operator: "Intelsat",
                        type: "Communications",
                        frequency: "C/Ku Band",
                        orbit: "GEO",
                        altitude: 35786,
                        coverage: "Americas",
                        status: "Active",
                        launchDate: "2012-08-05",
                        mission: "Commercial Communications"
                    },
                    {
                        name: "Eutelsat-10B",
                        position: [10.0, 0, 35786],
                        operator: "Eutelsat",
                        type: "Communications",
                        frequency: "Ku/Ka Band",
                        orbit: "GEO",
                        altitude: 35786,
                        coverage: "Europe/Africa",
                        status: "Active",
                        launchDate: "2009-08-04",
                        mission: "Satellite Broadcasting"
                    },
                    {
                        name: "SES-15",
                        position: [-129.0, 0, 35786],
                        operator: "SES",
                        type: "Communications",
                        frequency: "Ku/Ka Band",
                        orbit: "GEO",
                        altitude: 35786,
                        coverage: "Americas",
                        status: "Active",
                        launchDate: "2017-05-18",
                        mission: "HTS and Broadcasting"
                    },
                    {
                        name: "Astra-5B",
                        position: [31.5, 0, 35786],
                        operator: "SES",
                        type: "Communications",
                        frequency: "Ku Band",
                        orbit: "GEO",
                        altitude: 35786,
                        coverage: "Eastern Europe",
                        status: "Active",
                        launchDate: "2014-03-22",
                        mission: "Direct-to-Home Broadcasting"
                    }
                ],
                navigation: [
                    {
                        name: "GSAT0221 (Galileo E15)",
                        position: [12.9, 57.3, 23222],
                        operator: "European Space Agency",
                        type: "Navigation",
                        frequency: "E1/E5/E6",
                        orbit: "MEO",
                        altitude: 23222,
                        coverage: "Global",
                        status: "Active",
                        launchDate: "2018-07-25",
                        mission: "Galileo Navigation System"
                    },
                    {
                        name: "BEIDOU-3 G1 (C59)",
                        position: [110.5, 1.2, 35786],
                        operator: "China National Space Administration",
                        type: "Navigation",
                        frequency: "B1/B2/B3",
                        orbit: "GEO",
                        altitude: 35786,
                        coverage: "Asia-Pacific",
                        status: "Active",
                        launchDate: "2018-11-19",
                        mission: "BeiDou Navigation System"
                    },
                    {
                        name: "QZS-4 (Michibiki)",
                        position: [131.0, 41.0, 32600],
                        operator: "Japan Aerospace Exploration Agency",
                        type: "Navigation",
                        frequency: "L1/L2/L5",
                        orbit: "QZO",
                        altitude: 32600,
                        coverage: "Asia-Oceania",
                        status: "Active",
                        launchDate: "2017-10-10",
                        mission: "Quasi-Zenith Satellite System"
                    },
                    {
                        name: "IRNSS-1I (NavIC I09)",
                        position: [83.0, 29.0, 35786],
                        operator: "Indian Space Research Organisation",
                        type: "Navigation",
                        frequency: "L5/S Band",
                        orbit: "GEO",
                        altitude: 35786,
                        coverage: "Indian Subcontinent",
                        status: "Active",
                        launchDate: "2018-04-12",
                        mission: "Indian Regional Navigation System"
                    }
                ],
                scientific: [
                    {
                        name: "Hubble Space Telescope",
                        position: [-80.1, 28.5, 547],
                        operator: "NASA/ESA",
                        type: "Scientific",
                        frequency: "S/Ku Band",
                        orbit: "LEO",
                        altitude: 547,
                        coverage: "Deep Space Observation",
                        status: "Active",
                        launchDate: "1990-04-24",
                        mission: "Space Telescope"
                    },
                    {
                        name: "James Webb Space Telescope",
                        position: [-60.0, 0, 1500000],
                        operator: "NASA/ESA/CSA",
                        type: "Scientific",
                        frequency: "S/Ka Band",
                        orbit: "L2 Halo",
                        altitude: 1500000,
                        coverage: "Deep Space Infrared",
                        status: "Active",
                        launchDate: "2021-12-25",
                        mission: "Infrared Space Observatory"
                    },
                    {
                        name: "International Space Station",
                        position: [-74.0, 40.7, 408],
                        operator: "NASA/Roscosmos/ESA",
                        type: "Scientific",
                        frequency: "S/Ku Band",
                        orbit: "LEO",
                        altitude: 408,
                        coverage: "Earth Observation/Research",
                        status: "Active",
                        launchDate: "1998-11-20",
                        mission: "Space Station Research Platform"
                    }
                ],
                military: [
                    {
                        name: "COSMOS-2544",
                        position: [40.0, 65.0, 19100],
                        operator: "Russian Federation",
                        type: "Military",
                        frequency: "Classified",
                        orbit: "MEO",
                        altitude: 19100,
                        coverage: "Regional",
                        status: "Active",
                        launchDate: "2019-12-26",
                        mission: "GLONASS Navigation/Military",
                        rfSignalStrength: 78,
                        algorithmicRisk: 0.89,
                        dataFlowRate: 15000,
                        manipulationIndicators: {
                            regularBursts: true,
                            asymmetricFlows: 0.95,
                            knownSignatures: true
                        }
                    },
                    {
                        name: "USA-326 (AEHF-6)",
                        position: [-105.0, 0, 35786],
                        operator: "US Space Force",
                        type: "Military",
                        frequency: "EHF/SHF",
                        orbit: "GEO",
                        altitude: 35786,
                        coverage: "Global",
                        status: "Active",
                        launchDate: "2020-03-26",
                        mission: "Advanced Extremely High Frequency Communications",
                        rfSignalStrength: 95,
                        algorithmicRisk: 0.35,
                        dataFlowRate: 12000,
                        manipulationIndicators: {
                            regularBursts: false,
                            asymmetricFlows: 0.4,
                            knownSignatures: false
                        }
                    },
                    {
                        name: "Tianlian-2-01",
                        position: [77.0, 0, 35786],
                        operator: "China National Space Administration",
                        type: "Military",
                        frequency: "S/Ka Band",
                        orbit: "GEO",
                        altitude: 35786,
                        coverage: "Asia-Pacific",
                        status: "Active",
                        launchDate: "2019-03-31",
                        mission: "Data Relay and Communications",
                        rfSignalStrength: 86,
                        algorithmicRisk: 0.82,
                        dataFlowRate: 18000,
                        manipulationIndicators: {
                            regularBursts: true,
                            asymmetricFlows: 0.88,
                            knownSignatures: true
                        }
                    }
                ],
                weather: [
                    {
                        name: "GOES-18",
                        position: [-137.0, 0, 35786],
                        operator: "NOAA",
                        type: "Weather",
                        frequency: "S/Ka Band",
                        orbit: "GEO",
                        altitude: 35786,
                        coverage: "Western Americas",
                        status: "Active",
                        launchDate: "2022-03-01",
                        mission: "Geostationary Weather Monitoring"
                    },
                    {
                        name: "Meteosat-12",
                        position: [9.5, 0, 35786],
                        operator: "EUMETSAT",
                        type: "Weather",
                        frequency: "S/Ka Band",
                        orbit: "GEO",
                        altitude: 35786,
                        coverage: "Europe/Africa",
                        status: "Active",
                        launchDate: "2022-12-13",
                        mission: "Meteorological Imaging"
                    },
                    {
                        name: "Himawari-9",
                        position: [140.7, 0, 35786],
                        operator: "Japan Meteorological Agency",
                        type: "Weather",
                        frequency: "S/Ka Band",
                        orbit: "GEO",
                        altitude: 35786,
                        coverage: "Asia-Pacific",
                        status: "Active",
                        launchDate: "2016-11-02",
                        mission: "Weather and Climate Monitoring"
                    }
                ]
            };
            
            // Try to load DB-driven satellite constellations at runtime.
            // If successful, this will override the hard-coded `RF_SCYTHE.realWorldSatelliteConstellations`.
            (function(){
                // Use a conservative limit so the page stays responsive
                fetch('/api/satellites?limit=10000')
                    .then(r => r.json())
                    .then(data => {
                        try {
                            const sats = data && data.satellites ? data.satellites : [];
                            if (!sats || sats.length === 0) {
                                document.documentElement.setAttribute('data-satellites-loaded','fallback');
                                console.log('No satellites returned from API; using fallback data');
                                return;
                            }

                            // Group by type (lowercased) to match the structure expected by the page
                            const grouped = {};
                            sats.forEach(s => {
                                const t = (s.type || 'other').toLowerCase();
                                if (!grouped[t]) grouped[t] = [];

                                grouped[t].push({
                                    name: s.name || s[0] || 'unknown',
                                    position: s.position || (s.extra && s.extra.position) || [0,0,(s.altitude||s.alt||0)],
                                    operator: s.operator || s.extra && s.extra.operator || '',
                                    type: s.type || '',
                                    frequency: s.frequency || '',
                                    orbit: s.orbit || '',
                                    altitude: s.altitude || s.alt || null,
                                    coverage: s.coverage || '',
                                    status: s.status || '',
                                    launchDate: s.launch_date || s.launchDate || '',
                                    mission: s.mission || '',
                                    extra: s.extra || {}
                                });
                            });

                            window.RF_SCYTHE = window.RF_SCYTHE || {};
                            window.RF_SCYTHE.realWorldSatelliteConstellations = grouped;

                            // DOM indicator for quick verification in any browser
                            document.documentElement.setAttribute('data-satellites-loaded','db');
                            console.log('Satellites loaded from DB (count):', sats.length);

                            try {
                                let badge = document.getElementById('satellite-load-indicator');
                                if (!badge) {
                                    badge = document.createElement('div');
                                    badge.id = 'satellite-load-indicator';
                                    badge.style.position = 'fixed';
                                    badge.style.right = '8px';
                                    badge.style.bottom = '8px';
                                    badge.style.padding = '6px 8px';
                                    badge.style.background = 'rgba(0,0,0,0.6)';
                                    badge.style.color = '#7CFC00';
                                    badge.style.fontSize = '12px';
                                    badge.style.zIndex = 999999;
                                    badge.style.borderRadius = '4px';
                                    badge.style.fontFamily = 'monospace';
                                    badge.textContent = 'Satellites: DB';
                                    document.body.appendChild(badge);
                                } else {
                                    badge.textContent = 'Satellites: DB';
                                }
                            } catch (e) {
                                // Non-fatal: DOM may not be ready yet
                                console.debug('Could not add satellite-load-indicator badge:', e);
                            }

                        } catch (e) {
                            console.warn('Error processing satellites API response', e);
                            document.documentElement.setAttribute('data-satellites-loaded','error');
                        }
                    })
                    .catch(err => {
                        document.documentElement.setAttribute('data-satellites-loaded','error');
                        console.warn('Could not fetch /api/satellites:', err);
                    });
            })();

            // Compile all cables into comprehensive network data
            RF_SCYTHE.sampleNetworkData = {
                underseaCables: [
                    ...RF_SCYTHE.realWorldSubmarineCables.transoceanic,
                    ...RF_SCYTHE.realWorldSubmarineCables.pacific,
                    ...RF_SCYTHE.realWorldSubmarineCables.european,
                    ...RF_SCYTHE.realWorldSubmarineCables.asian,
                    ...RF_SCYTHE.realWorldSubmarineCables.americas,
                    ...RF_SCYTHE.realWorldSubmarineCables.oceania,
                    ...RF_SCYTHE.realWorldSubmarineCables.african
                ],
                satellites: [
                    ...RF_SCYTHE.realWorldSatelliteConstellations.gps,
                    ...RF_SCYTHE.realWorldSatelliteConstellations.starlink,
                    ...RF_SCYTHE.realWorldSatelliteConstellations.communications,
                    ...RF_SCYTHE.realWorldSatelliteConstellations.navigation,
                    ...RF_SCYTHE.realWorldSatelliteConstellations.scientific,
                    ...RF_SCYTHE.realWorldSatelliteConstellations.military,
                    ...RF_SCYTHE.realWorldSatelliteConstellations.weather
                ],
                cellTowers: [
                    {
                        name: "SF-5G-Tower-001",
                        position: [37.7749, -122.4194, 50],
                        type: "5G",
                        operator: "Verizon",
                        frequency: "28 GHz",
                        range: "500m",
                        connectedDevices: 2500,
                        throughput: "10 Gbps",
                        status: "Active"
                    },
                    {
                        name: "NYC-5G-Tower-Central",
                        position: [40.7128, -74.0060, 60],
                        type: "5G",
                        operator: "T-Mobile",
                        frequency: "2.5 GHz",
                        range: "2km",
                        connectedDevices: 5000,
                        throughput: "5 Gbps",
                        status: "Active"
                    },
                    {
                        name: "LON-4G-Tower-City",
                        position: [51.5074, -0.1278, 45],
                        type: "4G LTE",
                        operator: "EE",
                        frequency: "800 MHz",
                        range: "5km",
                        connectedDevices: 3000,
                        throughput: "150 Mbps",
                        status: "Active"
                    }
                ],
                fiberBackbones: [
                    {
                        name: "US East-West Trunk",
                        path: [
                            [40.7128, -74.0060],  // New York
                            [39.9526, -75.1652],  // Philadelphia 
                            [38.9072, -77.0369],  // Washington DC
                            [35.2271, -80.8431],  // Charlotte
                            [33.7490, -84.3880],  // Atlanta
                            [32.0835, -81.0998],  // Savannah
                            [30.3322, -81.6557],  // Jacksonville
                            [25.7617, -80.1918]   // Miami
                        ],
                        owner: "Level 3",
                        capacity: "100 Tbps",
                        status: "Active"
                    },
                    {
                        name: "European Backbone",
                        path: [
                            [51.5074, -0.1278],   // London
                            [50.8503, 4.3517],    // Brussels
                            [52.3702, 4.8952],    // Amsterdam
                            [52.5200, 13.4050],   // Berlin
                            [50.0755, 14.4378],   // Prague
                            [47.4979, 19.0402],   // Budapest
                            [44.4268, 26.1025]    // Bucharest
                        ],
                        owner: "Deutsche Telekom",
                        capacity: "80 Tbps",
                        status: "Active"
                    },
                    {
                        name: "Asian Corridor",
                        path: [
                            [35.6762, 139.6503],  // Tokyo
                            [37.5665, 126.9780],  // Seoul
                            [39.9042, 116.4074],  // Beijing
                            [31.2304, 121.4737],  // Shanghai
                            [22.3964, 114.1095],  // Hong Kong
                            [1.3521, 103.8198]    // Singapore
                        ],
                        owner: "NTT Communications",
                        capacity: "200 Tbps",
                        status: "Active"
                    }
                ]
            };
            
            // Enhanced violator data showing cross-infrastructure hopping
            RF_SCYTHE.sampleViolatorData = {
                frequency: 162.475,
                description: "Unauthorized transmission jumping between undersea cable, satellite, and terrestrial networks",
                path: [
                    { type: "undersea", location: [40.7128, -74.0060], infrastructure: "TAT-14", timestamp: "2023-10-15T14:30:00Z" },
                    { type: "satellite", location: [51.5074, -0.1278], infrastructure: "Intelsat-21", timestamp: "2023-10-15T14:31:15Z" },
                    { type: "cellTower", location: [48.8566, 2.3522], infrastructure: "Paris-5G-001", timestamp: "2023-10-15T14:32:30Z" },
                    { type: "fiber", location: [52.5200, 13.4050], infrastructure: "European Backbone", timestamp: "2023-10-15T14:33:45Z" }
                ],
                severity: "HIGH",
                status: "TRACKING"
            };
            
            console.log('Real-world submarine cable network data loaded:', RF_SCYTHE.realWorldSubmarineCables);
            try {
                // Create network infrastructure visualization instance
                const networkInfra = new RF_SCYTHE.NetworkInfrastructure(viewer);
                window.networkInfra = networkInfra;  // Make available globally
                
                // Wait a bit before adding sample data to ensure Cesium is ready
                setTimeout(() => {
                    // Load sample network infrastructure data
                    networkInfra.addUnderseaCables(RF_SCYTHE.sampleNetworkData.underseaCables);
                    networkInfra.addSatellites(RF_SCYTHE.sampleNetworkData.satellites);
                    networkInfra.addCellTowers(RF_SCYTHE.sampleNetworkData.cellTowers);
                    networkInfra.addFiberBackbones(RF_SCYTHE.sampleNetworkData.fiberBackbones);
                    
                    // Update the count in the UI
                    updateNetworkElementsCount();
                    
                    // Add console message
                    addConsoleMessage('Network infrastructure visualization initialized', 'response');
                    
                    // Set up altitude-based visibility for network infrastructure
                    setupNetworkInfrastructureAltitudeListener(networkInfra);
                }, 2000);
                
                // Add event listeners for controls
                const toggleUnderseaCables = document.getElementById('toggleUnderseaCables');
                const toggleSatellites = document.getElementById('toggleSatellites');
                const toggleCellTowers = document.getElementById('toggleCellTowers');
                const toggleFiberBackbones = document.getElementById('toggleFiberBackbones');
                const scanNetworkBtn = document.getElementById('scanNetworkBtn');
                
                if (toggleUnderseaCables) {
                    toggleUnderseaCables.addEventListener('change', function() {
                        networkInfra.setUnderseaCablesVisible(this.checked);
                    });
                }
                
                if (toggleSatellites) {
                    toggleSatellites.addEventListener('change', function() {
                        networkInfra.setSatellitesVisible(this.checked);
                    });
                }

                // Satellites search controls
                const searchSatellitesBtn = document.getElementById('searchSatellitesBtn');
                const clearSatelliteResultsBtn = document.getElementById('clearSatelliteResultsBtn');
                const satelliteResultsList = document.getElementById('satellite-results-list');

                function getViewBoundingBox() {
                    try {
                        if (!viewer || !viewer.scene || !viewer.camera) return null;
                        const rect = viewer.camera.computeViewRectangle(viewer.scene.globe.ellipsoid);
                        if (!rect) return null;
                        return {
                            west: Cesium.Math.toDegrees(rect.west),
                            south: Cesium.Math.toDegrees(rect.south),
                            east: Cesium.Math.toDegrees(rect.east),
                            north: Cesium.Math.toDegrees(rect.north)
                        };
                    } catch (e) {
                        console.debug('getViewBoundingBox failed:', e);
                        return null;
                    }
                }

                function lonInRange(lon, west, east) {
                    // normalize to -180..180
                    const l = ((lon + 180) % 360 + 360) % 360 - 180;
                    const w = ((west + 180) % 360 + 360) % 360 - 180;
                    const e = ((east + 180) % 360 + 360) % 360 - 180;
                    if (w <= e) return l >= w && l <= e;
                    // wraps dateline
                    return l >= w || l <= e;
                }

                function renderSatelliteResults(list) {
                    if (!satelliteResultsList) return;
                    if (!list || list.length === 0) {
                        satelliteResultsList.innerHTML = '<div style="color:#888;">No satellites in view</div>';
                        return;
                    }

                    const html = list.map((s, idx) => {
                        const pos = s.position || s.position_deg || (s.extra && s.extra.position) || [];
                        const lon = pos[0] || 0;
                        const lat = pos[1] || 0;
                        const alt = pos[2] || (s.altitude || s.alt || 0);
                        const safeName = (s.name || s[0] || 'unknown').replace(/'/g, "\\'");
                        return `
                            <div class="sat-item" style="padding:6px; border-bottom:1px solid rgba(255,255,255,0.03); display:flex; align-items:center; justify-content:space-between;">
                                <div style="flex:1; font-size:12px; color:#fff;">
                                    <div style="font-weight:bold;">${safeName}</div>
                                    <div style="font-size:11px; color:#bbb;">${lat.toFixed(3)}, ${lon.toFixed(3)} @ ${Math.round(alt)} km</div>
                                </div>
                                <div style="display:flex; gap:6px; margin-left:8px;">
                                    <button class="action-button" style="padding:4px 8px; font-size:11px;" onclick="(function(){window._sat_track(${lon},${lat},${alt},'${safeName}')})()">Track</button>
                                    <button class="action-button" style="padding:4px 8px; font-size:11px;" onclick="(function(){window._sat_info('${safeName}', ${lon}, ${lat}, ${alt})})()">Info</button>
                                    <button class="action-button" style="padding:4px 8px; font-size:11px;" onclick="(function(){window._sat_to_recon('${safeName}', ${lon}, ${lat}, ${alt})})()">Make Recon</button>
                                </div>
                            </div>`;
                    }).join('');

                    satelliteResultsList.innerHTML = html;
                }

                // Satellite radar layer: create a CustomDataSource and auto-refresh
                function initSatelliteRadarLayer(viewer, refreshIntervalSec = 30) {
                    if (!viewer) return null;
                    if (window.satDataSource) return window.satDataSource;

                    const satDataSource = new Cesium.CustomDataSource('satellites_radar');
                    viewer.dataSources.add(satDataSource);
                    window.satDataSource = satDataSource;
                    window._satEntities = {};

                    // Animate pulses on preRender
                    viewer.scene.preRender.addEventListener(function() {
                        const t = Date.now() / 1000.0;
                        for (const id in window._satEntities) {
                            const rec = window._satEntities[id];
                            if (!rec || !rec.pulse) continue;
                            const base = rec.baseRadius || 20000; // meters
                            const factor = 0.5 + 0.5 * Math.abs(Math.sin(t * 2.0 + (rec._phase || 0)));
                            rec.pulse.ellipse.semiMajorAxis = base * (0.6 + factor);
                            rec.pulse.ellipse.semiMinorAxis = base * (0.6 + factor);
                            // fade by setting material color alpha
                            const alpha = 0.25 * (1.0 - factor) + 0.05;
                            rec.pulse.ellipse.material = Cesium.Color.CYAN.withAlpha(alpha);
                        }
                    });

                    async function refreshSatellites() {
                        try {
                            const resp = await fetch('/api/satellites?limit=1000');
                            const json = await resp.json();
                            if (!json || json.status !== 'ok') return;
                            const sats = json.satellites || [];

                            const seen = new Set();
                            for (const s of sats) {
                                const id = 'sat-' + (s.id || s.name || Math.random());
                                seen.add(id);
                                const lat = parseFloat(s.lat || s.lat_deg || (s.extra && s.extra.lat) || 0);
                                const lon = parseFloat(s.lon || s.lon_deg || (s.extra && s.extra.lon) || 0);
                                const alt_km = parseFloat(s.altitude || (s.extra && s.extra.altitude) || 400);
                                const alt_m = alt_km * 1000;

                                if (!window._satEntities[id]) {
                                    // create main entity (billboard + label)
                                    const ent = satDataSource.entities.add({
                                        id: id,
                                        name: s.name || ('sat-'+(s.id||'')),
                                        position: Cesium.Cartesian3.fromDegrees(lon, lat, alt_m),
                                        billboard: {
                                            image: 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24"><circle cx="12" cy="12" r="6" fill="cyan"/></svg>',
                                            verticalOrigin: Cesium.VerticalOrigin.CENTER,
                                            scale: 1.0
                                        },
                                        label: {
                                            text: s.name || '',
                                            font: '12px sans-serif',
                                            fillColor: Cesium.Color.WHITE,
                                            style: Cesium.LabelStyle.FILL_AND_OUTLINE,
                                            outlineWidth: 2,
                                            pixelOffset: new Cesium.Cartesian2(12, 12)
                                        }
                                    });

                                    // pulsing ellipse
                                    const pulse = satDataSource.entities.add({
                                        id: id + '-pulse',
                                        position: ent.position,
                                        ellipse: {
                                            semiMajorAxis: 20000,
                                            semiMinorAxis: 20000,
                                            material: Cesium.Color.CYAN.withAlpha(0.15),
                                            height: alt_m - 1000
                                        }
                                    });

                                    window._satEntities[id] = { entity: ent, pulse: pulse, baseRadius: 20000, _phase: Math.random() * Math.PI };
                                } else {
                                    // update position
                                    const rec = window._satEntities[id];
                                    if (rec && rec.entity) {
                                        rec.entity.position = Cesium.Cartesian3.fromDegrees(lon, lat, alt_m);
                                        if (rec.pulse) rec.pulse.position = rec.entity.position;
                                    }
                                }
                            }

                            // remove stale
                            for (const id in window._satEntities) {
                                if (!seen.has(id)) {
                                    const rec = window._satEntities[id];
                                    if (rec) {
                                        if (rec.entity) satDataSource.entities.remove(rec.entity);
                                        if (rec.pulse) satDataSource.entities.remove(rec.pulse);
                                    }
                                    delete window._satEntities[id];
                                }
                            }
                        } catch (e) {
                            console.error('Failed to refresh satellites:', e);
                        }
                    }

                    // initial fetch
                    refreshSatellites();
                    const intId = setInterval(refreshSatellites, Math.max(5000, (refreshIntervalSec || 30) * 1000));
                    satDataSource._refreshIntervalId = intId;

                    return satDataSource;
                }

                // initialize radar layer if viewer present
                try {
                    if (viewer) {
                        const satLayer = initSatelliteRadarLayer(viewer, 30);
                        // wire toggle control if available
                        if (toggleSatellites) {
                            toggleSatellites.addEventListener('change', function() {
                                if (satLayer) satLayer.show = this.checked;
                            });
                        }
                    }
                } catch (e) {
                    console.error('Satellite radar init error:', e);
                }

                window._sat_track = function(lon, lat, alt, name) {
                    try {
                        addConsoleMessage(`Tracking satellite: ${name}`,'command');
                        ensureCameraFree();
                        const dest = Cesium.Cartesian3.fromDegrees(lon, lat, Math.max(alt*1000, 1000));
                        window.flyToWithReset({ destination: dest, duration: 2.5 });
                    } catch (e) { console.warn('sat_track failed', e); }
                };

                window._sat_info = function(name, lon, lat, alt) {
                    try {
                        const msg = `Satellite Info:\nName: ${name}\nLat: ${lat}\nLon: ${lon}\nAlt(km): ${alt}`;
                        addConsoleMessage(msg, 'response');
                        alert(msg);
                    } catch (e) { console.warn('sat_info failed', e); }
                };

                window._sat_to_recon = function(name, lon, lat, alt) {
                    try {
                        if (!window.AutoReconVisualization) {
                            addConsoleMessage('AutoReconVisualization not initialized - initializing now', 'info');
                            if (viewer) window.AutoReconVisualization.initialize(viewer);
                        }

                        const id = `sat_${name.replace(/[^a-zA-Z0-9_-]/g,'')}_${Date.now()}`;
                        const entity = {
                            entity_id: id,
                            name: name,
                            location: { lat: lat, lon: lon, altitude_m: ((alt || 0) * 1000) },
                            disposition: 'UNKNOWN',
                            threat_level: 'NONE',
                            ontology: ['satellite']
                        };

                        window.AutoReconVisualization.entities[id] = entity;
                        window.AutoReconVisualization.renderEntities();
                        addConsoleMessage(`Added ${name} as recon entity (${id})`, 'response');
                    } catch (e) { console.warn('sat_to_recon failed', e); }
                };

                function searchSatellitesInView() {
                    try {
                        const bounds = getViewBoundingBox();
                        if (!bounds) {
                            addConsoleMessage('Viewer not ready for satellite search', 'alert');
                            return;
                        }

                        const groups = (window.RF_SCYTHE && window.RF_SCYTHE.realWorldSatelliteConstellations) ? window.RF_SCYTHE.realWorldSatelliteConstellations : {};
                        const flat = [];
                        Object.keys(groups).forEach(k => { (groups[k]||[]).forEach(s => flat.push(s)); });

                        const results = flat.filter(s => {
                            const pos = s.position || (s.extra && s.extra.position) || [];
                            if (!pos || pos.length < 2) return false;
                            const lon = pos[0];
                            const lat = pos[1];
                            const inLat = lat >= bounds.south && lat <= bounds.north;
                            const inLon = lonInRange(lon, bounds.west, bounds.east);
                            return inLat && inLon;
                        });

                        renderSatelliteResults(results.slice(0,200));
                        addConsoleMessage(`Found ${results.length} satellites in view`, 'response');
                    } catch (e) { console.warn('searchSatellitesInView failed', e); }
                }

                if (searchSatellitesBtn) searchSatellitesBtn.addEventListener('click', function(){ searchSatellitesInView(); });
                if (clearSatelliteResultsBtn) clearSatelliteResultsBtn.addEventListener('click', function(){ if (satelliteResultsList) satelliteResultsList.innerHTML = '<div style="color:#888;">No satellites searched yet</div>'; });
                
                if (toggleCellTowers) {
                    toggleCellTowers.addEventListener('change', function() {
                        networkInfra.setCellTowersVisible(this.checked);
                    });
                }
                
                if (toggleFiberBackbones) {
                    toggleFiberBackbones.addEventListener('change', function() {
                        networkInfra.setFiberBackbonesVisible(this.checked);
                    });
                }
                
                // Scan network infrastructure button
                if (scanNetworkBtn) {
                    scanNetworkBtn.addEventListener('click', function() {
                        // Simulate scanning the network
                        showNotification('Network Scan Started', 'Scanning global network infrastructure for anomalies...', 'info');
                        addConsoleMessage('Starting global network infrastructure scan...', 'command');
                        
                        // Simulate finding results after a delay
                        setTimeout(() => {
                            addConsoleMessage('Network scan complete. Found 3 undersea cables, 3 satellites, 3 cell towers, and 3 fiber backbones.', 'response');
                            
                            // Maybe discover a new satellite
                            if (Math.random() > 0.5) {
                                const newSatellite = {
                                    name: "Surveillance-SAT-X",
                                    position: [-60, 40], // North Atlantic
                                    altitude: 700,       // km
                                    type: "Surveillance",
                                    operator: "Unknown",
                                    orbit: "LEO",
                                    frequencies: "X and Ku bands",
                                    coverage: "Atlantic Region",
                                active: true
                            };
                            
                            networkInfra.addSatellites([newSatellite]);
                            updateNetworkElementsCount();
                            
                            addConsoleMessage('ALERT: Unregistered satellite detected in North Atlantic region', 'alert');
                            showNotification('New Satellite Detected', 'Unregistered satellite found operating in North Atlantic region on X and Ku bands. Potential surveillance platform.', 'warning');
                        }
                    }, 3000);
                    });
                }
                
                // Track FCC violators button
                const trackViolatorsBtn = document.getElementById('trackViolatorsBtn');
                if (trackViolatorsBtn) {
                    trackViolatorsBtn.addEventListener('click', function() {
                        // Simulate tracking a violator
                        showNotification('Tracking FCC Violator', 'Analyzing cross-infrastructure activity of suspected FCC violator...', 'info');
                        addConsoleMessage('Initiating cross-infrastructure tracking of FCC violator...', 'command');
                        
                        // After a delay, show the violator's path
                        setTimeout(() => {
                            // Highlight the violator's path
                            networkInfra.highlightViolatorPath(
                                RF_SCYTHE.sampleViolatorData.path,
                                RF_SCYTHE.sampleViolatorData
                            );
                            
                            // Add the violation to the cross-network violations list
                            addCrossNetworkViolation(RF_SCYTHE.sampleViolatorData);
                            
                            addConsoleMessage('ALERT: FCC violator tracked across multiple network infrastructures', 'alert');
                        }, 2000);
                    });
                }
                
                // LOS Analysis toggle and controls
                const toggleLOSAnalysis = document.getElementById('toggleLOSAnalysis');
                const losFilters = document.getElementById('losFilters');
                const losFovSlider = document.getElementById('losFovSlider');
                const losFovValue = document.getElementById('losFovValue');
                const losRangeSlider = document.getElementById('losRangeSlider');
                const losRangeValue = document.getElementById('losRangeValue');
                const losAddTowerViewshed = document.getElementById('losAddTowerViewshed');
                const losClearAll = document.getElementById('losClearAll');
                
                if (toggleLOSAnalysis && losFilters) {
                    toggleLOSAnalysis.addEventListener('change', function() {
                        losFilters.style.display = this.checked ? 'block' : 'none';
                        
                        if (this.checked && window.viewshedManager) {
                            // Auto-create viewsheds for visible recon entities
                            const entities = window.reconViz?.entities;
                            const list = Array.isArray(entities) ? entities
                                         : entities?.values ? entities.values
                                         : [];
                            list.forEach(entity => {
                                if (entity && entity.entity_id) {
                                    window.viewshedManager.createEntityViewshed(entity);
                                }
                            });
                            updateLOSCount();
                            addConsoleMessage('LOS Analysis enabled - viewsheds created for recon entities', 'response');
                        } else if (window.viewshedManager) {
                            window.viewshedManager.clearAllViewsheds();
                            updateLOSCount();
                            addConsoleMessage('LOS Analysis disabled - all viewsheds cleared', 'response');
                        }
                    });
                }
                
                if (losFovSlider && losFovValue) {
                    losFovSlider.addEventListener('input', function() {
                        losFovValue.textContent = this.value;
                        if (window.viewshedManager) {
                            window.viewshedManager.DEFAULT_CONFIG.horizontalFov = parseInt(this.value);
                        }
                    });
                }
                
                if (losRangeSlider && losRangeValue) {
                    losRangeSlider.addEventListener('input', function() {
                        losRangeValue.textContent = this.value;
                        if (window.viewshedManager) {
                            window.viewshedManager.DEFAULT_CONFIG.distance = parseInt(this.value) * 1000;
                        }
                    });
                }
                
                if (losAddTowerViewshed) {
                    losAddTowerViewshed.addEventListener('click', function() {
                        if (!window.viewshedManager) return;
                        
                        // Create viewsheds for cell towers
                        if (networkInfra && networkInfra.cellTowers) {
                            networkInfra.cellTowers.forEach((tower, index) => {
                                window.viewshedManager.createTowerViewshed({
                                    name: `Tower_${index}`,
                                    position: tower.position,
                                    height: tower.height || 50,
                                    range: tower.range || 15000
                                });
                            });
                            updateLOSCount();
                            addConsoleMessage(`LOS viewsheds created for ${networkInfra.cellTowers.length} cell towers`, 'response');
                        } else {
                            // Create sample tower viewsheds
                            const sampleTowers = [
                                { name: 'Tower_A', position: [-122.4194, 37.7749], height: 50, range: 15000 },
                                { name: 'Tower_B', position: [-118.2437, 34.0522], height: 75, range: 20000 },
                                { name: 'Tower_C', position: [-73.9857, 40.7484], height: 100, range: 25000 }
                            ];
                            sampleTowers.forEach(tower => {
                                window.viewshedManager.createTowerViewshed(tower);
                            });
                            updateLOSCount();
                            addConsoleMessage('LOS viewsheds created for 3 sample cell towers', 'response');
                        }
                    });
                }
                
                if (losClearAll) {
                    losClearAll.addEventListener('click', function() {
                        if (window.viewshedManager) {
                            window.viewshedManager.clearAllViewsheds();
                            updateLOSCount();
                            addConsoleMessage('All LOS viewsheds cleared', 'response');
                        }
                    });
                }
                
                // Function to update LOS viewshed count
                function updateLOSCount() {
                    const countEl = document.getElementById('los-viewshed-count');
                    if (countEl && window.viewshedManager) {
                        const count = Object.keys(window.viewshedManager.viewsheds).length;
                        countEl.textContent = count;
                    }
                }
                
                // Initialize network capture visualizer
                let networkCaptureViz = null;
                try {
                    if (typeof RF_SCYTHE.createNetworkCaptureVisualizer === 'function') {
                        networkCaptureViz = RF_SCYTHE.createNetworkCaptureVisualizer(viewer, {
                            captureLiveView: true
                        });
                        window.networkCaptureViz = networkCaptureViz;
                        console.log('Network capture visualizer initialized successfully');
                    } else {
                        console.log('createNetworkCaptureVisualizer not available, using fallback');
                        networkCaptureViz = {
                            viewer: viewer,
                            active: false,
                            captures: [],
                            initialize: function() { console.log('Network capture fallback initialized'); },
                            addCapture: function() { return null; },
                            clear: function() { /* no-op */ },
                            visualizeNetworkTraffic: function(data) { 
                                console.log('Network traffic visualization (fallback):', data);
                                addConsoleMessage('Network traffic capture active (visualization pending)', 'response');
                            }
                        };
                        window.networkCaptureViz = networkCaptureViz;
                    }
                } catch (error) {
                    console.log('Network capture visualizer fallback due to error:', error);
                    networkCaptureViz = {
                        viewer: viewer,
                        active: false,
                        captures: [],
                        initialize: function() { console.log('Network capture fallback initialized'); },
                        addCapture: function() { return null; },
                        clear: function() { /* no-op */ },
                        visualizeNetworkTraffic: function(data) { 
                            console.log('Network traffic visualization (fallback):', data);
                            addConsoleMessage('Network traffic capture active (visualization pending)', 'response');
                        }
                    };
                    window.networkCaptureViz = networkCaptureViz;
                }
                
                // Capture network traffic button
                document.getElementById('captureNetworkBtn').addEventListener('click', function() {
                    // Ensure we have the visualizer
                    if (!networkCaptureViz) {
                        try {
                            networkCaptureViz = RF_SCYTHE.createNetworkCaptureVisualizer(viewer, {
                                captureLiveView: true
                            });
                            window.networkCaptureViz = networkCaptureViz;
                        } catch (error) {
                            console.error('Error initializing network capture visualizer:', error);
                            showNotification('Error', 'Failed to initialize network capture visualizer', 'error');
                            return;
                        }
                    }
                    
                    // Show notification
                    showNotification('Network Traffic Capture', 'Starting capture of cross-infrastructure network traffic...', 'info');
                    addConsoleMessage('Initiating network traffic capture and analysis...', 'command');
                    
                    // Start with visualization of live data
                    networkCaptureViz.visualizeNetworkTraffic({});
                    
                    // Show spinner in the network details panel
                    const detailsPanel = document.getElementById('network-infra-details');
                    if (detailsPanel) {
                        detailsPanel.innerHTML = `
                            <div class="status-section">
                                <h3 class="status-title">Network Traffic Capture</h3>
                                <div style="display: flex; justify-content: center; margin: 20px 0;">
                                    <div class="loading-spinner"></div>
                                </div>
                                <p style="text-align: center; font-size: 12px;">Analyzing network traffic across infrastructures...</p>
                                <p style="text-align: center; font-size: 12px;">Gemini API processing data...</p>
                            </div>
                        `;
                    }
                    
                    // After a delay, get detailed analysis from Gemini API
                    setTimeout(() => {
                        // Ensure generateNetworkCaptureReport exists
                        if (typeof RF_SCYTHE.generateNetworkCaptureReport !== 'function') {
                            RF_SCYTHE.generateNetworkCaptureReport = function(options) {
                                return Promise.resolve({
                                    timestamp: options.timestamp || new Date().toISOString(),
                                    summary: 'Network traffic analysis complete. 15 active connections detected across infrastructure.',
                                    geminiConfidence: 87,
                                    total_packets: Math.floor(Math.random() * 10000) + 1000,
                                    violations: [
                                        { type: 'Unusual Traffic Pattern', severity: 'low', source: '10.0.0.75' }
                                    ],
                                    rf_correlation: {
                                        signals_detected: 8,
                                        frequency_range: '2.4GHz - 5.8GHz',
                                        interference_level: 'Low'
                                    },
                                    violationAnalysis: {
                                        primaryViolation: {
                                            type: 'Unlicensed RF Emission',
                                            frequency: '2.45 GHz',
                                            modulation: 'FHSS',
                                            threatAssessment: 'Medium',
                                            source: '10.0.0.75',
                                            path: ['192.168.1.1', '10.0.0.75', 'cell_tower_1', 'sat_starlink_12']
                                        },
                                        detectedViolations: 1
                                    },
                                    infrastructureAnalysis: {
                                        underseaCables: { detected: true, abnormalTraffic: [{ pattern: 'Unusual latency spikes' }] },
                                        satellites: { detected: true, abnormalTraffic: [{ pattern: 'Irregular signal bursts' }] },
                                        cellTowers: { detected: false, abnormalTraffic: [] }
                                    },
                                    recommendations: [
                                        'Monitor frequency band 2.4-2.5 GHz for unauthorized transmissions',
                                        'Consider deploying additional RF sensors in affected area',
                                        'Review FCC compliance for detected emissions'
                                    ]
                                });
                            };
                        }
                        
                        // Get a simulated network capture report
                        RF_SCYTHE.generateNetworkCaptureReport({
                            timestamp: new Date().toISOString()
                        }).then(report => {
                            // Update the visualizer with real data
                            networkCaptureViz.visualizeNetworkTraffic(report);
                            
                            // Safely access nested properties with defaults
                            const violationAnalysis = report.violationAnalysis || {};
                            const primaryViolation = violationAnalysis.primaryViolation || {
                                type: 'No violations detected',
                                frequency: 'N/A',
                                modulation: 'N/A',
                                threatAssessment: 'Low',
                                source: 'Unknown',
                                path: []
                            };
                            const infrastructureAnalysis = report.infrastructureAnalysis || {};
                            const recommendations = report.recommendations || ['Continue monitoring network traffic'];
                            
                            // Show the report in the network details panel
                            if (detailsPanel) {
                                detailsPanel.innerHTML = `
                                    <div class="status-section">
                                        <h3 class="status-title">Network Traffic Analysis</h3>
                                        <div class="status-indicator status-active">
                                            <div class="status-dot"></div>
                                            <span>GEMINI ANALYSIS COMPLETE: ${report.geminiConfidence || 0}% CONFIDENCE</span>
                                        </div>
                                    </div>
                                    
                                    <div style="margin-top: 15px; padding: 10px; background-color: rgba(42, 157, 58, 0.1); border-radius: 5px; border-left: 3px solid #2a9d3a;">
                                        <h3 style="font-size: 14px; margin-top: 0; color: #2a9d3a;">Traffic Analysis Summary</h3>
                                        <p style="font-size: 12px; margin: 5px 0;">${report.summary || 'Analysis pending...'}</p>
                                    </div>
                                    
                                    <div style="margin-top: 15px;">
                                        <h4 style="font-size: 14px; margin-bottom: 5px;">Detected Violations</h4>
                                        <div class="feature-value">
                                            <span class="feature-name">Primary Violation:</span>
                                            <span>${primaryViolation.type}</span>
                                        </div>
                                        <div class="feature-value">
                                            <span class="feature-name">Frequency:</span>
                                            <span>${primaryViolation.frequency}</span>
                                        </div>
                                        <div class="feature-value">
                                            <span class="feature-name">Modulation:</span>
                                            <span>${primaryViolation.modulation}</span>
                                        </div>
                                        <div class="feature-value">
                                            <span class="feature-name">Threat Level:</span>
                                            <span style="color: #c93840;">${primaryViolation.threatAssessment}</span>
                                        </div>
                                    </div>
                                    
                                    <div style="margin-top: 15px;">
                                        <h4 style="font-size: 14px; margin-bottom: 5px;">Infrastructure Used</h4>
                                        <ul style="font-size: 12px; margin: 5px 0; padding-left: 20px;">
                                            ${Object.keys(infrastructureAnalysis).length > 0 
                                                ? Object.keys(infrastructureAnalysis)
                                                    .filter(key => infrastructureAnalysis[key] && infrastructureAnalysis[key].detected)
                                                    .map(key => `<li>${key.charAt(0).toUpperCase() + key.slice(1)}: ${(infrastructureAnalysis[key].abnormalTraffic && infrastructureAnalysis[key].abnormalTraffic[0]?.pattern) || 'Normal traffic'}</li>`)
                                                    .join('') || '<li>No infrastructure detected</li>'
                                                : '<li>Infrastructure analysis pending</li>'}
                                        </ul>
                                    </div>
                                    
                                    <div style="margin-top: 15px;">
                                        <h4 style="font-size: 14px; margin-bottom: 5px;">Recommendations</h4>
                                        <ul style="font-size: 12px; margin: 5px 0; padding-left: 20px;">
                                            ${recommendations.map(rec => `<li>${rec}</li>`).join('')}
                                        </ul>
                                    </div>
                                    
                                    <div class="list-item-actions" style="margin-top: 15px;">
                                        <button class="action-button">Full Report</button>
                                        <button id="stopCaptureBtn" class="action-button danger">Stop Capture</button>
                                        <button class="action-button">Dispatch Drone</button>
                                    </div>
                                `;
                                
                                // Add event listener for stop capture button
                                const stopCaptureBtn = document.getElementById('stopCaptureBtn');
                                if (stopCaptureBtn) {
                                    stopCaptureBtn.addEventListener('click', function() {
                                        if (networkCaptureViz) {
                                            networkCaptureViz.stopVisualization();
                                            showNotification('Capture Stopped', 'Network traffic capture has been stopped', 'info');
                                        }
                                    });
                                }
                            }
                            
                            // Add to the violations list (only if we have a valid primary violation)
                            if (primaryViolation.type !== 'No violations detected') {
                                addCrossNetworkViolation(primaryViolation);
                            }
                            
                            // Show notification
                            showNotification('Analysis Complete', 'Gemini API has completed analysis of network traffic', 'info');
                            const detectedCount = violationAnalysis.detectedViolations || 0;
                            const infraCount = Object.keys(infrastructureAnalysis).filter(key => infrastructureAnalysis[key] && infrastructureAnalysis[key].detected).length;
                            addConsoleMessage(`Network traffic analysis complete. Detected ${detectedCount} violations across ${infraCount} infrastructure types.`, 'response');
                        }).catch(err => {
                            console.error('Error generating network capture report:', err);
                            showNotification('Error', 'Failed to analyze network traffic', 'error');
                            
                            if (detailsPanel) {
                                detailsPanel.innerHTML = `
                                    <div class="status-section">
                                        <h3 class="status-title">Network Traffic Analysis</h3>
                                        <div class="status-indicator status-inactive">
                                            <div class="status-dot"></div>
                                            <span>ANALYSIS FAILED</span>
                                        </div>
                                        <p style="text-align: center; font-size: 12px; color: #c93840;">Error analyzing network traffic: ${err.message}</p>
                                    </div>
                                    <div class="list-item-actions" style="margin-top: 15px;">
                                        <button id="retryAnalysisBtn" class="action-button">Retry Analysis</button>
                                        <button id="stopCaptureBtn" class="action-button danger">Stop Capture</button>
                                    </div>
                                `;
                            }
                        });
                    }, 3000);
                });
            } catch (error) {
                console.error('Error initializing network infrastructure visualization:', error);
            }
            
            // Function to update network elements count
            function updateNetworkElementsCount() {
                try {
                    const networkInfra = window.networkInfra;
                    if (!networkInfra || !networkInfra.entities) {
                        console.warn('Network infrastructure not initialized');
                        return;
                    }
                    
                    const entities = networkInfra.entities;
                    // Ensure all entity arrays exist with safe defaults
                    const cables = entities.cables || entities.underseaCables || [];
                    const satellites = entities.satellites || [];
                    const towers = entities.towers || entities.cellTowers || [];
                    const fiberBackbones = entities.fiberBackbones || [];
                    
                    const totalCount = cables.length + satellites.length + towers.length + fiberBackbones.length;
                    
                    const countElement = document.getElementById('network-elements-count');
                    if (countElement) {
                        countElement.textContent = totalCount;
                    }
                    
                    console.log('Network element counts:', {
                        cables: cables.length,
                        satellites: satellites.length,
                        towers: towers.length,
                        fiberBackbones: fiberBackbones.length,
                        total: totalCount
                    });
                } catch (error) {
                    console.error('Error updating network elements count:', error);
                }
            }
            
            // Setup altitude-based visibility listener for network infrastructure
            function setupNetworkInfrastructureAltitudeListener(networkInfra) {
                if (!networkInfra) return;
                
                // Store the listener reference for cleanup
                const altitudeHandler = function(e) {
                    const { altitude, level } = e.detail;
                    
                    if (!window.HierarchicalRenderManager) return;
                    
                    const showLabels = HierarchicalRenderManager.shouldShowDetail('labels');
                    const showRings = HierarchicalRenderManager.shouldShowDetail('rings');
                    const showTrails = HierarchicalRenderManager.shouldShowDetail('trails');
                    
                    // Get entities from network infrastructure
                    const entities = networkInfra.entities || {};
                    const satellites = entities.satellites || [];
                    const towers = entities.towers || entities.cellTowers || [];
                    const cables = entities.cables || entities.underseaCables || [];
                    const fiberBackbones = entities.fiberBackbones || [];
                    
                    // Update satellite visibility based on altitude
                    satellites.forEach(sat => {
                        if (sat && sat.label) {
                            sat.label.show = showLabels;
                        }
                        // Show/hide satellite orbit rings at lower altitudes
                        if (sat && sat.ellipse) {
                            sat.ellipse.show = showRings;
                        }
                    });
                    
                    // Update cell tower labels and range circles
                    towers.forEach(tower => {
                        if (tower && tower.label) {
                            tower.label.show = showLabels;
                        }
                        // Show coverage rings only at detailed level
                        if (tower && tower.ellipse) {
                            tower.ellipse.show = showRings;
                        }
                    });
                    
                    // Undersea cables - adjust width based on altitude
                    cables.forEach(cable => {
                        if (cable && cable.polyline) {
                            // Thicker lines at global view, thinner at detailed
                            const width = level === 'GLOBAL' ? 4 : level === 'REGIONAL' ? 3 : 2;
                            cable.polyline.width = width;
                        }
                    });
                    
                    // Fiber backbones - similar treatment
                    fiberBackbones.forEach(fiber => {
                        if (fiber && fiber.polyline) {
                            const width = level === 'GLOBAL' ? 3 : level === 'REGIONAL' ? 2 : 1;
                            fiber.polyline.width = width;
                        }
                        if (fiber && fiber.label) {
                            fiber.label.show = showLabels;
                        }
                    });
                    
                    // Log visibility changes for metrics
                    if (window.logMetric && Math.random() < 0.1) { // Sample 10% to avoid spam
                        window.logMetric('render', 'network_infra_altitude_update', altitude);
                        window.logMetric('render', 'network_infra_detail_level', 
                            level === 'GLOBAL' ? 1 : level === 'REGIONAL' ? 2 : level === 'LOCAL' ? 3 : 4);
                    }
                };
                
                document.addEventListener('altitudeChanged', altitudeHandler);
                
                // Store handler reference for cleanup
                networkInfra._altitudeHandler = altitudeHandler;
                
                console.log('[NetworkInfra] Altitude-based visibility listener registered');
            }
            
            // Function to add a cross-network violation to the list
            function addCrossNetworkViolation(violatorData) {
                try {
                    const violationsList = document.getElementById('cross-network-violations');
                    if (!violationsList) return;
                    
                    // Create new violation item
                    const violationItem = document.createElement('li');
                    violationItem.className = 'signal-card violation';
                    
                    // Format the path for display - with validation
                    let pathDisplay = 'Unknown';
                    if (violatorData.path && Array.isArray(violatorData.path) && violatorData.path.length > 0) {
                        pathDisplay = violatorData.path.map(p => {
                            // Handle different path data formats
                            if (!p) return '?';
                            if (typeof p === 'string') return p.split(' ')[0] || p;
                            if (p.id && typeof p.id === 'string') {
                                const parts = p.id.split(' ');
                                return parts[0] || p.id;
                            }
                            if (p.name) return p.name;
                            if (p.type) return p.type;
                            return '?';
                        }).join(' → ');
                    }
                    
                    violationItem.innerHTML = `
                        <div class="list-item-header">
                            <span class="list-item-title">${violatorData.frequency} MHz</span>
                            <span style="background-color: #c93840; padding: 2px 6px; border-radius: 3px; font-size: 11px;">CROSS-NETWORK</span>
                        </div>
                        <div class="feature-value">
                            <span class="feature-name">Violation Type:</span>
                            <span>${violatorData.violationType}</span>
                        </div>
                        <div class="feature-value">
                            <span class="feature-name">Network Path:</span>
                            <span>${pathDisplay}</span>
                        </div>
                        <div class="feature-value">
                            <span class="feature-name">AI Classification:</span>
                            <span>${violatorData.signalType}</span>
                        </div>
                        <div class="confidence-bar">
                            <div class="confidence-level" style="width: ${violatorData.confidence}%; background-color: #c93840;"></div>
                        </div>
                        <div class="list-item-actions">
                            <button class="action-button" onclick="window.networkInfra.highlightViolatorPath(RF_SCYTHE.sampleViolatorData.path, RF_SCYTHE.sampleViolatorData)">View Path</button>
                            <button class="action-button danger">Intercept</button>
                            <button class="action-button">Analyze</button>
                        </div>
                    `;
                    
                    // Add to list
                    violationsList.appendChild(violationItem);
                } catch (error) {
                    console.error('Error adding cross-network violation:', error);
                }
            }
            
            // Setup event listeners for ionosphere controls
            document.getElementById('toggleIonosphere').addEventListener('change', function() {
                if (this.checked) {
                    try {
                        // Try to use our safe implementation first if it's available
                        if (window.safeIonosphere) {
                            console.log("Using safe ionosphere visualization");
                            // If we already have safeIonosphere instance, just create layers
                            if (typeof window.safeIonosphere.createIonosphereLayers === 'function') {
                                window.safeIonosphere.createIonosphereLayers();
                                console.log("Created ionosphere layers using safe implementation");
                                return;
                            }
                        }
                        
                        // Try the safe implementation if available
                        if (typeof RF_SCYTHE !== 'undefined' && typeof RF_SCYTHE.initSafeIonosphereVisualization === 'function') {
                            console.log("Initializing safe ionosphere visualization");
                            window.safeIonosphere = RF_SCYTHE.initSafeIonosphereVisualization(viewer, {
                                useSafeEllipses: true,
                                enablePoles: false,
                                avoidProblematicLatitudes: true,
                                debug: false,
                                labelLayers: true
                            });
                            
                            if (window.safeIonosphere) {
                                console.log("Safe ionosphere visualization initialized successfully");
                                return;
                            }
                        }
                        
                        // Fall back to the original implementation
                        console.log("Falling back to original ionosphere implementation");
                        if (ionosphereData) {
                            addIonosphericLayers(viewer, ionosphereData);
                        } else {
                            fetchIonosphereData();
                        }
                    } catch (error) {
                        console.error("Error showing ionosphere:", error);
                        // Final fallback - just fetch data and try standard visualization
                        fetchIonosphereData();
                    }
                } else {
                    // Remove ionosphere layers
                    if (window.safeIonosphere && typeof window.safeIonosphere.clearIonosphere === 'function') {
                        // Use the safe implementation's cleanup method
                        window.safeIonosphere.clearIonosphere();
                        console.log("Cleared ionosphere using safe implementation");
                    } else {
                        // Traditional removal
                        const ionoLayers = viewer.entities.values.filter(entity => 
                            entity.name && entity.name.includes('Ionosphere'));
                        ionoLayers.forEach(layer => viewer.entities.remove(layer));
                        console.log("Cleared ionosphere using traditional method");
                    }
                }
            });
            
            // Setup event listeners for POI controls
            const togglePOIs = document.getElementById('togglePOIs');
            if (togglePOIs) {
                togglePOIs.addEventListener('change', function() {
                    if (window.POIVisualization) {
                        POIVisualization.setVisible(this.checked);
                        addConsoleMessage(`POIs ${this.checked ? 'shown' : 'hidden'}`, 'info');
                    }
                });
            }
            
            const togglePOILabels = document.getElementById('togglePOILabels');
            if (togglePOILabels) {
                togglePOILabels.addEventListener('change', function() {
                    if (window.POIVisualization) {
                        POIVisualization.toggleLabels(this.checked);
                        addConsoleMessage(`POI labels ${this.checked ? 'shown' : 'hidden'}`, 'info');
                    }
                });
            }
            
            const flyToAllPOIsBtn = document.getElementById('flyToAllPOIsBtn');
            if (flyToAllPOIsBtn) {
                flyToAllPOIsBtn.addEventListener('click', function() {
                    if (window.POIVisualization) {
                        POIVisualization.flyToAllPOIs();
                    }
                });
            }
            
            const reloadPOIsBtn = document.getElementById('reloadPOIsBtn');
            if (reloadPOIsBtn) {
                reloadPOIsBtn.addEventListener('click', async function() {
                    if (window.POIVisualization) {
                        addConsoleMessage('Reloading Points of Interest...', 'info');
                        await POIVisualization.loadPOIs();
                        updatePOIPanelStats();
                        updatePOIList();
                    }
                });
            }
            
            // Add new POI button
            const addPoiBtn = document.getElementById('add-poi-btn');
            if (addPoiBtn) {
                addPoiBtn.addEventListener('click', async function() {
                    const name = document.getElementById('new-poi-name').value.trim();
                    const lat = parseFloat(document.getElementById('new-poi-lat').value);
                    const lon = parseFloat(document.getElementById('new-poi-lon').value);
                    const category = document.getElementById('new-poi-category').value;
                    const description = document.getElementById('new-poi-description').value.trim();
                    
                    if (!name) {
                        showNotification('Error', 'Please enter a POI name', 'error');
                        return;
                    }
                    if (isNaN(lat) || isNaN(lon)) {
                        showNotification('Error', 'Please enter valid coordinates', 'error');
                        return;
                    }
                    if (lat < -90 || lat > 90 || lon < -180 || lon > 180) {
                        showNotification('Error', 'Coordinates out of range', 'error');
                        return;
                    }
                    
                    if (window.POIVisualization) {
                        const poiId = await POIVisualization.addPOI(name, lat, lon, category, description);
                        if (poiId) {
                            showNotification('POI Added', `"${name}" added successfully`, 'success');
                            // Clear form
                            document.getElementById('new-poi-name').value = '';
                            document.getElementById('new-poi-lat').value = '';
                            document.getElementById('new-poi-lon').value = '';
                            document.getElementById('new-poi-description').value = '';
                            // Update panel
                            updatePOIPanelStats();
                            updatePOIList();
                        }
                    }
                });
            }
            
            // Pick location from map button
            const pickLocationBtn = document.getElementById('pick-location-btn');
            if (pickLocationBtn) {
                pickLocationBtn.addEventListener('click', function() {
                    addConsoleMessage('Click on the map to pick a location for the new POI...', 'info');
                    showNotification('Pick Location', 'Click anywhere on the map to set coordinates', 'info');
                    
                    // Enable pick mode
                    window.poiPickMode = true;
                    pickLocationBtn.textContent = '🎯 Click Map to Select...';
                    pickLocationBtn.style.background = 'linear-gradient(135deg, #ff6b6b, #ffd93d)';
                    
                    // One-time click handler on the viewer
                    const handler = new Cesium.ScreenSpaceEventHandler(viewer.scene.canvas);
                    handler.setInputAction(function(click) {
                        if (!window.poiPickMode) return;
                        
                        const cartesian = viewer.camera.pickEllipsoid(click.position, viewer.scene.globe.ellipsoid);
                        if (cartesian) {
                            const cartographic = Cesium.Cartographic.fromCartesian(cartesian);
                            const lat = Cesium.Math.toDegrees(cartographic.latitude);
                            const lon = Cesium.Math.toDegrees(cartographic.longitude);
                            
                            // Fill in the form
                            document.getElementById('new-poi-lat').value = lat.toFixed(6);
                            document.getElementById('new-poi-lon').value = lon.toFixed(6);
                            
                            addConsoleMessage(`Location picked: ${lat.toFixed(6)}, ${lon.toFixed(6)}`, 'response');
                            showNotification('Location Set', `Coordinates: ${lat.toFixed(4)}, ${lon.toFixed(4)}`, 'success');
                            
                            // Disable pick mode
                            window.poiPickMode = false;
                            pickLocationBtn.textContent = '🎯 Pick Location from Map';
                            pickLocationBtn.style.background = '';
                            handler.destroy();
                        }
                    }, Cesium.ScreenSpaceEventType.LEFT_CLICK);
                    
                    // Cancel on right-click
                    handler.setInputAction(function() {
                        window.poiPickMode = false;
                        pickLocationBtn.textContent = '🎯 Pick Location from Map';
                        pickLocationBtn.style.background = '';
                        handler.destroy();
                        addConsoleMessage('Location pick cancelled', 'info');
                    }, Cesium.ScreenSpaceEventType.RIGHT_CLICK);
                });
            }
            
            // Import KMZ button
            const importKmzBtn = document.getElementById('import-kmz-btn');
            if (importKmzBtn) {
                importKmzBtn.addEventListener('click', async function() {
                    const filePath = document.getElementById('import-kmz-path').value.trim();
                    const category = document.getElementById('import-kmz-category').value;
                    
                    if (!filePath) {
                        showNotification('Error', 'Please enter a file path', 'error');
                        return;
                    }
                    
                    try {
                        addConsoleMessage(`Importing POIs from ${filePath}...`, 'info');
                        const response = await fetch('/api/poi/import', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ file_path: filePath, category: category })
                        });
                        
                        const data = await response.json();
                        if (data.status === 'ok') {
                            showNotification('Import Complete', `Imported ${data.count} POIs`, 'success');
                            addConsoleMessage(`Successfully imported ${data.count} POIs from ${filePath}`, 'response');
                            // Reload POIs
                            if (window.POIVisualization) {
                                await POIVisualization.loadPOIs();
                                updatePOIPanelStats();
                                updatePOIList();
                            }
                            document.getElementById('import-kmz-path').value = '';
                        } else {
                            showNotification('Import Failed', data.message, 'error');
                            addConsoleMessage('Import failed: ' + data.message, 'alert');
                        }
                    } catch (error) {
                        showNotification('Error', 'Failed to import file', 'error');
                        addConsoleMessage('Import error: ' + error.message, 'alert');
                    }
                });
            }
            
            // Helper function to update POI panel statistics
            function updatePOIPanelStats() {
                if (window.POIVisualization) {
                    const countEl = document.getElementById('poi-count');
                    const catCountEl = document.getElementById('poi-category-count');
                    const visibleCountEl = document.getElementById('poi-visible-count');
                    
                    if (countEl) countEl.textContent = POIVisualization.pois.length;
                    if (catCountEl) catCountEl.textContent = Object.keys(POIVisualization.categories).length;
                    if (visibleCountEl) visibleCountEl.textContent = POIVisualization.visible ? POIVisualization.pois.length : 0;
                    
                    // Update category filters
                    updatePOICategoryFilters();
                }
            }
            
            // Helper function to update POI list in panel
            function updatePOIList() {
                const listEl = document.getElementById('poi-list');
                if (!listEl || !window.POIVisualization) return;
                
                const pois = POIVisualization.pois;
                
                if (pois.length === 0) {
                    listEl.innerHTML = `<div style="color: #888; text-align: center; padding: 15px; font-size: 11px;">
                        No points of interest loaded
                    </div>`;
                    return;
                }
                
                // Category colors
                const categoryColors = {
                    'intelligence': '#ff4444',
                    'military': '#8b0000',
                    'infrastructure': '#ff8c00',
                    'commercial': '#4169e1',
                    'government': '#800080',
                    'transportation': '#00bfff',
                    'imported': '#ffd700',
                    'manual': '#ffffff',
                    'general': '#888888'
                };
                
                listEl.innerHTML = pois.map(poi => {
                    const color = categoryColors[poi.category] || '#888888';
                    return `
                        <div class="poi-list-item" style="padding: 8px; margin-bottom: 5px; background: rgba(255,255,255,0.05); border-radius: 4px; border-left: 3px solid ${color};">
                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                <div>
                                    <div style="font-weight: bold; font-size: 12px;">${poi.name}</div>
                                    <div style="font-size: 10px; color: #888;">
                                        ${poi.latitude.toFixed(4)}, ${poi.longitude.toFixed(4)}
                                    </div>
                                    <div style="font-size: 9px; color: ${color}; text-transform: uppercase;">${poi.category}</div>
                                </div>
                                <div style="display: flex; gap: 5px;">
                                    <button class="action-button" style="padding: 3px 8px; font-size: 10px;" onclick="flyToPOI(${poi.id})">📍</button>
                                    <button class="action-button" style="padding: 3px 8px; font-size: 10px; background: #ff4444;" onclick="deletePOI(${poi.id})">🗑️</button>
                                </div>
                            </div>
                        </div>
                    `;
                }).join('');
            }
            
            // Helper function to update category filters
            function updatePOICategoryFilters() {
                const filtersEl = document.getElementById('poi-category-filters');
                if (!filtersEl || !window.POIVisualization) return;
                
                const categories = POIVisualization.categories;
                
                filtersEl.innerHTML = Object.entries(categories).map(([cat, count]) => {
                    const isVisible = POIVisualization.categoryVisibility[cat] !== false;
                    return `
                        <label style="display: flex; align-items: center; gap: 5px; padding: 5px 10px; background: ${isVisible ? 'rgba(74,158,255,0.2)' : 'rgba(255,255,255,0.05)'}; border-radius: 15px; cursor: pointer; font-size: 11px;">
                            <input type="checkbox" ${isVisible ? 'checked' : ''} onchange="togglePOICategory('${cat}', this.checked)">
                            <span>${cat} (${count})</span>
                        </label>
                    `;
                }).join('');
            }
            
            // Global functions for POI actions
            window.flyToPOI = function(poiId) {
                if (window.POIVisualization) {
                    POIVisualization.flyToPOI(poiId);
                }
            };
            
            window.deletePOI = async function(poiId) {
                if (!confirm('Are you sure you want to delete this POI?')) return;
                
                if (window.POIVisualization) {
                    const success = await POIVisualization.deletePOI(poiId);
                    if (success) {
                        showNotification('POI Deleted', 'Point of interest removed', 'success');
                        updatePOIPanelStats();
                        updatePOIList();
                    }
                }
            };
            
            window.togglePOICategory = function(category, visible) {
                if (window.POIVisualization) {
                    POIVisualization.setCategoryVisible(category, visible);
                    addConsoleMessage(`Category "${category}" ${visible ? 'shown' : 'hidden'}`, 'info');
                }
            };
            
            // Make update functions globally available
            window.updatePOIPanelStats = updatePOIPanelStats;
            window.updatePOIList = updatePOIList;
            
            // Initial update when POI panel is shown
            setTimeout(function() {
                updatePOIPanelStats();
                updatePOIList();
            }, 2000);
            
            // Setup event listeners for missile controls
            const deployMissileBtn = document.getElementById('deployMissileBtn');
            if (deployMissileBtn) {
                deployMissileBtn.addEventListener('click', function() {
                    showNotification('Missile Deployed', 'Hypersonic missile deployed and ready for launch', 'info');
                    addConsoleMessage('Missile deployed successfully. Standing by for targeting...', 'response');
                
                // Update missile count
                const missileCount = document.getElementById('missile-count');
                const currentCount = parseInt(missileCount.textContent) + 1;
                missileCount.textContent = currentCount;
                
                // Add to missiles list
                const missilesList = document.getElementById('missiles-list');
                const placeholder = missilesList.querySelector('.list-placeholder');
                if (placeholder) {
                    placeholder.style.display = 'none';
                }
                
                const missileItem = document.createElement('div');
                missileItem.className = 'signal-card';
                missileItem.innerHTML = `
                    <div class="list-item-header">
                        <span class="list-item-title">Hypersonic Missile ${currentCount}</span>
                        <span class="status-dot" style="background-color: var(--warning-orange)"></span>
                    </div>
                    <div class="feature-value">
                        <span class="feature-name">Status:</span>
                        <span>Deployed - Ready to Launch</span>
                    </div>
                    <div class="feature-value">
                        <span class="feature-name">Type:</span>
                        <span>Hypersonic Air-to-Surface</span>
                    </div>
                    <div class="list-item-actions">
                        <button class="action-button" onclick="launchSpecificMissile(${currentCount})">Launch</button>
                        <button class="action-button">Configure</button>
                    </div>
                `;
                missilesList.appendChild(missileItem);
                });
            }
            
            const launchSingleBtn = document.getElementById('launchSingleBtn');
            if (launchSingleBtn) {
                launchSingleBtn.addEventListener('click', function() {
                const targetMode = document.getElementById('missileTarget').value;
                const platform = document.getElementById('missilePlatform').value;
                
                showNotification('Missile Launch', `Launching hypersonic missile from ${platform} platform`, 'warning');
                addConsoleMessage(`Initiating missile launch sequence - Target mode: ${targetMode}`, 'command');
                
                // Launch missile and deploy tracking drones
                setTimeout(() => {
                    launchHypersonicMissile();
                    deployTrackingDrones();
                    addConsoleMessage('Hypersonic missile launched. Tracking drones deployed.', 'response');
                }, 1000);
                });
            }
            
            const launchBarrageBtn = document.getElementById('launchBarrageBtn');
            if (launchBarrageBtn) {
                launchBarrageBtn.addEventListener('click', function() {
                const platform = document.getElementById('missilePlatform').value;
                
                showNotification('Missile Barrage', `Launching multiple missiles from ${platform} platforms`, 'error');
                addConsoleMessage('Initiating missile barrage - Multiple targets engaged', 'command');
                
                // Launch multiple missiles with slight delays
                for (let i = 0; i < 3; i++) {
                    setTimeout(() => {
                        launchHypersonicMissile();
                        if (i === 0) {
                            deployTrackingDrones();
                        }
                        addConsoleMessage(`Missile ${i + 1} launched`, 'response');
                    }, i * 500);
                }
                });
            }
            
            // Setup target generation controls
            const generateBtn = document.getElementById('generateTargetsBtn');
            if (generateBtn) {
                // Remove any existing event listeners
                generateBtn.replaceWith(generateBtn.cloneNode(true));
                const newGenerateBtn = document.getElementById('generateTargetsBtn');
                
                newGenerateBtn.addEventListener('click', function(e) {
                    e.preventDefault();
                    console.log('Generate Targets button clicked - starting target generation');
                    showNotification('Target Generation', 'Generating missile targets from RF violations...', 'info');
                    addConsoleMessage('Generating high-priority targets for missile engagement...', 'command');
                    
                    try {
                        generateMissileTargets();
                        console.log('Target generation completed successfully');
                    } catch (error) {
                        console.error('Error generating targets:', error);
                        showNotification('Error', 'Failed to generate targets: ' + error.message, 'error');
                    }
                    
                    setTimeout(() => {
                        if (window.activeMissileTargets && window.activeMissileTargets.length > 0) {
                            addConsoleMessage(`${window.activeMissileTargets.length} targets generated and added to engagement list`, 'response');
                        } else {
                            addConsoleMessage('Target generation completed - check missiles panel', 'response');
                        }
                    }, 500);
                });
                console.log('Generate targets button listener attached successfully');
            } else {
                console.error('Generate targets button not found!');
            }

	            // Clear targets button
	            const clearTargetsBtn = document.getElementById('clearTargetsBtn');
            if (clearTargetsBtn) {
                clearTargetsBtn.addEventListener('click', function() {
                    showNotification('Targets Cleared', 'All missile targets removed from system', 'warning');
                    addConsoleMessage('Clearing all missile targets from engagement list...', 'command');

                    // Remove all targets from Cesium
                    (window.activeMissileTargets || []).forEach(target => {
                        if (target && target.entity) {
                            viewer.entities.remove(target.entity);
                        }
                    });

                    // Clear array
                    window.activeMissileTargets = [];
                    updateMissileTargetsList();

                    addConsoleMessage('All missile targets cleared', 'response');
                });
            } else {
                console.warn('clearTargetsBtn not found; skipping listener');
            }

            const toggleSignalPathsEl = document.getElementById('toggleSignalPaths');
            if (toggleSignalPathsEl) {
                toggleSignalPathsEl.addEventListener('change', function() {
                    if (this.checked) {
                        if (signalPaths.length === 0) {
                            generateExampleSignalPaths();
                        } else {
                            signalPaths.forEach(path => { path.show = true; });
                        }
                    } else {
                        signalPaths.forEach(path => { path.show = false; });
                    }
                });
            } else {
                console.warn('toggleSignalPaths not found; skipping listener');
            }

            document.getElementById('updateIonosphereBtn').addEventListener('click', function() {
                try {
                    // Clear existing ionosphere
                    removeIonosphereLayers();
                    
                    // Try to fetch new data and use safe visualization if possible
                    if (window.safeIonosphere) {
                        // If we have the safe implementation, check if we need to reset it
                        if (typeof window.safeIonosphere.clearIonosphere === 'function') {
                            window.safeIonosphere.clearIonosphere();
                        }
                        
                        // Update the ionosphere for current time
                        if (typeof window.safeIonosphere.updateForTimeOfDay === 'function') {
                            window.safeIonosphere.updateForTimeOfDay(new Date());
                        }
                        
                        // Create new layers
                        if (typeof window.safeIonosphere.createIonosphereLayers === 'function') {
                            window.safeIonosphere.createIonosphereLayers();
                            addConsoleMessage("Ionosphere model updated with enhanced visualization", "response");
                            return;
                        }
                    }
                    
                    // Fall back to standard fetch if needed
                    fetchIonosphereData();
                } catch (error) {
                    console.error("Error updating ionosphere:", error);
                    fetchIonosphereData(); // Fall back to traditional method
                }
            });
            
            // Add event handlers for minimal globe mode
            document.getElementById('toggleMinimalGlobe').addEventListener('change', function() {
                if (this.checked) {
                    // Switch to minimal globe mode
                    switchToMinimalGlobeMode();
                } else {
                    // Try to reload the page
                    if (confirm("Switching back to full mode requires reloading the page. Continue?")) {
                        window.location.reload();
                    } else {
                        // Re-check the checkbox if user cancels
                        this.checked = true;
                    }
                }
            });
            
            document.getElementById('switchToMinimalBtn').addEventListener('click', function() {
                // Switch to minimal globe mode
                document.getElementById('toggleMinimalGlobe').checked = true;
                switchToMinimalGlobeMode();
                addConsoleMessage("Switched to minimal globe mode to avoid Rectangle.north errors", "response");
            });
            
            document.getElementById('reloadBtn').addEventListener('click', function() {
                if (confirm("Reload the visualization? Any unsaved data will be lost.")) {
                    window.location.reload();
                }
            });
            
            // Function to switch to minimal globe mode
            function switchToMinimalGlobeMode() {
                try {
                    console.log("Switching to minimal globe mode...");
                    addConsoleMessage("Switching to minimal globe mode...", "system");
                    
                    // Remove all entities that might cause Rectangle.north errors
                    viewer.entities.removeAll();
                    
                    // Remove all primitives
                    viewer.scene.primitives.removeAll();
                    
                    // Destroy and recreate viewer with minimal settings if possible
                    if (typeof RF_SCYTHE !== 'undefined' && typeof RF_SCYTHE.initializeMinimalViewer === 'function') {
                        // Get current camera position to restore later
                        const cameraPosition = viewer.camera.position.clone();
                        const cameraHeading = viewer.camera.heading;
                        const cameraPitch = viewer.camera.pitch;
                        const cameraRoll = viewer.camera.roll;
                        
                        // Destroy current viewer
                        viewer.destroy();
                        
                        // Create new minimal viewer
                        viewer = RF_SCYTHE.initializeMinimalViewer('cesiumContainer');
                        
                        // Restore camera position
                        viewer.camera.setView({
                            destination: cameraPosition,
                            orientation: {
                                heading: cameraHeading,
                                pitch: cameraPitch,
                                roll: cameraRoll
                            }
                        });
                        
                        // Add basic globe visualization
                        setTimeout(() => {
                            RF_SCYTHE.addBasicIonospherePrimitives(viewer);
                        }, 1000);
                        
                        addConsoleMessage("Switched to minimal globe mode successfully", "response");
                    } else {
                        // If the minimal viewer isn't available, just remove problematic elements
                        console.log("Minimal viewer not available, removing problematic elements");
                        
                        // Disable terrain which can cause issues
                        viewer.terrainProvider = new Cesium.EllipsoidTerrainProvider();
                        
                        // Disable features that might use Rectangle
                        if (viewer.scene.globe) {
                            viewer.scene.globe.depthTestAgainstTerrain = false;
                        }
                        
                        // Add simple sphere if available
                        if (typeof RF_SCYTHE !== 'undefined' && typeof RF_SCYTHE.addSimpleSphere === 'function') {
                            RF_SCYTHE.addSimpleSphere(viewer);
                        }
                        
                        addConsoleMessage("Applied minimal mode (limited functionality)", "response");
                    }
                    
                    console.log("Switched to minimal globe mode");
                } catch (error) {
                    console.error("Error switching to minimal globe mode:", error);
                    addConsoleMessage("Error switching to minimal mode: " + error.message, "error");
                }
            }

            // Create a sensor ping indicator (simple pulsing circle effect)
            function createSensorPingIndicator(options) {
                const { position, color = 'cyan', radius = 1, duration = 2 } = options;
                
                // Convert color string to Cesium Color
                let cesiumColor;
                try {
                    cesiumColor = Cesium.Color.fromCssColorString(color).withAlpha(0.6);
                } catch (e) {
                    cesiumColor = Cesium.Color.CYAN.withAlpha(0.6);
                }
                
                // Create a simple point entity as the ping indicator
                const startTime = Date.now();
                const durationMs = duration * 1000;
                
                // Create a billboard-based ping indicator
                const pingEntity = viewer.entities.add({
                    position: new Cesium.Cartesian3(position.x, position.y, position.z),
                    point: {
                        pixelSize: 10 * radius,
                        color: cesiumColor,
                        outlineColor: cesiumColor.withAlpha(1.0),
                        outlineWidth: 2,
                        scaleByDistance: new Cesium.NearFarScalar(1e3, 2.0, 1e7, 0.5)
                    }
                });
                
                // Return a simple object with update method
                return {
                    entity: pingEntity,
                    startTime: startTime,
                    duration: durationMs,
                    update: function() {
                        const elapsed = Date.now() - this.startTime;
                        if (elapsed > this.duration) {
                            // Remove entity after duration
                            if (this.entity) {
                                viewer.entities.remove(this.entity);
                                this.entity = null;
                            }
                            return;
                        }
                        
                        // Pulse effect - scale and alpha based on time
                        const progress = elapsed / this.duration;
                        const pulse = Math.sin(progress * Math.PI * 4) * 0.3 + 1.0;
                        const alpha = 1.0 - progress;
                        
                        if (this.entity && this.entity.point) {
                            this.entity.point.pixelSize = (10 * radius) * pulse;
                            this.entity.point.color = cesiumColor.withAlpha(alpha * 0.6);
                        }
                    }
                };
            }

            // Expose the sensor ping indicator function globally to avoid ReferenceError in other scopes
            window.createSensorPingIndicator = createSensorPingIndicator;

            // Function to add a sensor ping at a given location
            function addSensorPing(lat, lon, color = 'cyan', radius = 1, duration = 2) {
                try {
                    // Input validation
                    if (typeof lat !== 'number' || typeof lon !== 'number' || isNaN(lat) || isNaN(lon)) {
                        console.warn('Invalid coordinates for sensor ping', { lat, lon });
                        return;
                    }
                    
                    // Convert geographic coordinates to Cartesian3 safely
                    const cartesian = Cesium.Cartesian3.fromDegrees(lon, lat);
                    if (!cartesian) {
                        console.warn('Failed to convert coordinates to Cartesian3', { lat, lon });
                        return;
                    }
                    
                    // Create position object with x, y, z properties
                    const positionObj = {
                        x: cartesian.x,
                        y: cartesian.y,
                        z: cartesian.z
                    };
                    
                    // Log position data for debugging
                    console.log(`Creating sensor ping at lat: ${lat}, lon: ${lon}, position:`, positionObj);

                    try {
                        const pingIndicator = createSensorPingIndicator({
                            position: positionObj, 
                            color,
                            radius,
                            duration
                        });

                        // Add the ping to the Cesium scene
                        viewer.scene.primitives.add(pingIndicator);

                        // Update the ping in the render loop
                        viewer.scene.preRender.addEventListener(() => {
                            pingIndicator.update();
                        });
                    } catch (innerError) {
                        console.error('Error creating sensor ping indicator:', innerError);
                    }
                } catch (error) {
                    console.error('Error in addSensorPing:', error);
                }
            }

            // Example usage: Add a sensor ping at a specific location
            addSensorPing(37.7749, -122.4194, 'cyan', 1, 2); // San Francisco
            addSensorPing(40.7128, -74.0060, 'yellow', 1.5, 3); // New York
            
            // Add patrol boat with sensor suite
            initializePatrolBoat();
            
            // Initialize the spectrogram and signal classification components
            initializeSpectrogram();
            
            // Initialize the URH tab functionality
            try {
                console.log("Initializing URH integration...");
                initializeURHTabFunctionality();
                
                // Also initialize the URH functionality from the JS file if available
                if (typeof RF_SCYTHE !== 'undefined' && 
                    typeof RF_SCYTHE.URH !== 'undefined' && 
                    typeof RF_SCYTHE.URH.initialize === 'function') {
                    RF_SCYTHE.URH.initialize();
                    console.log("URH library initialization successful");
                } else {
                    console.warn("URH library not found, using basic functionality only");
                }
            } catch (urhError) {
                console.error("Error initializing URH functionality:", urhError);
            }
            
            } catch (error) {
                console.error('Error in main initialization:', error);
                showNotification('Initialization Error', 'There was an error initializing some components. Some features may not work properly.', 'error');
            }
        });
        
        // Boat patrol with sensor suite
        let patrolBoat = null;
        let patrolRoute = [];
        let currentPatrolPoint = 0;
        let patrolActive = false;
        let sensorSuiteActive = false;
        let sensorInterval = null;
        
        function initializePatrolBoat() {
            // Create a dedicated panel for boat controls in the sidebar
            const dronePanel = document.getElementById('drones-panel');
            const boatControlsDiv = document.createElement('div');
            boatControlsDiv.className = 'status-section';
            boatControlsDiv.innerHTML = `
                <div class="status-header">
                    <h3 class="status-title">Patrol Boat Operations</h3>
                </div>
                <div style="margin-top: 10px;">
                    <button id="loadBoatBtn" class="action-button">Load Patrol Boat</button>
                    <button id="startPatrolBtn" class="action-button" disabled>Start Patrol</button>
                    <button id="stopPatrolBtn" class="action-button" disabled>Stop Patrol</button>
                </div>
                <div style="margin-top: 10px;">
                    <div class="feature-value">
                        <span class="feature-name">Sensor Suite:</span>
                        <label class="switch">
                            <input type="checkbox" id="sensorSuiteToggle" disabled>
                            <span class="slider round"></span>
                        </label>
                    </div>
                    <div class="feature-value">
                        <span class="feature-name">Scan Interval:</span>
                        <select id="sensorInterval" disabled>
                            <option value="2">2 seconds</option>
                            <option value="5" selected>5 seconds</option>
                            <option value="10">10 seconds</option>
                            <option value="30">30 seconds</option>
                        </select>
                    </div>
                </div>
            `;
            
            // Insert boat controls at the top of drone panel
            dronePanel.insertBefore(boatControlsDiv, dronePanel.firstChild);
            
            // Add event listeners
            document.getElementById('loadBoatBtn').addEventListener('click', loadPatrolBoat);
            document.getElementById('startPatrolBtn').addEventListener('click', startPatrol);
            document.getElementById('stopPatrolBtn').addEventListener('click', stopPatrol);
            document.getElementById('sensorSuiteToggle').addEventListener('change', toggleSensorSuite);
            document.getElementById('sensorInterval').addEventListener('change', updateSensorInterval);
            
            // Add patrol boat to the list
            const droneList = document.getElementById('droneList');
            const boatListItem = document.createElement('li');
            boatListItem.className = 'list-item';
            boatListItem.innerHTML = `
                <div class="list-item-header">
                    <span class="list-item-title">Patrol Boat</span>
                    <span class="status-dot" style="background-color: var(--inactive-gray)" id="boat-status-dot"></span>
                </div>
                <div class="list-item-subtitle" id="boat-status">
                    Status: Inactive | Fuel: 100%
                </div>
                <div class="list-item-actions">
                    <button class="action-button" id="trackBoatBtn" disabled>Track</button>
                    <button class="action-button" id="homeBoatBtn" disabled>Return Home</button>
                </div>
            `;
            droneList.insertBefore(boatListItem, droneList.firstChild);
            
            // Add track and home buttons
            document.getElementById('trackBoatBtn').addEventListener('click', () => {
                if (patrolBoat) {
                    viewer.trackedEntity = patrolBoat;
                }
            });
            document.getElementById('homeBoatBtn').addEventListener('click', returnBoatToHome);

            // Attach Track handlers for items in the drone list (static and dynamic)
            function handleDroneTrackClick(listItem) {
                try {
                    const titleEl = listItem.querySelector('.list-item-title');
                    const title = titleEl ? titleEl.textContent.trim() : null;
                    if (!title) return;

                    // Try to find a matching Cesium entity by name
                    let found = null;
                    const ents = viewer && viewer.entities && viewer.entities.values ? viewer.entities.values : [];
                    for (let i = 0; i < ents.length; i++) {
                        const e = ents[i];
                        if (!e) continue;
                        if (String(e.name) === title || e.id === title) { found = e; break; }
                    }

                    if (found) {
                        // Fly to the entity with a comfortable offset and temporarily track it
                        viewer.trackedEntity = found;
                        viewer.flyTo(found, {
                            duration: 1.2,
                            offset: new Cesium.HeadingPitchRange(0, Cesium.Math.toRadians(-45), 300)
                        }).then(() => {
                            try {
                                viewer.camera.lookAtTransform(Cesium.Matrix4.IDENTITY);
                                // release camera lock after flyTo so operator can resume control
                                viewer.trackedEntity = undefined;
                            } catch (e) { console.debug('Error resetting camera after drone flyTo:', e); }
                        }).catch((e) => {
                            try { viewer.zoomTo(found); } catch (err) { console.debug('Drone flyTo/zoomTo failed:', err, e); }
                        });
                    } else {
                        showNotification('No Map Entity', `No map entity found for ${title}`, 'warning');
                    }
                } catch (err) {
                    console.error('Error in handleDroneTrackClick:', err);
                }
            }

            function setupDroneTrackButtons() {
                const droneListEl = document.getElementById('droneList');
                if (!droneListEl) return;
                const items = droneListEl.querySelectorAll('li.list-item');
                items.forEach(item => {
                    if (item.__trackHandlerAttached) return;
                    const actionButtons = item.querySelectorAll('.list-item-actions .action-button');
                    actionButtons.forEach(btn => {
                        if (btn.textContent && btn.textContent.trim() === 'Track') {
                            btn.addEventListener('click', () => handleDroneTrackClick(item));
                        }
                    });
                    item.__trackHandlerAttached = true;
                });
            }

            // Initial setup for existing items
            setupDroneTrackButtons();

            // Observe future additions to the drone list and attach handlers automatically
            const droneListNode = document.getElementById('droneList');
            if (droneListNode && window.MutationObserver) {
                const mo = new MutationObserver(() => setupDroneTrackButtons());
                mo.observe(droneListNode, { childList: true, subtree: false });
            }
        }
        
        function loadPatrolBoat() {
            // Define a patrol route in San Francisco Bay
            patrolRoute = [
                { lat: 37.8199, lon: -122.4783, alt: 0 }, // Golden Gate Bridge
                { lat: 37.8270, lon: -122.4230, alt: 0 }, // Alcatraz
                { lat: 37.7749, lon: -122.4194, alt: 0 }, // San Francisco
                { lat: 37.8043, lon: -122.2711, alt: 0 }, // Oakland
                { lat: 37.7749, lon: -122.3780, alt: 0 }  // Bay Bridge
            ];
            
            // Create the boat entity
            patrolBoat = viewer.entities.add({
                name: 'RF SCYTHE Patrol Boat',
                position: Cesium.Cartesian3.fromDegrees(
                    patrolRoute[0].lon, 
                    patrolRoute[0].lat, 
                    patrolRoute[0].alt
                ),
                model: {
                    uri: 'assets/Part2.gltf',
                    scale: 2.0,
                    minimumPixelSize: 128,
                    maximumScale: 20000,
                    shadows: Cesium.ShadowMode.ENABLED
                },
                path: {
                    show: true,
                    width: 2,
                    material: new Cesium.PolylineGlowMaterialProperty({
                        glowPower: 0.2,
                        color: Cesium.Color.AQUA
                    }),
                    leadTime: 0
                }
            });
            
            // Update UI
            document.getElementById('loadBoatBtn').disabled = true;
            document.getElementById('startPatrolBtn').disabled = false;
            document.getElementById('sensorSuiteToggle').disabled = false;
            document.getElementById('sensorInterval').disabled = false;
            document.getElementById('trackBoatBtn').disabled = false;
            document.getElementById('homeBoatBtn').disabled = false;
            
            // Update status
            document.getElementById('boat-status-dot').style.backgroundColor = 'var(--success-green)';
            document.getElementById('boat-status').textContent = 'Status: Ready | Fuel: 100%';
            
            // Fly to boat with a comfortable offset and re-enable user controls after flight
            viewer.flyTo(patrolBoat, {
                duration: 1.5,
                offset: new Cesium.HeadingPitchRange(0, Cesium.Math.toRadians(-45), 500)
            }).then(function() {
                try {
                    // Reset camera transform to re-enable user control
                    viewer.camera.lookAtTransform(Cesium.Matrix4.IDENTITY);
                    viewer.trackedEntity = undefined;

                    const controller = viewer.scene.screenSpaceCameraController;
                    controller.enableRotate = true;
                    controller.enableTilt = true;
                    controller.enableZoom = true;
                    controller.enableTranslate = true;
                    controller.enableLook = true;
                } catch (e) {
                    console.debug('Error resetting camera after flyTo:', e);
                }
            }).catch(function(e) {
                // fallback to zoomTo if flyTo fails
                console.debug('flyTo failed, falling back to zoomTo:', e);
                try { viewer.zoomTo(patrolBoat); } catch (err) { console.debug('zoomTo fallback failed:', err); }
            });
            
            // Add console message
            addConsoleMessage('Patrol boat loaded into the system', 'response');
            showNotification('Patrol Boat Ready', 'RF SCYTHE patrol boat deployed with sensor suite capabilities.', 'info');
        }
        
        function startPatrol() {
            if (!patrolBoat) return;
            
            patrolActive = true;
            currentPatrolPoint = 0;
            
            // Update UI
            document.getElementById('startPatrolBtn').disabled = true;
            document.getElementById('stopPatrolBtn').disabled = false;
            document.getElementById('boat-status').textContent = 'Status: Patrolling | Fuel: 100%';
            
            // Start patrol movement
            moveToNextPatrolPoint();
            
            // Add console message
            addConsoleMessage('Patrol boat started route monitoring', 'command');
            showNotification('Patrol Started', 'Boat is now patrolling designated route with RF monitoring.', 'info');
        }
        
        function moveToNextPatrolPoint() {
            if (!patrolActive || !patrolBoat) return;
            
            const nextPoint = patrolRoute[currentPatrolPoint];
            
            // Get current position - safely
            let startLon, startLat;
            try {
                const startPosition = patrolBoat.position.getValue(Cesium.JulianDate.now());
                if (startPosition) {
                    const startCartographic = Cesium.Cartographic.fromCartesian(startPosition);
                    startLon = Cesium.Math.toDegrees(startCartographic.longitude);
                    startLat = Cesium.Math.toDegrees(startCartographic.latitude);
                } else {
                    // Fallback if position is undefined
                    startLon = nextPoint.lon - 0.01;
                    startLat = nextPoint.lat - 0.01;
                    console.warn("Using fallback position for boat movement");
                }
            } catch (e) {
                console.error("Error getting boat position:", e);
                // Use fallback values
                startLon = nextPoint.lon - 0.01;
                startLat = nextPoint.lat - 0.01;
            }
            
            // Calculate duration based on distance (simplified)
            const distance = calculateDistance(startLat, startLon, nextPoint.lat, nextPoint.lon);
            const duration = distance * 0.5; // 0.5 seconds per km
            
            // Create animation for smooth movement
            patrolBoat.position = new Cesium.CallbackProperty((time) => {
                const elapsedTime = Cesium.JulianDate.secondsDifference(time, Cesium.JulianDate.now());
                const t = Math.min(elapsedTime / duration, 1.0);
                
                // Linear interpolation between points
                const lon = startLon + (nextPoint.lon - startLon) * t;
                const lat = startLat + (nextPoint.lat - startLat) * t;
                
                // If we've reached the destination, move to next point
                if (t >= 1.0) {
                    currentPatrolPoint = (currentPatrolPoint + 1) % patrolRoute.length;
                    setTimeout(moveToNextPatrolPoint, 100);
                }
                
                // Adjust boat orientation to face direction of travel
                if (patrolBoat.orientation) {
                    try {
                        const heading = calculateHeading(startLat, startLon, nextPoint.lat, nextPoint.lon);
                        const cartesian = Cesium.Cartesian3.fromDegrees(lon, lat);
                        if (cartesian) {
                            patrolBoat.orientation = Cesium.Transforms.headingPitchRollQuaternion(
                                cartesian,
                                new Cesium.HeadingPitchRoll(
                                    Cesium.Math.toRadians(heading),
                                    0,
                                    0
                                )
                            );
                        }
                    } catch (e) {
                        console.error("Error setting boat orientation:", e);
                    }
                }
                
                return Cesium.Cartesian3.fromDegrees(lon, lat, nextPoint.alt);
            }, false);
            
            // If sensor suite is active, activate sensors at each point
            if (sensorSuiteActive) {
                activateSensors(nextPoint.lat, nextPoint.lon);
            }
        }
        
        function stopPatrol() {
            patrolActive = false;
            
            // Update UI
            document.getElementById('startPatrolBtn').disabled = false;
            document.getElementById('stopPatrolBtn').disabled = true;
            document.getElementById('boat-status').textContent = 'Status: Idle | Fuel: 85%';
            
            // Add console message
            addConsoleMessage('Patrol boat stopped', 'command');
        }
        
        function toggleSensorSuite(e) {
            sensorSuiteActive = e.target.checked;
            
            if (sensorSuiteActive) {
                // Get interval from dropdown
                const intervalSeconds = parseInt(document.getElementById('sensorInterval').value);
                
                // Setup sensor ping interval
                sensorInterval = setInterval(() => {
                    if (patrolBoat && patrolActive) {
                        const position = patrolBoat.position.getValue(Cesium.JulianDate.now());
                        const cartographic = Cesium.Cartographic.fromCartesian(position);
                        const lon = Cesium.Math.toDegrees(cartographic.longitude);
                        const lat = Cesium.Math.toDegrees(cartographic.latitude);
                        
                        activateSensors(lat, lon);
                    }
                }, intervalSeconds * 1000);
                
                // Add console message
                addConsoleMessage(`Sensor suite activated with ${intervalSeconds}s scan interval`, 'command');
                showNotification('Sensors Active', 'RF scanning and signal detection active on patrol boat.', 'info');
            } else {
                // Clear interval
                if (sensorInterval) {
                    clearInterval(sensorInterval);
                    sensorInterval = null;
                }
                
                // Add console message
                addConsoleMessage('Sensor suite deactivated', 'command');
            }
        }
        
        function updateSensorInterval() {
            if (sensorSuiteActive && sensorInterval) {
                // Clear existing interval
                clearInterval(sensorInterval);
                
                // Get new interval from dropdown
                const intervalSeconds = parseInt(document.getElementById('sensorInterval').value);
                
                // Setup new sensor ping interval
                sensorInterval = setInterval(() => {
                    if (patrolBoat && patrolActive) {
                        const position = patrolBoat.position.getValue(Cesium.JulianDate.now());
                        const cartographic = Cesium.Cartographic.fromCartesian(position);
                        const lon = Cesium.Math.toDegrees(cartographic.longitude);
                        const lat = Cesium.Math.toDegrees(cartographic.latitude);
                        
                        activateSensors(lat, lon);
                    }
                }, intervalSeconds * 1000);
                
                // Add console message
                addConsoleMessage(`Sensor scan interval updated to ${intervalSeconds}s`, 'response');
            }
        }
        
        function activateSensors(lat, lon) {
            try {
                // Check if coordinates are valid
                if (typeof lat !== 'number' || typeof lon !== 'number' || isNaN(lat) || isNaN(lon)) {
                    console.warn('Invalid coordinates for sensor activation', { lat, lon });
                    return;
                }
                
                // Add a sensor ping
                addSensorPing(lat, lon, 'cyan', 2, 3);
                
                // Simulate detecting signals
                const detectSignal = Math.random() < 0.3; // 30% chance of detection
                
                if (detectSignal) {
                    // Generate random offset for the signal location with bounds checking
                    // Keep offsets small to avoid invalid coordinates at edge cases
                    const maxOffset = 0.05; // in degrees
                    
                    // Create a safe offset that won't exceed latitude bounds
                    let latOffset = (Math.random() - 0.5) * maxOffset;
                    if (lat + latOffset > 90) latOffset = 90 - lat;
                    if (lat + latOffset < -90) latOffset = -90 - lat;
                    
                    // Create a safe offset that won't exceed longitude bounds
                    let lonOffset = (Math.random() - 0.5) * maxOffset;
                    if (lon + lonOffset > 180) lonOffset = 180 - lon;
                    if (lon + lonOffset < -180) lonOffset = -180 - lon;
                    
                    const signalLat = lat + latOffset;
                    const signalLon = lon + lonOffset;
                    const signalTypes = ['FM', 'AM', 'SSB', 'PSK', 'FSK'];
                    const signalType = signalTypes[Math.floor(Math.random() * signalTypes.length)];
                    const freq = (Math.random() * 900 + 100).toFixed(3);
                    
                    // Add a smaller ping for the detected signal
                    try {
                        // Only add ping if coordinates are valid
                        if (isFinite(signalLat) && isFinite(signalLon)) {
                            addSensorPing(signalLat, signalLon, 'yellow', 1, 2);
                        }
                    } catch (pingError) {
                        console.error('Error adding signal ping:', pingError);
                    }
                    
                    // Add console message
                    addConsoleMessage(`Detected ${signalType} signal at ${freq} MHz`, 'alert');
                    
                    // 10% chance of finding a violation
                    if (Math.random() < 0.1) {
                        // Add a red ping for violation - with safety checks
                        try {
                            if (isFinite(signalLat) && isFinite(signalLon)) {
                                addSensorPing(signalLat, signalLon, 'red', 1.5, 4);
                            }
                        } catch (pingError) {
                            console.error('Error adding violation ping:', pingError);
                        }
                        
                        // Add violation details
                        addConsoleMessage(`FCC VIOLATION: Unauthorized ${signalType} transmission at ${freq} MHz`, 'alert');
                        showNotification('FCC Violation Detected', 
                            `Patrol boat sensors detected unauthorized ${signalType} transmission at ${freq} MHz. Triangulating source location.`, 
                            'alert');
                        
                        // Add violation to the list
                        addViolationToList(freq, signalType, signalLat, signalLon);
                    }
                }
            } catch (e) {
                console.error('Error in activateSensors:', e);
            }
        }
        
        function addViolationToList(freq, modulationType, lat, lon) {
            // Validate coordinates
            if (typeof lat !== 'number' || typeof lon !== 'number' || isNaN(lat) || isNaN(lon)) {
                console.warn('Invalid coordinates for violation', { lat, lon });
                return;
            }
            
            // Ensure coordinates are in valid range
            if (lat < -90 || lat > 90 || lon < -180 || lon > 180) {
                console.warn('Coordinates out of range for violation', { lat, lon });
                return;
            }
            
            const violationList = document.getElementById('violationList');
            
            // Create new violation item
            const violationItem = document.createElement('li');
            violationItem.className = 'signal-card violation';
            violationItem.innerHTML = `
                <div class="list-item-header">
                    <span class="list-item-title">${freq} MHz</span>
                    <span style="background-color: #c93840; padding: 2px 6px; border-radius: 3px; font-size: 11px;">UNLICENSED</span>
                </div>
                <div class="feature-value">
                    <span class="feature-name">Signal Strength:</span>
                    <span>${-Math.floor(Math.random() * 30 + 30)} dBm</span>
                </div>
                <div class="feature-value">
                    <span class="feature-name">Violation Type:</span>
                    <span>Unlicensed Operation</span>
                </div>
                <div class="feature-value">
                    <span class="feature-name">AI Classification:</span>
                    <span>${modulationType} (Detected by Patrol Boat)</span>
                </div>
                <div class="confidence-bar">
                    <div class="confidence-level" style="width: ${Math.floor(Math.random() * 20 + 80)}%; background-color: #c93840;"></div>
                </div>
                <div class="list-item-actions">
                    <button class="action-button">Geolocate</button>
                    <button class="action-button danger">Pursue</button>
                </div>
            `;
            
            // Add to list
            violationList.insertBefore(violationItem, violationList.firstChild);
            
            // Update violation count
            const violationCount = document.querySelector('#violations-panel .status-count');
            if (violationCount) {
                violationCount.textContent = violationList.children.length;
            }
            
            // Also update the FCC VIOLATIONS indicator in the header
            const violationIndicator = document.querySelector('.status-indicator.status-alert span');
            if (violationIndicator) {
                violationIndicator.textContent = `FCC VIOLATIONS: ${violationList.children.length}`;
            }                        // Add violation to the map using our safe utility functions
                        try {
                            // Use our new safe coordinate functions and RF_SCYTHE namespace
                            if (window.RF_SCYTHE && typeof window.RF_SCYTHE.sanitizeCoordinates === 'function') {
                                const sanitized = window.RF_SCYTHE.sanitizeCoordinates(signalLat, signalLon);
                                RF_SCYTHE.addViolation(viewer, sanitized.latitude, sanitized.longitude, parseFloat(freq), 
                                    "Unauthorized transmission detected by patrol boat");
                                
                                // Use createSafeEllipse if available, otherwise fall back to addUncertaintyCircle
                                if (typeof RF_SCYTHE.createSafeEllipse === 'function') {
                                    RF_SCYTHE.createSafeEllipse(viewer, 
                                        Cesium.Cartesian3.fromDegrees(sanitized.longitude, sanitized.latitude), 
                                        5000, 5000, Cesium.Color.RED.withAlpha(0.3), {
                                            outlineColor: Cesium.Color.RED.withAlpha(0.7),
                                            rotation: 0.001 // Small non-zero rotation to avoid problems
                                        });
                                } else {
                                    RF_SCYTHE.addUncertaintyCircle(viewer, sanitized.latitude, sanitized.longitude, 5000, true);
                                }
                            } else {
                                // Fallback to old method with added validation
                                const validLat = typeof signalLat === 'number' && !isNaN(signalLat) ? 
                                    Math.max(-90, Math.min(90, signalLat)) : 0;
                                const validLon = typeof signalLon === 'number' && !isNaN(signalLon) ? 
                                    Math.max(-180, Math.min(180, signalLon)) : 0;
                                
                                RF_SCYTHE.addViolation(viewer, validLat, validLon, parseFloat(freq), 
                                    "Unauthorized transmission detected by patrol boat");
                                RF_SCYTHE.addUncertaintyCircle(viewer, validLat, validLon, 5000, true);
                            }
                        } catch (e) {
                            console.error("Error adding violation markers to map:", e);
                            // Continue anyway - UI was already updated
                        }
        }
        
        function returnBoatToHome() {
            if (!patrolBoat) return;
            
            // Stop current patrol
            stopPatrol();
            
            // Return to first point
            currentPatrolPoint = 0;
            patrolBoat.position = Cesium.Cartesian3.fromDegrees(
                patrolRoute[0].lon, 
                patrolRoute[0].lat, 
                patrolRoute[0].alt
            );
            
            // Update status
            document.getElementById('boat-status').textContent = 'Status: Returned to Home | Fuel: 80%';
            
            // Add console message
            addConsoleMessage('Patrol boat returned to home position', 'command');
        }
        
        // Helper functions for boat movement
        function calculateDistance(lat1, lon1, lat2, lon2) {
            const R = 6371; // Radius of the earth in km
            const dLat = deg2rad(lat2 - lat1);
            const dLon = deg2rad(lon2 - lon1);
            const a = 
                Math.sin(dLat/2) * Math.sin(dLat/2) +
                Math.cos(deg2rad(lat1)) * Math.cos(deg2rad(lat2)) * 
                Math.sin(dLon/2) * Math.sin(dLon/2); 
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a)); 
            const d = R * c; // Distance in km
            return d;
        }
        
        function deg2rad(deg) {
            return deg * (Math.PI/180);
        }
        
        function calculateHeading(lat1, lon1, lat2, lon2) {
            const dLon = deg2rad(lon2 - lon1);
            const y = Math.sin(dLon) * Math.cos(deg2rad(lat2));
            const x = Math.cos(deg2rad(lat1)) * Math.sin(deg2rad(lat2)) -
                      Math.sin(deg2rad(lat1)) * Math.cos(deg2rad(lat2)) * Math.cos(dLon);
            let brng = Math.atan2(y, x);
            brng = rad2deg(brng);
            return (brng + 360) % 360;
        }
        
        function rad2deg(rad) {
            return rad * (180/Math.PI);
        }

        // =====================================================================
        // HIERARCHICAL RENDER MANAGER
        // Handles clustering, zoom-dependent visibility, and level-of-detail
        // =====================================================================
        
        const HierarchicalRenderManager = {
            viewer: null,
            dataSources: {},
            cameraListener: null,
            currentAltitude: 0,
            
            // Altitude thresholds (in meters)
            THRESHOLDS: {
                GLOBAL: 5000000,       // Above 5000km: Show only large clusters
                REGIONAL: 500000,      // 500km-5000km: Show medium clusters
                LOCAL: 50000,          // 50km-500km: Show small clusters + labels
                DETAILED: 10000        // Below 50km: Show all details
            },
            
            // Cluster configuration
            CLUSTER_CONFIG: {
                enabled: true,
                pixelRange: 45,        // Pixels between clusters
                minimumClusterSize: 2,
                clusterBillboards: true,
                clusterLabels: true,
                clusterPoints: true
            },
            
            initialize: function(cesiumViewer) {
                this.viewer = cesiumViewer;
                this.setupCameraListener();
                console.log('HierarchicalRenderManager initialized');
                return this;
            },
            
            setupCameraListener: function() {
                if (!this.viewer) return;
                
                const self = this;
                
                // Listen for camera movement to update visibility
                this.cameraListener = this.viewer.camera.changed.addEventListener(function() {
                    const cartographic = Cesium.Cartographic.fromCartesian(self.viewer.camera.position);
                    self.currentAltitude = cartographic.height;
                    self.updateVisibilityForAltitude();
                });
                
                // Initial update
                const cartographic = Cesium.Cartographic.fromCartesian(this.viewer.camera.position);
                this.currentAltitude = cartographic.height;
            },
            
            // Create a clustered data source for a layer
            createClusteredDataSource: function(name, options = {}) {
                if (!this.viewer) return null;
                
                const dataSource = new Cesium.CustomDataSource(name);
                
                // Configure clustering
                dataSource.clustering.enabled = options.enabled !== false;
                dataSource.clustering.pixelRange = options.pixelRange || this.CLUSTER_CONFIG.pixelRange;
                dataSource.clustering.minimumClusterSize = options.minimumClusterSize || this.CLUSTER_CONFIG.minimumClusterSize;
                dataSource.clustering.clusterBillboards = options.clusterBillboards !== false;
                dataSource.clustering.clusterLabels = options.clusterLabels !== false;
                dataSource.clustering.clusterPoints = options.clusterPoints !== false;
                
                // Store reference
                this.dataSources[name] = dataSource;
                
                // Add to viewer
                this.viewer.dataSources.add(dataSource);
                
                console.log(`Created clustered data source: ${name}`);
                return dataSource;
            },
            
            // Setup cluster event handler with custom styling
            setupClusterStyling: function(dataSource, styleCallback) {
                if (!dataSource || !dataSource.clustering) return;
                
                const self = this;
                
                dataSource.clustering.clusterEvent.addEventListener(function(clusteredEntities, cluster) {
                    // Default cluster appearance
                    cluster.label.show = true;
                    cluster.label.text = clusteredEntities.length.toString();
                    cluster.label.font = 'bold 14px sans-serif';
                    cluster.label.outlineWidth = 2;
                    cluster.label.outlineColor = Cesium.Color.BLACK;
                    cluster.label.style = Cesium.LabelStyle.FILL_AND_OUTLINE;
                    cluster.label.verticalOrigin = Cesium.VerticalOrigin.CENTER;
                    cluster.label.horizontalOrigin = Cesium.HorizontalOrigin.CENTER;
                    cluster.label.pixelOffset = new Cesium.Cartesian2(0, 0);
                    
                    cluster.billboard.show = true;
                    cluster.billboard.verticalOrigin = Cesium.VerticalOrigin.CENTER;
                    cluster.billboard.horizontalOrigin = Cesium.HorizontalOrigin.CENTER;
                    
                    // Apply custom styling if provided
                    if (styleCallback) {
                        styleCallback(clusteredEntities, cluster, self.currentAltitude);
                    } else {
                        // Default cluster icon
                        cluster.billboard.image = self.createClusterIcon(clusteredEntities.length, Cesium.Color.GRAY);
                        cluster.label.fillColor = Cesium.Color.WHITE;
                    }
                });
            },
            
            // Create a cluster icon with entity count
            createClusterIcon: function(count, color, size = 40) {
                const canvas = document.createElement('canvas');
                canvas.width = size;
                canvas.height = size;
                const ctx = canvas.getContext('2d');
                
                // Background circle
                ctx.beginPath();
                ctx.arc(size/2, size/2, size/2 - 2, 0, 2 * Math.PI);
                ctx.fillStyle = color.toCssColorString();
                ctx.fill();
                
                // Border
                ctx.strokeStyle = 'rgba(255,255,255,0.8)';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // Inner circle for depth effect
                ctx.beginPath();
                ctx.arc(size/2, size/2, size/2 - 6, 0, 2 * Math.PI);
                ctx.fillStyle = 'rgba(0,0,0,0.3)';
                ctx.fill();
                
                return canvas.toDataURL();
            },
            
            // Update visibility based on current altitude
            updateVisibilityForAltitude: function() {
                // Emit an event that layers can listen to
                const event = new CustomEvent('altitudeChanged', {
                    detail: {
                        altitude: this.currentAltitude,
                        level: this.getDetailLevel()
                    }
                });
                document.dispatchEvent(event);
            },
            
            // Get current detail level based on altitude
            getDetailLevel: function() {
                if (this.currentAltitude > this.THRESHOLDS.GLOBAL) return 'GLOBAL';
                if (this.currentAltitude > this.THRESHOLDS.REGIONAL) return 'REGIONAL';
                if (this.currentAltitude > this.THRESHOLDS.LOCAL) return 'LOCAL';
                return 'DETAILED';
            },
            
            // Check if a detail should be visible at current altitude
            shouldShowDetail: function(detailType) {
                const level = this.getDetailLevel();
                
                switch (detailType) {
                    case 'labels':
                        return level === 'LOCAL' || level === 'DETAILED';
                    case 'rings':
                    case 'trails':
                        return level === 'DETAILED';
                    case 'altitudeLines':
                        return level === 'LOCAL' || level === 'DETAILED';
                    case 'hyperedges':
                        return level !== 'GLOBAL';
                    default:
                        return true;
                }
            },
            
            // Get cluster pixel range based on altitude (adaptive clustering)
            getAdaptivePixelRange: function() {
                const level = this.getDetailLevel();
                switch (level) {
                    case 'GLOBAL': return 80;
                    case 'REGIONAL': return 60;
                    case 'LOCAL': return 40;
                    case 'DETAILED': return 20;
                    default: return 45;
                }
            },
            
            // Client-side spatial index (simple quadtree)
            SpatialQuadtree: class {
                constructor(bounds, maxObjects = 10, maxLevels = 5, level = 0) {
                    this.bounds = bounds; // { minLon, minLat, maxLon, maxLat }
                    this.maxObjects = maxObjects;
                    this.maxLevels = maxLevels;
                    this.level = level;
                    this.objects = [];
                    this.nodes = [];
                }
                
                clear() {
                    this.objects = [];
                    this.nodes.forEach(node => node.clear());
                    this.nodes = [];
                }
                
                split() {
                    const midLon = (this.bounds.minLon + this.bounds.maxLon) / 2;
                    const midLat = (this.bounds.minLat + this.bounds.maxLat) / 2;
                    
                    this.nodes = [
                        new HierarchicalRenderManager.SpatialQuadtree(
                            { minLon: this.bounds.minLon, minLat: midLat, maxLon: midLon, maxLat: this.bounds.maxLat },
                            this.maxObjects, this.maxLevels, this.level + 1
                        ),
                        new HierarchicalRenderManager.SpatialQuadtree(
                            { minLon: midLon, minLat: midLat, maxLon: this.bounds.maxLon, maxLat: this.bounds.maxLat },
                            this.maxObjects, this.maxLevels, this.level + 1
                        ),
                        new HierarchicalRenderManager.SpatialQuadtree(
                            { minLon: this.bounds.minLon, minLat: this.bounds.minLat, maxLon: midLon, maxLat: midLat },
                            this.maxObjects, this.maxLevels, this.level + 1
                        ),
                        new HierarchicalRenderManager.SpatialQuadtree(
                            { minLon: midLon, minLat: this.bounds.minLat, maxLon: this.bounds.maxLon, maxLat: midLat },
                            this.maxObjects, this.maxLevels, this.level + 1
                        )
                    ];
                }
                
                getIndex(obj) {
                    const midLon = (this.bounds.minLon + this.bounds.maxLon) / 2;
                    const midLat = (this.bounds.minLat + this.bounds.maxLat) / 2;
                    
                    const top = obj.lat > midLat;
                    const left = obj.lon < midLon;
                    
                    if (top) {
                        return left ? 0 : 1;
                    } else {
                        return left ? 2 : 3;
                    }
                }
                
                insert(obj) {
                    if (this.nodes.length > 0) {
                        const index = this.getIndex(obj);
                        this.nodes[index].insert(obj);
                        return;
                    }
                    
                    this.objects.push(obj);
                    
                    if (this.objects.length > this.maxObjects && this.level < this.maxLevels) {
                        if (this.nodes.length === 0) {
                            this.split();
                        }
                        
                        this.objects.forEach(o => {
                            const index = this.getIndex(o);
                            this.nodes[index].insert(o);
                        });
                        
                        this.objects = [];
                    }
                }
                
                retrieve(bounds) {
                    let results = [...this.objects];
                    
                    if (this.nodes.length > 0) {
                        // Check which quadrants intersect with bounds
                        this.nodes.forEach(node => {
                            if (this.intersects(node.bounds, bounds)) {
                                results = results.concat(node.retrieve(bounds));
                            }
                        });
                    }
                    
                    return results;
                }
                
                intersects(a, b) {
                    return !(a.maxLon < b.minLon || a.minLon > b.maxLon ||
                             a.maxLat < b.minLat || a.minLat > b.maxLat);
                }
            },
            
            // Create a quadtree for a set of entities
            createQuadtree: function(entities) {
                const tree = new this.SpatialQuadtree({
                    minLon: -180, minLat: -90, maxLon: 180, maxLat: 90
                });
                
                const list = Array.isArray(entities) ? entities
                             : entities?.values ? entities.values
                             : [];
                list.forEach(e => {
                    if (e.location || e.lat) {
                        tree.insert({
                            id: e.entity_id || e.mmsi || e.id,
                            lat: e.location ? e.location.lat : e.lat,
                            lon: e.location ? e.location.lon : e.lon,
                            data: e
                        });
                    }
                });
                
                return tree;
            },
            
            // Get visible entities from quadtree based on current view
            getVisibleEntities: function(quadtree) {
                if (!this.viewer || !quadtree) return [];
                
                const rect = this.viewer.camera.computeViewRectangle();
                if (!rect) return [];
                
                const bounds = {
                    minLon: Cesium.Math.toDegrees(rect.west),
                    minLat: Cesium.Math.toDegrees(rect.south),
                    maxLon: Cesium.Math.toDegrees(rect.east),
                    maxLat: Cesium.Math.toDegrees(rect.north)
                };
                
                return quadtree.retrieve(bounds);
            },
            
            // Cleanup
            destroy: function() {
                if (this.cameraListener) {
                    this.cameraListener();
                    this.cameraListener = null;
                }
                
                Object.values(this.dataSources).forEach(ds => {
                    if (this.viewer && this.viewer.dataSources.contains(ds)) {
                        this.viewer.dataSources.remove(ds);
                    }
                });
                
                this.dataSources = {};
            }
        };
        
        // Make globally available
        window.HierarchicalRenderManager = HierarchicalRenderManager;

        // =====================================================================
        // RF PROPAGATION MANAGER - Advanced Terrain-Aware Propagation Modeling
        // Based on ITU-R P.452, ITM, and APRT methodologies
        // =====================================================================
        
        const RFPropagationManager = {
            viewer: null,
            terrainProvider: null,
            propagationPaths: {},
            atmosphericConditions: {
                // Default atmospheric parameters
                surfaceRefractivity: 315,           // N-units (standard atmosphere)
                refractivityGradient: -40,          // N-units/km (standard)
                kFactor: 4/3,                       // Effective Earth radius factor
                humidity: 50,                       // Relative humidity %
                temperature: 15,                    // Celsius
                pressure: 1013.25                   // hPa (sea level)
            },
            
            // Physical constants
            CONSTANTS: {
                EARTH_RADIUS_M: 6371000,
                SPEED_OF_LIGHT: 299792458,
                EFFECTIVE_EARTH_FACTOR: 4/3        // Standard k-factor
            },
            
            // Propagation model configuration
            CONFIG: {
                terrainSampleSpacing: 100,         // meters between terrain samples
                maxTerrainSamples: 200,            // Max samples per path
                fresnelZoneCount: 1,               // Number of Fresnel zones to check
                diffractionModel: 'bullington',    // 'bullington', 'deygout', 'epstein-peterson'
                atmosphericModel: 'itu-r-p835',    // Atmospheric refractivity model
                enableDucting: false,               // Super/sub-refraction modeling
                logPerformance: true               // Log metrics to MetricsLogger
            },
            
            initialize: function(cesiumViewer) {
                this.viewer = cesiumViewer;
                if (cesiumViewer && cesiumViewer.terrainProvider) {
                    this.terrainProvider = cesiumViewer.terrainProvider;
                }
                console.log('[RFPropagation] Manager initialized with terrain-aware propagation');
                return this;
            },
            
            /**
             * Calculate path loss between transmitter and receiver
             * Uses terrain profile sampling and knife-edge diffraction
             * @param {Object} tx - Transmitter {lat, lon, height_m, frequency_mhz, power_dbm}
             * @param {Object} rx - Receiver {lat, lon, height_m, sensitivity_dbm}
             * @returns {Promise<Object>} Path loss analysis result
             */
            calculatePathLoss: async function(tx, rx) {
                const startTime = performance.now();
                
                try {
                    // Step 1: Calculate basic geometry
                    const pathGeometry = this._calculatePathGeometry(tx, rx);
                    
                    // Step 2: Get terrain profile along path
                    const terrainProfile = await this._sampleTerrainProfile(tx, rx);
                    
                    // Step 3: Calculate free-space path loss
                    const fspl = this._calculateFreeSpacePathLoss(
                        pathGeometry.distance_m, 
                        tx.frequency_mhz
                    );
                    
                    // Step 4: Calculate Fresnel zone clearance
                    const fresnelAnalysis = this._calculateFresnelClearance(
                        tx, rx, terrainProfile, tx.frequency_mhz
                    );
                    
                    // Step 5: Calculate knife-edge diffraction loss
                    const diffractionLoss = this._calculateDiffractionLoss(
                        tx, rx, terrainProfile, tx.frequency_mhz
                    );
                    
                    // Step 6: Apply atmospheric effects
                    const atmosphericLoss = this._calculateAtmosphericLoss(
                        pathGeometry.distance_m, 
                        tx.frequency_mhz,
                        this.atmosphericConditions
                    );
                    
                    // Step 7: Calculate total path loss
                    const totalPathLoss = fspl + diffractionLoss + atmosphericLoss;
                    
                    // Step 8: Determine link margin
                    const receivedPower = tx.power_dbm - totalPathLoss;
                    const linkMargin = receivedPower - (rx.sensitivity_dbm || -100);
                    
                    const result = {
                        timestamp: Date.now(),
                        tx: tx,
                        rx: rx,
                        geometry: pathGeometry,
                        terrain: {
                            sampleCount: terrainProfile.length,
                            maxElevation: Math.max(...terrainProfile.map(p => p.height)),
                            minElevation: Math.min(...terrainProfile.map(p => p.height)),
                            obstructions: fresnelAnalysis.obstructions
                        },
                        losses: {
                            freeSpace_db: fspl,
                            diffraction_db: diffractionLoss,
                            atmospheric_db: atmosphericLoss,
                            total_db: totalPathLoss
                        },
                        fresnelClearance: fresnelAnalysis,
                        linkBudget: {
                            txPower_dbm: tx.power_dbm,
                            pathLoss_db: totalPathLoss,
                            receivedPower_dbm: receivedPower,
                            rxSensitivity_dbm: rx.sensitivity_dbm || -100,
                            linkMargin_db: linkMargin,
                            linkViable: linkMargin > 0
                        },
                        processingTime_ms: performance.now() - startTime
                    };
                    
                    // Log propagation metrics
                    if (this.CONFIG.logPerformance && window.logMetric) {
                        window.logMetric('propagation', 'path_loss_db', totalPathLoss);
                        window.logMetric('propagation', 'diffraction_loss_db', diffractionLoss);
                        window.logMetric('propagation', 'link_margin_db', linkMargin);
                        window.logMetric('propagation', 'processing_time_ms', result.processingTime_ms);
                        window.logMetric('propagation', 'terrain_samples', terrainProfile.length);
                    }
                    
                    return result;
                    
                } catch (error) {
                    console.error('[RFPropagation] Path loss calculation failed:', error);
                    return {
                        error: error.message,
                        processingTime_ms: performance.now() - startTime
                    };
                }
            },
            
            /**
             * Calculate basic path geometry
             */
            _calculatePathGeometry: function(tx, rx) {
                const distance = this._haversineDistance(tx.lat, tx.lon, rx.lat, rx.lon);
                const bearing = this._calculateBearing(tx.lat, tx.lon, rx.lat, rx.lon);
                
                // Calculate horizon distances with k-factor
                const effectiveRadius = this.CONSTANTS.EARTH_RADIUS_M * this.atmosphericConditions.kFactor;
                const txHorizon = Math.sqrt(2 * effectiveRadius * tx.height_m);
                const rxHorizon = Math.sqrt(2 * effectiveRadius * rx.height_m);
                
                return {
                    distance_m: distance,
                    distance_km: distance / 1000,
                    bearing_deg: bearing,
                    txHorizon_m: txHorizon,
                    rxHorizon_m: rxHorizon,
                    maxLineOfSight_m: txHorizon + rxHorizon,
                    beyondLineOfSight: distance > (txHorizon + rxHorizon)
                };
            },
            
            /**
             * Sample terrain heights along the path using Cesium's terrain API
             */
            _sampleTerrainProfile: async function(tx, rx) {
                const distance = this._haversineDistance(tx.lat, tx.lon, rx.lat, rx.lon);
                const numSamples = Math.min(
                    Math.ceil(distance / this.CONFIG.terrainSampleSpacing),
                    this.CONFIG.maxTerrainSamples
                );
                
                const positions = [];
                for (let i = 0; i <= numSamples; i++) {
                    const fraction = i / numSamples;
                    const lat = tx.lat + (rx.lat - tx.lat) * fraction;
                    const lon = tx.lon + (rx.lon - tx.lon) * fraction;
                    positions.push(Cesium.Cartographic.fromDegrees(lon, lat));
                }
                
                // Try to use Cesium terrain sampling if available
                if (this.viewer && this.terrainProvider && 
                    typeof Cesium.sampleTerrainMostDetailed === 'function') {
                    try {
                        const sampledPositions = await Cesium.sampleTerrainMostDetailed(
                            this.terrainProvider, 
                            positions
                        );
                        
                        return sampledPositions.map((pos, idx) => ({
                            lat: Cesium.Math.toDegrees(pos.latitude),
                            lon: Cesium.Math.toDegrees(pos.longitude),
                            height: pos.height || 0,
                            distance_m: (idx / numSamples) * distance
                        }));
                    } catch (terrainError) {
                        console.warn('[RFPropagation] Terrain sampling failed, using elevation model:', terrainError);
                    }
                }
                
                // Fallback: Simple elevation model based on position
                return positions.map((pos, idx) => ({
                    lat: Cesium.Math.toDegrees(pos.latitude),
                    lon: Cesium.Math.toDegrees(pos.longitude),
                    height: this._estimateElevation(
                        Cesium.Math.toDegrees(pos.latitude),
                        Cesium.Math.toDegrees(pos.longitude)
                    ),
                    distance_m: (idx / numSamples) * distance
                }));
            },
            
            /**
             * Estimate elevation when terrain data unavailable (simple model)
             */
            _estimateElevation: function(lat, lon) {
                // Simple procedural elevation model
                // In production, use actual DEM data
                const baseElev = 50 + Math.sin(lat * 0.5) * 200 + Math.cos(lon * 0.3) * 150;
                const noise = Math.sin(lat * 10) * Math.cos(lon * 10) * 100;
                return Math.max(0, baseElev + noise);
            },
            
            /**
             * Calculate Free-Space Path Loss (FSPL)
             * FSPL = 20*log10(d) + 20*log10(f) + 32.44 (d in km, f in MHz)
             */
            _calculateFreeSpacePathLoss: function(distance_m, frequency_mhz) {
                const d_km = distance_m / 1000;
                if (d_km <= 0 || frequency_mhz <= 0) return 0;
                
                return 20 * Math.log10(d_km) + 20 * Math.log10(frequency_mhz) + 32.44;
            },
            
            /**
             * Calculate Fresnel zone radius at a point along the path
             */
            _calculateFresnelRadius: function(d1_m, d2_m, frequency_mhz, zoneNumber = 1) {
                const wavelength = this.CONSTANTS.SPEED_OF_LIGHT / (frequency_mhz * 1e6);
                const totalDistance = d1_m + d2_m;
                
                if (totalDistance <= 0) return 0;
                
                return Math.sqrt((zoneNumber * wavelength * d1_m * d2_m) / totalDistance);
            },
            
            /**
             * Calculate Fresnel zone clearance along the path
             */
            _calculateFresnelClearance: function(tx, rx, terrainProfile, frequency_mhz) {
                const totalDistance = this._haversineDistance(tx.lat, tx.lon, rx.lat, rx.lon);
                const obstructions = [];
                let minClearanceRatio = Infinity;
                let worstPoint = null;
                
                terrainProfile.forEach((point, idx) => {
                    if (idx === 0 || idx === terrainProfile.length - 1) return;
                    
                    const d1 = point.distance_m;
                    const d2 = totalDistance - d1;
                    
                    // Calculate LOS height at this point
                    const losHeight = tx.height_m + 
                        (rx.height_m - tx.height_m) * (d1 / totalDistance);
                    
                    // Calculate first Fresnel zone radius
                    const fresnelRadius = this._calculateFresnelRadius(d1, d2, frequency_mhz, 1);
                    
                    // Calculate clearance
                    const groundClearance = losHeight - point.height;
                    const clearanceRatio = groundClearance / fresnelRadius;
                    
                    if (clearanceRatio < minClearanceRatio) {
                        minClearanceRatio = clearanceRatio;
                        worstPoint = {
                            index: idx,
                            distance_m: d1,
                            terrainHeight: point.height,
                            losHeight: losHeight,
                            fresnelRadius: fresnelRadius,
                            clearance_m: groundClearance,
                            clearanceRatio: clearanceRatio
                        };
                    }
                    
                    // Track obstructions (clearance < 60% of first Fresnel zone)
                    if (clearanceRatio < 0.6) {
                        obstructions.push({
                            distance_m: d1,
                            height: point.height,
                            intrusion_m: fresnelRadius * 0.6 - groundClearance
                        });
                    }
                });
                
                return {
                    minClearanceRatio: minClearanceRatio,
                    worstPoint: worstPoint,
                    obstructions: obstructions,
                    obstructionCount: obstructions.length,
                    clearPathPercent: Math.max(0, Math.min(100, minClearanceRatio * 100)),
                    adequate: minClearanceRatio >= 0.6  // 60% first Fresnel zone clearance
                };
            },
            
            /**
             * Calculate knife-edge diffraction loss using selected model
             * Based on ITU-R P.526 and Bullington method
             */
            _calculateDiffractionLoss: function(tx, rx, terrainProfile, frequency_mhz) {
                const totalDistance = this._haversineDistance(tx.lat, tx.lon, rx.lat, rx.lon);
                
                // Find the dominant obstacle (Bullington method)
                let maxObstruction = null;
                let maxV = -Infinity;
                
                terrainProfile.forEach((point, idx) => {
                    if (idx === 0 || idx === terrainProfile.length - 1) return;
                    
                    const d1 = point.distance_m;
                    const d2 = totalDistance - d1;
                    
                    // Calculate LOS height at this point
                    const losHeight = tx.height_m + 
                        (rx.height_m - tx.height_m) * (d1 / totalDistance);
                    
                    // Height of obstacle above LOS
                    const h = point.height - losHeight;
                    
                    if (h > 0) {
                        // Calculate Fresnel-Kirchhoff parameter v
                        const wavelength = this.CONSTANTS.SPEED_OF_LIGHT / (frequency_mhz * 1e6);
                        const v = h * Math.sqrt(2 / wavelength * (1/d1 + 1/d2));
                        
                        if (v > maxV) {
                            maxV = v;
                            maxObstruction = {
                                index: idx,
                                distance_m: d1,
                                height: point.height,
                                obstructionHeight: h,
                                v: v
                            };
                        }
                    }
                });
                
                if (!maxObstruction || maxV <= -0.78) {
                    // No significant diffraction loss
                    return 0;
                }
                
                // Calculate diffraction loss using ITU-R P.526 approximation
                let diffractionLoss;
                if (maxV > -0.78 && maxV <= 0) {
                    diffractionLoss = 0;
                } else if (maxV > 0 && maxV <= 2.4) {
                    diffractionLoss = 6.02 + 9.11 * maxV - 1.27 * maxV * maxV;
                } else {
                    // v > 2.4
                    diffractionLoss = 12.953 + 20 * Math.log10(maxV);
                }
                
                return Math.max(0, diffractionLoss);
            },
            
            /**
             * Calculate atmospheric absorption loss
             * Simplified ITU-R P.676 model for oxygen and water vapor absorption
             */
            _calculateAtmosphericLoss: function(distance_m, frequency_mhz, conditions) {
                const d_km = distance_m / 1000;
                
                // Atmospheric absorption is significant above ~10 GHz
                if (frequency_mhz < 1000) {
                    return 0;  // Negligible below 1 GHz
                }
                
                // Simplified specific attenuation (dB/km)
                // Based on ITU-R P.676 for sea-level standard atmosphere
                let gamma = 0;
                
                if (frequency_mhz >= 1000 && frequency_mhz < 10000) {
                    gamma = 0.001 * (frequency_mhz / 1000);
                } else if (frequency_mhz >= 10000 && frequency_mhz < 60000) {
                    // Increasing absorption, peak at 60 GHz (oxygen)
                    gamma = 0.01 + 0.0015 * (frequency_mhz - 10000) / 1000;
                } else if (frequency_mhz >= 60000) {
                    // Very high absorption near 60 GHz
                    gamma = 15;
                }
                
                // Adjust for humidity (water vapor absorption)
                const humidityFactor = 1 + (conditions.humidity - 50) / 200;
                
                return gamma * d_km * humidityFactor;
            },
            
            /**
             * Set atmospheric conditions for refractivity modeling
             */
            setAtmosphericConditions: function(conditions) {
                Object.assign(this.atmosphericConditions, conditions);
                
                // Recalculate k-factor from refractivity gradient
                // k = 1 / (1 + (Re/n) * dn/dh)
                const gradient = conditions.refractivityGradient || -40;
                this.atmosphericConditions.kFactor = 1 / (1 + (this.CONSTANTS.EARTH_RADIUS_M / 1e6) * (gradient / 1e6));
                
                console.log('[RFPropagation] Atmospheric conditions updated, k-factor:', 
                    this.atmosphericConditions.kFactor.toFixed(3));
            },
            
            /**
             * Classify atmospheric conditions (ducting analysis)
             */
            classifyAtmosphere: function() {
                const k = this.atmosphericConditions.kFactor;
                
                if (k > 2) {
                    return {
                        condition: 'super-refractive',
                        description: 'Ducting likely - signals may travel beyond normal horizon',
                        color: Cesium.Color.BLUE.withAlpha(0.5)
                    };
                } else if (k >= 1.2 && k <= 2) {
                    return {
                        condition: 'standard',
                        description: 'Standard atmospheric conditions',
                        color: Cesium.Color.GREEN.withAlpha(0.5)
                    };
                } else if (k >= 0.8 && k < 1.2) {
                    return {
                        condition: 'sub-refractive',
                        description: 'Reduced range - signals bend away from earth',
                        color: Cesium.Color.ORANGE.withAlpha(0.5)
                    };
                } else {
                    return {
                        condition: 'anomalous',
                        description: 'Anomalous propagation conditions',
                        color: Cesium.Color.RED.withAlpha(0.5)
                    };
                }
            },
            
            /**
             * Visualize a propagation path on the map
             */
            visualizePropagationPath: async function(pathId, tx, rx, options = {}) {
                if (!this.viewer) return null;
                
                // Calculate path loss
                const analysis = await this.calculatePathLoss(tx, rx);
                if (analysis.error) return null;
                
                const entities = [];
                
                // Transmitter marker
                entities.push(this.viewer.entities.add({
                    id: `prop_tx_${pathId}`,
                    position: Cesium.Cartesian3.fromDegrees(tx.lon, tx.lat, tx.height_m),
                    point: {
                        pixelSize: 14,
                        color: Cesium.Color.CYAN,
                        outlineColor: Cesium.Color.WHITE,
                        outlineWidth: 2
                    },
                    label: {
                        text: `TX: ${tx.frequency_mhz} MHz\n${tx.power_dbm} dBm`,
                        font: '10px sans-serif',
                        fillColor: Cesium.Color.CYAN,
                        outlineColor: Cesium.Color.BLACK,
                        outlineWidth: 2,
                        style: Cesium.LabelStyle.FILL_AND_OUTLINE,
                        verticalOrigin: Cesium.VerticalOrigin.BOTTOM,
                        pixelOffset: new Cesium.Cartesian2(0, -20)
                    }
                }));
                
                // Receiver marker
                const rxColor = analysis.linkBudget.linkViable ? Cesium.Color.GREEN : Cesium.Color.RED;
                entities.push(this.viewer.entities.add({
                    id: `prop_rx_${pathId}`,
                    position: Cesium.Cartesian3.fromDegrees(rx.lon, rx.lat, rx.height_m),
                    point: {
                        pixelSize: 14,
                        color: rxColor,
                        outlineColor: Cesium.Color.WHITE,
                        outlineWidth: 2
                    },
                    label: {
                        text: `RX: ${analysis.linkBudget.receivedPower_dbm.toFixed(1)} dBm\nMargin: ${analysis.linkBudget.linkMargin_db.toFixed(1)} dB`,
                        font: '10px sans-serif',
                        fillColor: rxColor,
                        outlineColor: Cesium.Color.BLACK,
                        outlineWidth: 2,
                        style: Cesium.LabelStyle.FILL_AND_OUTLINE,
                        verticalOrigin: Cesium.VerticalOrigin.BOTTOM,
                        pixelOffset: new Cesium.Cartesian2(0, -20)
                    }
                }));
                
                // Path line (color based on link quality)
                const pathColor = analysis.linkBudget.linkViable 
                    ? Cesium.Color.GREEN.withAlpha(0.7)
                    : Cesium.Color.RED.withAlpha(0.7);
                    
                entities.push(this.viewer.entities.add({
                    id: `prop_path_${pathId}`,
                    polyline: {
                        positions: Cesium.Cartesian3.fromDegreesArrayHeights([
                            tx.lon, tx.lat, tx.height_m,
                            rx.lon, rx.lat, rx.height_m
                        ]),
                        width: 3,
                        material: analysis.linkBudget.linkViable
                            ? pathColor
                            : new Cesium.PolylineDashMaterialProperty({
                                color: pathColor,
                                dashLength: 16.0
                            })
                    }
                }));
                
                // Mark obstructions if any
                if (analysis.fresnelClearance.obstructions.length > 0) {
                    analysis.fresnelClearance.obstructions.forEach((obs, idx) => {
                        const fraction = obs.distance_m / analysis.geometry.distance_m;
                        const obsLat = tx.lat + (rx.lat - tx.lat) * fraction;
                        const obsLon = tx.lon + (rx.lon - tx.lon) * fraction;
                        
                        entities.push(this.viewer.entities.add({
                            id: `prop_obs_${pathId}_${idx}`,
                            position: Cesium.Cartesian3.fromDegrees(obsLon, obsLat, obs.height + 10),
                            point: {
                                pixelSize: 8,
                                color: Cesium.Color.ORANGE
                            },
                            label: {
                                text: `⚠`,
                                font: '14px sans-serif',
                                fillColor: Cesium.Color.ORANGE
                            }
                        }));
                    });
                }
                
                // Store path data
                this.propagationPaths[pathId] = {
                    id: pathId,
                    tx: tx,
                    rx: rx,
                    analysis: analysis,
                    entities: entities,
                    timestamp: Date.now()
                };
                
                return analysis;
            },
            
            /**
             * Remove a propagation path visualization
             */
            removePropagationPath: function(pathId) {
                const path = this.propagationPaths[pathId];
                if (!path) return;
                
                const list = Array.isArray(path.entities) ? path.entities
                             : path.entities?.values ? path.entities.values
                             : [];
                list.forEach(entity => {
                    if (this.viewer.entities.contains(entity)) {
                        this.viewer.entities.remove(entity);
                    }
                });
                
                delete this.propagationPaths[pathId];
            },
            
            /**
             * Clear all propagation paths
             */
            clearAllPaths: function() {
                Object.keys(this.propagationPaths).forEach(id => {
                    this.removePropagationPath(id);
                });
            },
            
            // Helper: Haversine distance
            _haversineDistance: function(lat1, lon1, lat2, lon2) {
                const R = this.CONSTANTS.EARTH_RADIUS_M;
                const dLat = (lat2 - lat1) * Math.PI / 180;
                const dLon = (lon2 - lon1) * Math.PI / 180;
                const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                          Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                          Math.sin(dLon/2) * Math.sin(dLon/2);
                const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
                return R * c;
            },
            
            // Helper: Calculate bearing
            _calculateBearing: function(lat1, lon1, lat2, lon2) {
                const dLon = (lon2 - lon1) * Math.PI / 180;
                const y = Math.sin(dLon) * Math.cos(lat2 * Math.PI / 180);
                const x = Math.cos(lat1 * Math.PI / 180) * Math.sin(lat2 * Math.PI / 180) -
                          Math.sin(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) * Math.cos(dLon);
                let brng = Math.atan2(y, x) * 180 / Math.PI;
                return (brng + 360) % 360;
            }
        };
        
        // Make globally available
        window.RFPropagationManager = RFPropagationManager;

        // =====================================================================
        // VIEWSHED MANAGER - Line-of-Sight Analysis for RF Propagation
        // Enhanced with terrain-aware propagation integration
        // =====================================================================
        
        const ViewshedManager = {
            viewer: null,
            viewsheds: {},
            raycastEntities: [],
            enabled: false,
            propagationManager: null,  // Reference to RFPropagationManager
            
            // Default viewshed parameters
            DEFAULT_CONFIG: {
                horizontalFov: 60,      // degrees
                verticalFov: 45,        // degrees
                distance: 20000,        // meters
                visibleColor: Cesium.Color.GREEN.withAlpha(0.25),
                hiddenColor: Cesium.Color.RED.withAlpha(0.25),
                lineColor: Cesium.Color.YELLOW.withAlpha(0.6),
                rayCount: 36,           // Number of rays per viewshed
                verticalRays: 8         // Vertical resolution
            },
            
            initialize: function(cesiumViewer) {
                this.viewer = cesiumViewer;
                
                // Link to RFPropagationManager for terrain-aware LOS
                if (window.RFPropagationManager) {
                    this.propagationManager = window.RFPropagationManager;
                    if (cesiumViewer) {
                        this.propagationManager.initialize(cesiumViewer);
                    }
                    console.log('ViewshedManager initialized with terrain-aware propagation');
                } else {
                    console.log('ViewshedManager initialized (no propagation manager available)');
                }
                return this;
            },
            
            /**
             * Create a viewshed from an observer position
             * @param {string} id - Unique identifier for this viewshed
             * @param {Object} options - Viewshed configuration
             */
            createViewshed: function(id, options) {
                if (!this.viewer) return null;
                
                const config = Object.assign({}, this.DEFAULT_CONFIG, options);
                
                const viewshed = {
                    id: id,
                    position: Cesium.Cartesian3.fromDegrees(
                        config.lon, 
                        config.lat, 
                        config.height || 100
                    ),
                    direction: config.direction || 0,
                    horizontalFov: config.horizontalFov,
                    verticalFov: config.verticalFov,
                    distance: config.distance,
                    visibleColor: config.visibleColor,
                    hiddenColor: config.hiddenColor,
                    entities: [],
                    visible: true
                };
                
                // Create visual representation
                this._createViewshedVisualization(viewshed, config);
                
                this.viewsheds[id] = viewshed;
                console.log(`Viewshed created: ${id}`);
                
                return viewshed;
            },
            
            /**
             * Create the visual elements for a viewshed
             */
            _createViewshedVisualization: function(viewshed, config) {
                if (!this.viewer) return;
                
                const position = viewshed.position;
                const direction = viewshed.direction;
                const hFov = viewshed.horizontalFov;
                const vFov = viewshed.verticalFov;
                const distance = viewshed.distance;
                
                // Observer point marker
                const observerEntity = this.viewer.entities.add({
                    id: `viewshed_observer_${viewshed.id}`,
                    position: position,
                    point: {
                        pixelSize: 12,
                        color: Cesium.Color.CYAN,
                        outlineColor: Cesium.Color.WHITE,
                        outlineWidth: 2
                    },
                    label: {
                        text: `📡 LOS: ${viewshed.id}`,
                        font: '11px sans-serif',
                        fillColor: Cesium.Color.CYAN,
                        outlineColor: Cesium.Color.BLACK,
                        outlineWidth: 2,
                        style: Cesium.LabelStyle.FILL_AND_OUTLINE,
                        verticalOrigin: Cesium.VerticalOrigin.BOTTOM,
                        pixelOffset: new Cesium.Cartesian2(0, -15)
                    }
                });
                viewshed.entities.push(observerEntity);
                
                // Create coverage cone/wedge
                const coneEntity = this._createCoverageWedge(viewshed, config);
                if (coneEntity) viewshed.entities.push(coneEntity);
                
                // Cast rays and create LOS lines
                this._castViewshedRays(viewshed, config);
            },
            
            /**
             * Create a wedge/cone showing the FOV coverage area
             */
            _createCoverageWedge: function(viewshed, config) {
                const cartographic = Cesium.Cartographic.fromCartesian(viewshed.position);
                const lon = Cesium.Math.toDegrees(cartographic.longitude);
                const lat = Cesium.Math.toDegrees(cartographic.latitude);
                const height = cartographic.height;
                
                // Calculate arc points for the wedge
                const points = [];
                const startAngle = viewshed.direction - viewshed.horizontalFov / 2;
                const endAngle = viewshed.direction + viewshed.horizontalFov / 2;
                const segments = 24;
                
                // Add center point
                points.push(lon, lat);
                
                // Add arc points
                for (let i = 0; i <= segments; i++) {
                    const angle = startAngle + (endAngle - startAngle) * (i / segments);
                    const rad = Cesium.Math.toRadians(angle);
                    const distDeg = viewshed.distance / 111320; // approximate meters to degrees
                    
                    const arcLon = lon + distDeg * Math.sin(rad);
                    const arcLat = lat + distDeg * Math.cos(rad);
                    points.push(arcLon, arcLat);
                }
                
                // Close the polygon
                points.push(lon, lat);
                
                try {
                    return this.viewer.entities.add({
                        id: `viewshed_coverage_${viewshed.id}`,
                        polygon: {
                            hierarchy: Cesium.Cartesian3.fromDegreesArray(points),
                            material: viewshed.visibleColor,
                            outline: true,
                            outlineColor: config.lineColor,
                            outlineWidth: 2,
                            height: height,
                            heightReference: Cesium.HeightReference.RELATIVE_TO_GROUND
                        }
                    });
                } catch (error) {
                    console.warn('Error creating coverage wedge:', error);
                    return null;
                }
            },
            
            /**
             * Cast rays from observer to determine LOS
             * Uses synchronous terrain estimation for immediate visualization
             */
            _castViewshedRays: function(viewshed, config) {
                const cartographic = Cesium.Cartographic.fromCartesian(viewshed.position);
                const observerLon = Cesium.Math.toDegrees(cartographic.longitude);
                const observerLat = Cesium.Math.toDegrees(cartographic.latitude);
                const observerHeight = cartographic.height;
                
                const startAngle = viewshed.direction - viewshed.horizontalFov / 2;
                const angleStep = viewshed.horizontalFov / (config.rayCount - 1);
                
                // Track statistics for logging
                let blockedCount = 0;
                let clearCount = 0;
                
                // Cast horizontal rays
                for (let i = 0; i < config.rayCount; i++) {
                    const angle = startAngle + angleStep * i;
                    const rad = Cesium.Math.toRadians(angle);
                    const distDeg = viewshed.distance / 111320;
                    
                    const endLon = observerLon + distDeg * Math.sin(rad);
                    const endLat = observerLat + distDeg * Math.cos(rad);
                    
                    // Perform terrain occlusion check (synchronous for immediate rendering)
                    const losResult = this._checkLineOfSightSync(
                        observerLon, observerLat, observerHeight,
                        endLon, endLat, 0,
                        config
                    );
                    
                    if (losResult.blocked) {
                        blockedCount++;
                    } else {
                        clearCount++;
                    }
                    
                    // Create ray visualization
                    const rayEntity = this.viewer.entities.add({
                        id: `viewshed_ray_${viewshed.id}_${i}`,
                        polyline: {
                            positions: Cesium.Cartesian3.fromDegreesArrayHeights([
                                observerLon, observerLat, observerHeight,
                                losResult.endLon, losResult.endLat, losResult.endHeight
                            ]),
                            width: 1,
                            material: losResult.blocked 
                                ? new Cesium.PolylineDashMaterialProperty({
                                    color: viewshed.hiddenColor,
                                    dashLength: 8.0
                                })
                                : viewshed.visibleColor
                        }
                    });
                    
                    viewshed.entities.push(rayEntity);
                }
                
                // Log viewshed analysis metrics
                if (window.logMetric) {
                    window.logMetric('viewshed', 'rays_cast', config.rayCount);
                    window.logMetric('viewshed', 'rays_blocked', blockedCount);
                    window.logMetric('viewshed', 'rays_clear', clearCount);
                    window.logMetric('viewshed', 'visibility_percent', (clearCount / config.rayCount) * 100);
                }
            },
            
            /**
             * Check line of sight between two points using terrain-aware propagation
             * Enhanced with ITU-R P.452 style terrain analysis
             */
            _checkLineOfSight: async function(startLon, startLat, startHeight, endLon, endLat, endHeight, config) {
                const distance = this._haversineDistance(startLat, startLon, endLat, endLon);
                const maxRange = config.distance;
                
                // Use RFPropagationManager if available for terrain-aware analysis
                if (this.propagationManager && this.propagationManager.viewer) {
                    try {
                        // Sample terrain along the ray path
                        const tx = { lat: startLat, lon: startLon, height_m: startHeight };
                        const rx = { lat: endLat, lon: endLon, height_m: endHeight || 2 };
                        
                        const terrainProfile = await this.propagationManager._sampleTerrainProfile(tx, rx);
                        
                        if (terrainProfile && terrainProfile.length > 2) {
                            // Check for terrain obstructions along the path
                            for (let i = 1; i < terrainProfile.length - 1; i++) {
                                const point = terrainProfile[i];
                                const fraction = point.distance_m / distance;
                                
                                // Calculate expected LOS height at this point
                                const losHeight = startHeight + (endHeight - startHeight) * fraction;
                                
                                // Check if terrain is above LOS
                                if (point.height > losHeight) {
                                    // Terrain obstruction found
                                    return {
                                        blocked: true,
                                        endLon: point.lon,
                                        endLat: point.lat,
                                        endHeight: point.height,
                                        obstruction: {
                                            distance_m: point.distance_m,
                                            terrainHeight: point.height,
                                            losHeight: losHeight,
                                            excess_m: point.height - losHeight
                                        }
                                    };
                                }
                            }
                            
                            // No terrain obstruction found
                            return {
                                blocked: false,
                                endLon: endLon,
                                endLat: endLat,
                                endHeight: endHeight,
                                terrainSamples: terrainProfile.length
                            };
                        }
                    } catch (error) {
                        console.warn('[ViewshedManager] Terrain sampling failed, using fallback:', error);
                    }
                }
                
                // Fallback: Distance-based attenuation with probabilistic terrain modeling
                // This simulates terrain effects when actual terrain data is unavailable
                const blocked = distance > maxRange * 0.6 && Math.random() > 0.7;
                
                if (blocked) {
                    const ratio = 0.4 + Math.random() * 0.3;
                    return {
                        blocked: true,
                        endLon: startLon + (endLon - startLon) * ratio,
                        endLat: startLat + (endLat - startLat) * ratio,
                        endHeight: startHeight * (1 - ratio),
                        fallback: true
                    };
                }
                
                return {
                    blocked: false,
                    endLon: endLon,
                    endLat: endLat,
                    endHeight: endHeight,
                    fallback: true
                };
            },
            
            /**
             * Synchronous version for immediate ray casting
             */
            _checkLineOfSightSync: function(startLon, startLat, startHeight, endLon, endLat, endHeight, config) {
                const distance = this._haversineDistance(startLat, startLon, endLat, endLon);
                const maxRange = config.distance;
                
                // Use estimated elevation along the path
                if (this.propagationManager) {
                    const numSamples = 10;
                    for (let i = 1; i < numSamples; i++) {
                        const fraction = i / numSamples;
                        const pointLat = startLat + (endLat - startLat) * fraction;
                        const pointLon = startLon + (endLon - startLon) * fraction;
                        const pointDist = distance * fraction;
                        
                        const losHeight = startHeight + (endHeight - startHeight) * fraction;
                        const terrainHeight = this.propagationManager._estimateElevation(pointLat, pointLon);
                        
                        if (terrainHeight > losHeight) {
                            return {
                                blocked: true,
                                endLon: pointLon,
                                endLat: pointLat,
                                endHeight: terrainHeight,
                                obstruction: { distance_m: pointDist, terrainHeight, losHeight }
                            };
                        }
                    }
                    
                    return { blocked: false, endLon, endLat, endHeight };
                }
                
                // Basic probabilistic fallback
                const blocked = distance > maxRange * 0.6 && Math.random() > 0.7;
                
                if (blocked) {
                    const ratio = 0.4 + Math.random() * 0.3;
                    return {
                        blocked: true,
                        endLon: startLon + (endLon - startLon) * ratio,
                        endLat: startLat + (endLat - startLat) * ratio,
                        endHeight: startHeight * (1 - ratio)
                    };
                }
                
                return { blocked: false, endLon, endLat, endHeight };
            },
            
            /**
             * Calculate haversine distance between two points
             */
            _haversineDistance: function(lat1, lon1, lat2, lon2) {
                const R = 6371000; // Earth radius in meters
                const dLat = Cesium.Math.toRadians(lat2 - lat1);
                const dLon = Cesium.Math.toRadians(lon2 - lon1);
                const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                          Math.cos(Cesium.Math.toRadians(lat1)) * Math.cos(Cesium.Math.toRadians(lat2)) *
                          Math.sin(dLon/2) * Math.sin(dLon/2);
                const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
                return R * c;
            },
            
            /**
             * Create viewshed for a recon entity
             */
            createEntityViewshed: function(entity) {
                if (!entity || !entity.location) return null;
                
                const id = `entity_${entity.entity_id}`;
                const heading = entity.velocity ? entity.velocity.heading_deg : 0;
                
                return this.createViewshed(id, {
                    lat: entity.location.lat,
                    lon: entity.location.lon,
                    height: entity.location.altitude_m || 100,
                    direction: heading,
                    horizontalFov: entity.ontology && entity.ontology.includes('radar') ? 90 : 60,
                    distance: entity.ontology && entity.ontology.includes('radar') ? 50000 : 20000
                });
            },
            
            /**
             * Create viewshed for a cell tower (360° coverage)
             */
            createTowerViewshed: function(tower) {
                if (!tower || !tower.position) return null;
                
                const id = `tower_${tower.name || 'unknown'}`;
                
                return this.createViewshed(id, {
                    lat: tower.position[1],
                    lon: tower.position[0],
                    height: tower.height || 50,
                    direction: 0,
                    horizontalFov: 360,
                    distance: tower.range || 15000
                });
            },
            
            /**
             * Update viewshed position and direction
             */
            updateViewshed: function(id, options) {
                const viewshed = this.viewsheds[id];
                if (!viewshed) return;
                
                // Remove old visualization
                this.removeViewshed(id);
                
                // Create new one with updated options
                const existingConfig = {
                    horizontalFov: viewshed.horizontalFov,
                    verticalFov: viewshed.verticalFov,
                    distance: viewshed.distance
                };
                
                this.createViewshed(id, Object.assign(existingConfig, options));
            },
            
            /**
             * Toggle viewshed visibility
             */
            setViewshedVisible: function(id, visible) {
                const viewshed = this.viewsheds[id];
                if (!viewshed) return;
                
                viewshed.visible = visible;
                const list = Array.isArray(viewshed.entities) ? viewshed.entities
                             : viewshed.entities?.values ? viewshed.entities.values
                             : [];
                list.forEach(entity => {
                    entity.show = visible;
                });
            },
            
            /**
             * Remove a viewshed
             */
            removeViewshed: function(id) {
                const viewshed = this.viewsheds[id];
                if (!viewshed) return;
                
                const list = Array.isArray(viewshed.entities) ? viewshed.entities
                             : viewshed.entities?.values ? viewshed.entities.values
                             : [];
                list.forEach(entity => {
                    if (this.viewer.entities.contains(entity)) {
                        this.viewer.entities.remove(entity);
                    }
                });
                
                delete this.viewsheds[id];
                console.log(`Viewshed removed: ${id}`);
            },
            
            /**
             * Remove all viewsheds
             */
            clearAllViewsheds: function() {
                Object.keys(this.viewsheds).forEach(id => {
                    this.removeViewshed(id);
                });
            },
            
            /**
             * Get all active viewsheds
             */
            getActiveViewsheds: function() {
                return Object.values(this.viewsheds).filter(v => v.visible);
            }
        };
        
        // Make globally available
        window.ViewshedManager = ViewshedManager;

        // =====================================================================
        // AIS VESSEL VISUALIZATION
        // =====================================================================
        
        const AISVisualization = {
            viewer: null,
            vessels: {},
            vesselEntities: {},
            trailEntities: {},
            visible: false,
            showTrails: true,
            showLabels: true,
            autoUpdate: false,
            updateInterval: null,
            correlations: [],
            
            // Vessel type filtering
            vesselTypeFilters: ['Cargo', 'Tanker', 'Passenger', 'Fishing', 'Tug', 'Pilot', 'Other'],
            availableVesselTypes: new Set(),
            // Pagination state for server-side vessel listing
            currentPage: 1,
            perPage: 100,
            
            // Clustering support
            dataSource: null,
            clusteringEnabled: true,
            quadtree: null,
            
            initialize: function(cesiumViewer) {
                this.viewer = cesiumViewer;
                console.log('AIS Visualization initialized');
                
                // Setup clustered data source if HierarchicalRenderManager is available
                if (typeof HierarchicalRenderManager !== 'undefined' && HierarchicalRenderManager.viewer) {
                    this.dataSource = HierarchicalRenderManager.createClusteredDataSource('AIS_Vessels', {
                        pixelRange: 50,
                        minimumClusterSize: 3
                    });
                    
                    // Setup custom cluster styling for AIS
                    this.setupClusterStyling();
                }
                
                // Setup event listeners
                this.setupEventListeners();
                
                // Listen for altitude changes
                this.setupAltitudeListener();
                
                return this;
            },
            
            setupClusterStyling: function() {
                if (!this.dataSource) return;
                
                const self = this;
                
                this.dataSource.clustering.clusterEvent.addEventListener(function(clusteredEntities, cluster) {
                    // Count vessel types in cluster
                    let cargo = 0, tanker = 0, passenger = 0, other = 0;
                    let hasViolation = false;
                    
                    clusteredEntities.forEach(entity => {
                        const props = entity.properties;
                        if (props && props.vesselData) {
                            const typeNum = parseInt(props.vesselData.getValue().vessel_type || 0);
                            if (typeNum >= 70 && typeNum <= 79) cargo++;
                            else if (typeNum >= 80 && typeNum <= 89) tanker++;
                            else if (typeNum >= 60 && typeNum <= 69) passenger++;
                            else other++;
                            
                            if (props.rfCorrelation && props.rfCorrelation.getValue() && 
                                props.rfCorrelation.getValue().violation) {
                                hasViolation = true;
                            }
                        }
                    });
                    
                    // Determine cluster color based on composition
                    let clusterColor;
                    if (hasViolation) {
                        clusterColor = Cesium.Color.RED;
                    } else if (tanker > cargo && tanker > passenger) {
                        clusterColor = Cesium.Color.YELLOW;
                    } else if (cargo > tanker && cargo > passenger) {
                        clusterColor = Cesium.Color.ORANGE;
                    } else if (passenger > 0) {
                        clusterColor = Cesium.Color.LIME;
                    } else {
                        clusterColor = Cesium.Color.CYAN;
                    }
                    
                    // Style the cluster
                    cluster.label.text = clusteredEntities.length.toString();
                    cluster.label.font = 'bold 12px sans-serif';
                    cluster.label.fillColor = Cesium.Color.WHITE;
                    cluster.label.outlineColor = Cesium.Color.BLACK;
                    cluster.label.outlineWidth = 2;
                    cluster.label.style = Cesium.LabelStyle.FILL_AND_OUTLINE;
                    cluster.label.verticalOrigin = Cesium.VerticalOrigin.CENTER;
                    cluster.label.horizontalOrigin = Cesium.HorizontalOrigin.CENTER;
                    
                    // Create cluster icon
                    cluster.billboard.image = self.createClusterIcon(clusteredEntities.length, clusterColor);
                    cluster.billboard.width = 36;
                    cluster.billboard.height = 36;
                });
            },
            
            createClusterIcon: function(count, color) {
                const size = Math.min(50, 30 + count);
                const canvas = document.createElement('canvas');
                canvas.width = size;
                canvas.height = size;
                const ctx = canvas.getContext('2d');
                
                // Outer circle
                ctx.beginPath();
                ctx.arc(size/2, size/2, size/2 - 2, 0, 2 * Math.PI);
                ctx.fillStyle = color.withAlpha(0.8).toCssColorString();
                ctx.fill();
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // Ship icon in center
                ctx.fillStyle = 'white';
                ctx.font = `${size/3}px sans-serif`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('⛴', size/2, size/2);
                
                return canvas.toDataURL();
            },
            
            setupAltitudeListener: function() {
                const self = this;
                
                document.addEventListener('altitudeChanged', function(e) {
                    if (!self.visible) return;
                    
                    const shouldShowLabels = HierarchicalRenderManager.shouldShowDetail('labels');
                    const shouldShowTrails = HierarchicalRenderManager.shouldShowDetail('trails');
                    
                    // Update visibility based on altitude
                    if (self.showLabels !== shouldShowLabels) {
                        self.updateLabelVisibility(shouldShowLabels);
                    }
                    
                    if (self.showTrails && !shouldShowTrails) {
                        self.updateTrailVisibility(false);
                    } else if (self.showTrails && shouldShowTrails) {
                        self.updateTrailVisibility(true);
                    }
                });
            },
            
            setupEventListeners: function() {
                const self = this;
                
                // Toggle AIS vessels
                const aisToggle = document.getElementById('toggleAISVessels');
                if (aisToggle) {
                    aisToggle.addEventListener('change', function(e) {
                        if (e.target.checked) {
                            self.show();
                            // Start real-time streaming if available
                            if (window.AISStreamManager) {
                                AISStreamManager.checkAndStartStream();
                            }
                        } else {
                            self.hide();
                            // Stop streaming
                            if (window.AISStreamManager) {
                                AISStreamManager.stopStreaming();
                            }
                        }
                    });
                }
                
                // Show/hide trails
                const trailsToggle = document.getElementById('aisShowTrails');
                if (trailsToggle) {
                    trailsToggle.addEventListener('change', function(e) {
                        self.showTrails = e.target.checked;
                        self.updateTrailVisibility();
                    });
                }
                
                // Show/hide labels
                const labelsToggle = document.getElementById('aisShowLabels');
                if (labelsToggle) {
                    labelsToggle.addEventListener('change', function(e) {
                        self.showLabels = e.target.checked;
                        self.updateLabelVisibility();
                    });
                }
                
                // Auto-update toggle
                const autoUpdateToggle = document.getElementById('aisAutoUpdate');
                if (autoUpdateToggle) {
                    autoUpdateToggle.addEventListener('change', function(e) {
                        self.autoUpdate = e.target.checked;
                        if (self.autoUpdate) {
                            self.startAutoUpdate();
                        } else {
                            self.stopAutoUpdate();
                        }
                    });
                }
                
                // RF Correlation button
                const correlateBtn = document.getElementById('aisCorrelateRF');
                if (correlateBtn) {
                    correlateBtn.addEventListener('click', function() {
                        self.correlateWithRF();
                    });
                }
                
                // Vessel type filter checkboxes
                const typeFilters = document.querySelectorAll('.vesselTypeFilter');
                typeFilters.forEach(checkbox => {
                    checkbox.addEventListener('change', function(e) {
                        const type = e.target.value;
                        if (e.target.checked) {
                            if (!self.vesselTypeFilters.includes(type)) {
                                self.vesselTypeFilters.push(type);
                            }
                        } else {
                            self.vesselTypeFilters = self.vesselTypeFilters.filter(t => t !== type);
                        }
                        self.applyVesselTypeFilters();
                    });
                });
                
                // Select all vessel types
                const selectAllBtn = document.getElementById('aisSelectAllTypes');
                if (selectAllBtn) {
                    selectAllBtn.addEventListener('click', function() {
                        self.vesselTypeFilters = Array.from(self.availableVesselTypes);
                        document.querySelectorAll('.vesselTypeFilter').forEach(cb => {
                            cb.checked = true;
                        });
                        self.applyVesselTypeFilters();
                    });
                }
                
                // Clear all vessel types
                const clearAllBtn = document.getElementById('aisClearAllTypes');
                if (clearAllBtn) {
                    clearAllBtn.addEventListener('click', function() {
                        self.vesselTypeFilters = [];
                        document.querySelectorAll('.vesselTypeFilter').forEach(cb => {
                            cb.checked = false;
                        });
                        self.applyVesselTypeFilters();
                    });
                }
                
                // AIS Search functionality
                const searchBtn = document.getElementById('aisSearchBtn');
                if (searchBtn) {
                    searchBtn.addEventListener('click', function() {
                        const query = document.getElementById('aisSearchInput').value.trim();
                        const vesselType = document.getElementById('aisSearchType').value;
                        self.searchRecords(query, vesselType);
                    });
                }
                
                // Search input enter key
                const searchInput = document.getElementById('aisSearchInput');
                if (searchInput) {
                    searchInput.addEventListener('keypress', function(e) {
                        if (e.key === 'Enter') {
                            const query = searchInput.value.trim();
                            const vesselType = document.getElementById('aisSearchType').value;
                            self.searchRecords(query, vesselType);
                        }
                    });
                }
                
                // Clear search
                const clearSearchBtn = document.getElementById('aisClearSearchBtn');
                if (clearSearchBtn) {
                    clearSearchBtn.addEventListener('click', function() {
                        self.clearSearch();
                    });
                }
                
                // Search in visible area
                const searchInAreaBtn = document.getElementById('aisSearchInArea');
                if (searchInAreaBtn) {
                    searchInAreaBtn.addEventListener('click', function() {
                        self.searchInVisibleArea();
                    });
                }
                // Load all AIS records button
                const loadAllBtn = document.getElementById('aisLoadAllRecords');
                if (loadAllBtn) {
                    loadAllBtn.addEventListener('click', function() {
                        if (!confirm('Load ALL AIS records (~13k). This may be slow. Continue?')) return;
                        self.loadAllRecords();
                    });
                }
            },
            
            show: function() {
                this.visible = true;
                document.getElementById('aisFilters').style.display = 'block';
                this.loadVessels();
            },
            
            hide: function() {
                this.visible = false;
                document.getElementById('aisFilters').style.display = 'none';
                this.clearAllEntities();
                this.stopAutoUpdate();
            },
            
            // Load AIS vessel list asynchronously (supports pagination)
            loadVessels: async function(page, per_page) {
                try {
                    addConsoleMessage('Loading AIS vessel data...', 'command');
                    // Build request URL with optional pagination params
                    let url = '/api/ais/vessels';
                    const params = [];
                    if (page && Number.isInteger(page) && page > 0) params.push(`page=${page}`);
                    if (per_page && Number.isInteger(per_page) && per_page > 0) params.push(`per_page=${per_page}`);
                    if (params.length) url += '?' + params.join('&');

                    const response = await fetch(url);
                    const data = await response.json();
                    
                    if (data.status === 'ok') {
                        this.vessels = {};
                        data.vessels.forEach(v => {
                            this.vessels[v.mmsi] = v;
                        });
                        
                        // Update count display
                        const countEl = document.getElementById('ais-vessel-count');
                        if (countEl) {
                            countEl.textContent = data.vessel_count;
                        }
                        
                        // Update available vessel types
                        this.updateAvailableVesselTypes();
                        
                        // Render vessels on map
                        this.renderVessels();
                        addConsoleMessage(`Loaded ${data.vessel_count} AIS vessels`, 'response');
                        showNotification('AIS Data Loaded', `Tracking ${data.vessel_count} vessels`, 'info');

                        // Handle pagination UI if provided
                        const pagDiv = document.getElementById('aisVesselsPagination');
                        if (data.pagination && pagDiv) {
                            pagDiv.style.display = 'block';
                            this.currentPage = data.pagination.page || ((data.pagination.offset || 0) / data.pagination.per_page + 1);
                            this.perPage = data.pagination.per_page || this.perPage || 100;
                            const info = document.getElementById('aisPageInfo');
                            if (info) info.textContent = `Page ${this.currentPage} of ${data.pagination.total_pages}`;

                            // Wire up buttons (assign directly to avoid duplicate listeners)
                            const prev = document.getElementById('aisPrevPage');
                            const next = document.getElementById('aisNextPage');
                            const perInput = document.getElementById('aisPerPageInput');

                            if (perInput) {
                                perInput.value = this.perPage;
                                perInput.onchange = (e) => {
                                    const newPer = parseInt(e.target.value) || 100;
                                    this.loadVessels(1, newPer);
                                };
                            }

                            if (prev) prev.onclick = () => {
                                const np = Math.max(1, (this.currentPage || 1) - 1);
                                this.loadVessels(np, this.perPage);
                            };
                            if (next) next.onclick = () => {
                                const np = Math.min(data.pagination.total_pages || (this.currentPage + 1), (this.currentPage || 1) + 1);
                                this.loadVessels(np, this.perPage);
                            };
                        } else if (pagDiv) {
                            // Hide pagination if backend didn't provide it
                            pagDiv.style.display = 'none';
                        }
                    } else {
                        console.error('Failed to load AIS data:', data);
                        addConsoleMessage('Failed to load AIS vessel data', 'alert');
                    }
                } catch (error) {
                    console.error('Error loading AIS vessels:', error);
                    addConsoleMessage('Error loading AIS vessels: ' + error.message, 'alert');
                }
            },
            
            renderVessels: function() {
                if (!this.viewer || !this.visible) return;
                
                // Clear existing entities
                this.clearAllEntities();
                
                // Build quadtree for spatial queries
                if (typeof HierarchicalRenderManager !== 'undefined') {
                    this.quadtree = HierarchicalRenderManager.createQuadtree(
                        Object.values(this.vessels).map(v => ({
                            id: v.mmsi,
                            lat: v.lat,
                            lon: v.lon,
                            data: v
                        }))
                    );
                }
                
                // Render each vessel (filtered by type)
                Object.values(this.vessels).forEach(vessel => {
                    const vesselType = this._normalizeVesselType(vessel.vessel_type);
                    if (this.vesselTypeFilters.includes(vesselType)) {
                        this.addVesselEntity(vessel);
                    }
                });
            },
            
            addVesselEntity: function(vessel) {
                if (!this.viewer) return;
                
                const mmsi = vessel.mmsi;
                const lat = vessel.lat;
                const lon = vessel.lon;
                const heading = vessel.heading || vessel.cog || 0;
                const name = vessel.name || 'Unknown';
                const sog = vessel.sog || 0;
                
                // Determine vessel color based on type or speed
                let vesselColor = Cesium.Color.CYAN;
                if (vessel.vessel_type) {
                    const typeNum = parseInt(vessel.vessel_type);
                    if (typeNum >= 60 && typeNum <= 69) vesselColor = Cesium.Color.LIME; // Passenger
                    else if (typeNum >= 70 && typeNum <= 79) vesselColor = Cesium.Color.ORANGE; // Cargo
                    else if (typeNum >= 80 && typeNum <= 89) vesselColor = Cesium.Color.YELLOW; // Tanker
                    else if (typeNum === 50) vesselColor = Cesium.Color.MAGENTA; // Pilot
                    else if (typeNum === 52) vesselColor = Cesium.Color.AQUA; // Tug
                }
                
                // Check for RF correlation (violation = red)
                const correlation = this.correlations.find(c => c.mmsi === mmsi);
                if (correlation && correlation.violation) {
                    vesselColor = Cesium.Color.RED;
                }
                
                // Use clustered data source if available, otherwise use viewer.entities
                const entityCollection = this.dataSource ? this.dataSource.entities : this.viewer.entities;
                
                try {
                    // Create vessel entity with ship-like appearance
                    const entity = entityCollection.add({
                        id: `ais_vessel_${mmsi}`,
                        name: `${name} (MMSI: ${mmsi})`,
                        position: Cesium.Cartesian3.fromDegrees(lon, lat, 0),
                        billboard: {
                            image: this.createVesselIcon(vesselColor, heading),
                            scale: 0.5,
                            verticalOrigin: Cesium.VerticalOrigin.CENTER,
                            horizontalOrigin: Cesium.HorizontalOrigin.CENTER,
                            rotation: Cesium.Math.toRadians(-heading),
                            alignedAxis: Cesium.Cartesian3.UNIT_Z
                        },
                        label: this.showLabels ? {
                            text: name,
                            font: '11px sans-serif',
                            fillColor: Cesium.Color.WHITE,
                            outlineColor: Cesium.Color.BLACK,
                            outlineWidth: 2,
                            style: Cesium.LabelStyle.FILL_AND_OUTLINE,
                            verticalOrigin: Cesium.VerticalOrigin.TOP,
                            pixelOffset: new Cesium.Cartesian2(0, 15),
                            show: this.showLabels
                        } : undefined,
                        description: this.createVesselDescription(vessel, correlation),
                        properties: {
                            type: 'ais_vessel',
                            mmsi: mmsi,
                            vesselData: vessel,
                            rfCorrelation: correlation
                        }
                    });
                    
                    this.vesselEntities[mmsi] = entity;
                    
                    // Add trail if we have history
                    if (this.showTrails && vessel.history_length > 1) {
                        this.loadVesselTrail(mmsi);
                    }
                    
                } catch (error) {
                    console.error(`Error adding vessel ${mmsi}:`, error);
                }
            },
            
            createVesselIcon: function(color, heading) {
                // Create a canvas-based ship icon
                const canvas = document.createElement('canvas');
                canvas.width = 32;
                canvas.height = 32;
                const ctx = canvas.getContext('2d');
                
                // Clear background
                ctx.clearRect(0, 0, 32, 32);
                
                // Draw ship shape (pointing up)
                ctx.save();
                ctx.translate(16, 16);
                
                ctx.beginPath();
                ctx.moveTo(0, -12); // Bow (front)
                ctx.lineTo(6, 8);   // Starboard stern
                ctx.lineTo(0, 4);   // Center stern
                ctx.lineTo(-6, 8);  // Port stern
                ctx.closePath();
                
                // Fill
                ctx.fillStyle = color.toCssColorString();
                ctx.fill();
                
                // Outline
                ctx.strokeStyle = '#FFFFFF';
                ctx.lineWidth = 1.5;
                ctx.stroke();
                
                ctx.restore();
                
                return canvas.toDataURL();
            },
            
            createVesselDescription: function(vessel, correlation) {
                let html = `
                    <div style="padding: 10px; font-family: sans-serif;">
                        <h3 style="margin: 0 0 10px 0; color: #00aaff;">🚢 ${vessel.name || 'Unknown Vessel'}</h3>
                        <table style="width: 100%; border-collapse: collapse;">
                            <tr><td style="padding: 3px; color: #888;">MMSI:</td><td style="padding: 3px;">${vessel.mmsi}</td></tr>
                            <tr><td style="padding: 3px; color: #888;">Position:</td><td style="padding: 3px;">${vessel.lat.toFixed(5)}°, ${vessel.lon.toFixed(5)}°</td></tr>
                            <tr><td style="padding: 3px; color: #888;">Speed:</td><td style="padding: 3px;">${vessel.sog ? vessel.sog.toFixed(1) + ' kts' : 'N/A'}</td></tr>
                            <tr><td style="padding: 3px; color: #888;">Course:</td><td style="padding: 3px;">${vessel.cog ? vessel.cog.toFixed(1) + '°' : 'N/A'}</td></tr>
                            <tr><td style="padding: 3px; color: #888;">Heading:</td><td style="padding: 3px;">${vessel.heading ? vessel.heading.toFixed(1) + '°' : 'N/A'}</td></tr>
                            <tr><td style="padding: 3px; color: #888;">Type:</td><td style="padding: 3px;">${vessel.vessel_type || 'Unknown'}</td></tr>
                            <tr><td style="padding: 3px; color: #888;">Length:</td><td style="padding: 3px;">${vessel.length ? vessel.length + ' m' : 'N/A'}</td></tr>
                        </table>
                        
                        <!-- Action buttons moved to main UI overlay to avoid iframe sandbox restrictions -->
                `;
                
                if (correlation) {
                    html += `
                        <div style="margin-top: 10px; padding: 8px; background: ${correlation.violation ? 'rgba(255,0,0,0.2)' : 'rgba(0,255,0,0.2)'}; border-radius: 4px;">
                            <h4 style="margin: 0 0 5px 0; color: ${correlation.violation ? '#ff4444' : '#44ff44'};">📡 RF Correlation</h4>
                            <table style="width: 100%; border-collapse: collapse;">
                                <tr><td style="padding: 2px; color: #888;">Frequency:</td><td style="padding: 2px;">${correlation.frequency?.toFixed(3)} MHz</td></tr>
                                <tr><td style="padding: 2px; color: #888;">Channel:</td><td style="padding: 2px;">${correlation.channel}</td></tr>
                                <tr><td style="padding: 2px; color: #888;">Power:</td><td style="padding: 2px;">${correlation.power?.toFixed(1)} dBm</td></tr>
                                ${correlation.violation ? `<tr><td style="padding: 2px; color: #ff4444;">Violation:</td><td style="padding: 2px; color: #ff4444;">${correlation.violation_type}</td></tr>` : ''}
                            </table>
                        </div>
                    `;
                }
                
                html += '</div>';
                return html;
            },
            
            // Promote an AIS vessel to a persistent Recon Entity
            promoteToRecon: function(mmsiOrVessel, correlation) {
                let vessel;
                let mmsi;
                
                if (typeof mmsiOrVessel === 'object') {
                    vessel = mmsiOrVessel;
                    mmsi = vessel.mmsi;
                } else {
                    mmsi = mmsiOrVessel;
                    vessel = this.vessels[mmsi];
                }

                if (!vessel) {
                    addConsoleMessage('Cannot promote: Vessel data not found for MMSI ' + mmsi, 'alert');
                    return;
                }
                
                // Ensure numeric values
                const lat = parseFloat(vessel.lat) || 0;
                const lon = parseFloat(vessel.lon) || 0;
                
                // Use deterministic entity_id based on MMSI to prevent duplicates
                const entityId = `AIS-${mmsi}`;
                
                const payload = {
                    entity_id: entityId,  // Deterministic ID for idempotent create-or-update
                    name: vessel.name || `Vessel ${mmsi}`,
                    type: 'RECON_ENTITY',  // Explicit type for proper entity_type resolution
                    location: {
                        lat: lat,
                        lon: lon,
                        altitude_m: 0
                    },
                    disposition: 'NEUTRAL',
                    ontology: 'naval_vessel',
                    source: 'ais_ui',
                    meta: {
                        mmsi: mmsi,
                        sog: vessel.sog,
                        cog: vessel.cog,
                        heading: vessel.heading,
                        type: vessel.vessel_type,
                        length: vessel.length || 0,
                        width: vessel.width || 0,
                        draft: vessel.draft || 0,
                        destination: vessel.destination || 'UNKNOWN'
                    }
                };
                
                addConsoleMessage(`Promoting ${vessel.name}...`, 'command');
                
                // Include session token for provenance tracking
                const headers = { 'Content-Type': 'application/json' };
                if (window.OperatorSession && window.OperatorSession.sessionToken) {
                    headers['X-Session-Token'] = window.OperatorSession.sessionToken;
                }
                
                fetch('/api/recon/entity', {
                    method: 'POST',
                    headers: headers,
                    body: JSON.stringify(payload)
                })
                .then(response => {
                    if (!response.ok) throw new Error(`Server returned ${response.status}`);
                    return response.json();
                })
                .then(data => {
                    if (data.status === 'ok') {
                        addConsoleMessage(`✅ Promoted ${vessel.name || mmsi} to Recon Entity`, 'success');
                        showNotification('Entity Promoted', `${vessel.name} is now a tracked Recon Entity`, 'success');
                        
                        // Add to Recon map if available
                        if (window.AutoReconVisualization && window.AutoReconVisualization.addEntityMarker) {
                            window.AutoReconVisualization.addEntityMarker(data.entity);
                        }
                        
                        // Switch to Recon view? User said "then Track it". 
                        // Assuming this means the Recon functionality should take over tracking.
                        // For now we stay on AIS but have it in DB.
                    } else {
                        throw new Error(data.message || 'Unknown error from server');
                    }
                })
                .catch(error => {
                    console.error('Error promoting vessel:', error);
                    addConsoleMessage('❌ Error promoting vessel: ' + error.message, 'alert');
                    showServerErrorToast(`Failed to save Recon Entity: ${error.message}`);
                });
            },

            // Promote ALL AIS vessels to Recon Entities
            promoteAllToRecon: async function() {
                const keys = Object.keys(this.vessels);
                if (keys.length === 0) {
                    showNotification('No Vessels', 'No AIS vessels available to promote.', 'warning');
                    return;
                }

                if (!confirm(`Are you sure you want to promote ALL ${keys.length} visible AIS vessels to Recon Entities? This may take a moment.`)) {
                    return;
                }

                addConsoleMessage(`Starting batch promotion of ${keys.length} vessels...`, 'command');
                showNotification('Batch Started', `Promoting ${keys.length} vessels...`, 'info');

                let count = 0;
                let errors = 0;

                // Process in chunks to be nice to the UI loop
                for (const mmsi of keys) {
                    try {
                        // Call promoteToRecon for each vessel
                        // We attach a silent flag or just let it log to console
                        await this._promoteToReconInternal(mmsi, true); 
                        count++;
                    } catch (e) {
                        console.warn(`Failed to promote ${mmsi}:`, e);
                        errors++;
                    }
                    
                    // Small delay every 5 items to keep UI responsive
                    if (count % 5 === 0) await new Promise(r => setTimeout(r, 50));
                }

                addConsoleMessage(`✅ Batch complete: ${count} promoted, ${errors} failed.`, 'success');
                showNotification('Batch Complete', `${count} vessels promoted to Recon.`, 'success');
            },

            // Internal helper that returns a promise (promoteToRecon doesn't return one currently)
            _promoteToReconInternal: function(mmsi, silent) {
                return new Promise((resolve, reject) => {
                    const vessel = this.vessels[mmsi];
                    if (!vessel) return reject('Vessel not found');
                    
                    // Use deterministic entity_id based on MMSI to prevent duplicates
                    const entityId = `AIS-${mmsi}`;
                    
                    const payload = {
                        entity_id: entityId,  // Deterministic ID for idempotent create-or-update
                        name: vessel.name || `Vessel ${mmsi}`,
                        type: 'RECON_ENTITY',  // Explicit type for proper entity_type resolution
                        location: { lat: parseFloat(vessel.lat)||0, lon: parseFloat(vessel.lon)||0, altitude_m: 0 },
                        disposition: 'NEUTRAL',
                        ontology: 'naval_vessel',
                        source: 'ais_ui_batch',
                        meta: { mmsi: mmsi, type: vessel.vessel_type }
                    };

                    // Include session token for provenance tracking
                    const headers = { 'Content-Type': 'application/json' };
                    if (window.OperatorSession && window.OperatorSession.sessionToken) {
                        headers['X-Session-Token'] = window.OperatorSession.sessionToken;
                    }

                    fetch('/api/recon/entity', {
                        method: 'POST',
                        headers: headers,
                        body: JSON.stringify(payload)
                    })
                    .then(r => r.json())
                    .then(data => {
                        if (data.status === 'ok') {
                            if(!silent) addConsoleMessage(`Promoted ${vessel.name}`, 'success');
                            if (window.AutoReconVisualization?.addEntityMarker && data.entity) {
                                window.AutoReconVisualization.addEntityMarker(data.entity);
                            }
                            resolve(data.entity);
                        } else {
                            reject(data.message);
                        }
                    })
                    .catch(reject);
                });
            },

            // Load the movement trail for a specific vessel asynchronously
            loadVesselTrail: async function(mmsi) {
                try {
                    const response = await fetch(`/api/ais/vessel/${mmsi}/history?limit=50`);
                    const data = await response.json();
                    
                    if (data.status === 'ok' && data.history.length > 1) {
                        const positions = data.history.map(h => 
                            Cesium.Cartesian3.fromDegrees(h.lon, h.lat, 0)
                        );
                        
                        const trailEntity = this.viewer.entities.add({
                            id: `ais_trail_${mmsi}`,
                            polyline: {
                                positions: positions,
                                width: 2,
                                material: new Cesium.PolylineGlowMaterialProperty({
                                    glowPower: 0.2,
                                    color: Cesium.Color.CYAN.withAlpha(0.6)
                                }),
                                clampToGround: true
                            }
                        });
                        
                        this.trailEntities[mmsi] = trailEntity;
                    }
                } catch (error) {
                    console.error(`Error loading trail for ${mmsi}:`, error);
                }
            },
            
            updateTrailVisibility: function() {
                Object.values(this.trailEntities).forEach(entity => {
                    entity.show = this.showTrails;
                });
            },
            
            updateLabelVisibility: function() {
                Object.values(this.vesselEntities).forEach(entity => {
                    if (entity.label) {
                        entity.label.show = this.showLabels;
                    }
                });
            },
            
            clearAllEntities: function() {
                // Clear from clustered data source if available
                if (this.dataSource) {
                    this.dataSource.entities.removeAll();
                }
                
                // Remove vessel entities from viewer
                Object.values(this.vesselEntities).forEach(entity => {
                    if (this.viewer && this.viewer.entities.contains(entity)) {
                        this.viewer.entities.remove(entity);
                    }
                });
                this.vesselEntities = {};
                
                // Remove trail entities
                Object.values(this.trailEntities).forEach(entity => {
                    if (this.viewer && this.viewer.entities.contains(entity)) {
                        this.viewer.entities.remove(entity);
                    }
                });
                this.trailEntities = {};
            },
            
            startAutoUpdate: function() {
                if (this.updateInterval) return;
                
                const self = this;
                this.updateInterval = setInterval(async function() {
                    if (!self.visible) return;
                    
                    try {
                        const response = await fetch('/api/ais/advance');
                        const data = await response.json();
                        
                        if (data.status === 'ok') {
                            // Update vessel positions
                            data.vessels.forEach(v => {
                                self.vessels[v.mmsi] = v;
                                self.updateVesselPosition(v);
                            });
                        }
                    } catch (error) {
                        console.error('Error updating AIS positions:', error);
                    }
                }, 1000); // Update every second
                
                addConsoleMessage('AIS auto-update started', 'command');
            },
            
            stopAutoUpdate: function() {
                if (this.updateInterval) {
                    clearInterval(this.updateInterval);
                    this.updateInterval = null;
                    addConsoleMessage('AIS auto-update stopped', 'command');
                }
            },
            
            updateVesselPosition: function(vessel) {
                const entity = this.vesselEntities[vessel.mmsi];
                if (!entity) return;
                
                entity.position = Cesium.Cartesian3.fromDegrees(vessel.lon, vessel.lat, 0);
                
                // Update heading rotation
                if (entity.billboard && vessel.heading) {
                    entity.billboard.rotation = Cesium.Math.toRadians(-vessel.heading);
                }
            },
            
            // Correlate current AIS vessel data with RF emissions asynchronously
            correlateWithRF: async function() {
                try {
                    addConsoleMessage('Correlating AIS vessels with RF emissions...', 'command');
                    
                    const response = await fetch('/api/ais/rf-correlation');
                    const data = await response.json();
                    
                    if (data.status === 'ok') {
                        this.correlations = data.correlations;
                        
                        // Re-render vessels with correlation data
                        this.renderVessels();
                        
                        // Report violations
                        const violations = data.correlations.filter(c => c.violation);
                        
                        if (violations.length > 0) {
                            addConsoleMessage(`⚠️ Found ${violations.length} RF violations from vessels!`, 'alert');
                            showNotification('RF Violations Detected', 
                                `${violations.length} vessels have RF compliance issues in the maritime VHF band.`,
                                'alert');
                            
                            // Add to violation list
                            violations.forEach(v => {
                                const vessel = this.vessels[v.mmsi];
                                if (vessel) {
                                    addCrossNetworkViolation({
                                        type: v.violation_type,
                                        frequency: `${v.frequency.toFixed(3)} MHz`,
                                        source: `${vessel.name} (MMSI: ${v.mmsi})`,
                                        path: ['AIS', v.channel, 'Maritime VHF']
                                    });
                                }
                            });
                        } else {
                            addConsoleMessage(`All ${data.correlation_count} detected vessels are RF compliant`, 'response');
                        }
                    }
                } catch (error) {
                    console.error('Error correlating with RF:', error);
                    addConsoleMessage('Error correlating AIS with RF: ' + error.message, 'alert');
                }
            },
            
            flyToVessel: function(mmsi) {
                // Validated Entity Retrieval: Check if entity exists, if not try to create it from known data
                let entity = this.vesselEntities[mmsi];
                if (!entity && this.vessels[mmsi]) {
                    console.log(`[flyToVessel] Entity for ${mmsi} missing, creating now...`);
                    this.addVesselEntity(this.vessels[mmsi]);
                    entity = this.vesselEntities[mmsi];
                }

                if (entity && this.viewer) {
                    const self = this;
                    this.viewer.flyTo(entity, {
                        duration: 1.5,
                        offset: new Cesium.HeadingPitchRange(0, Cesium.Math.toRadians(-45), 5000)
                    }).then(function() {
                        // Reset camera transform to re-enable user control
                        self.viewer.camera.lookAtTransform(Cesium.Matrix4.IDENTITY);
                        self.viewer.trackedEntity = undefined;
                        
                        const controller = self.viewer.scene.screenSpaceCameraController;
                        controller.enableRotate = true;
                        controller.enableTilt = true;
                        controller.enableZoom = true;
                        controller.enableTranslate = true;
                        controller.enableLook = true;
                    });
                } else {
                    console.warn(`[flyToVessel] Failed to fly to ${mmsi}, entity not found`);
                    addConsoleMessage(`Could not focus: Vessel ${mmsi} entity missing`, 'alert'); 
                }
            },
            
            // Apply vessel type filters
            applyVesselTypeFilters: function() {
                if (!this.visible) return;
                
                // Re-render vessels with current filters
                this.renderVessels();
                
                // Update vessel count display
                const filteredCount = Object.values(this.vessels).filter(vessel => {
                    const vesselType = this._normalizeVesselType(vessel.vessel_type);
                    return this.vesselTypeFilters.includes(vesselType);
                }).length;
                
                const countEl = document.getElementById('ais-vessel-count');
                if (countEl) {
                    countEl.textContent = filteredCount;
                }
                
                addConsoleMessage(`Filtered to ${filteredCount} vessels of types: ${this.vesselTypeFilters.join(', ')}`, 'response');
            },
            
            // Normalize vessel type to match filter categories
            _normalizeVesselType: function(vesselType) {
                if (!vesselType) return 'Other';
                
                const type = vesselType.toLowerCase();
                
                if (type.includes('cargo')) return 'Cargo';
                if (type.includes('tanker') || type.includes('tanker')) return 'Tanker';
                if (type.includes('passenger') || type.includes('ferry')) return 'Passenger';
                if (type.includes('fish')) return 'Fishing';
                if (type.includes('tug')) return 'Tug';
                if (type.includes('pilot')) return 'Pilot';
                
                return 'Other';
            },
            
            // Update available vessel types from API
            updateAvailableVesselTypes: async function() {
                try {
                    const response = await fetch('/api/ais/vessel-types');
                    const data = await response.json();
                    
                    if (data.status === 'ok') {
                        this.availableVesselTypes = new Set(data.vessel_types);
                        
                        // Update filter checkboxes
                        const filterContainer = document.getElementById('vesselTypeFilters');
                        if (filterContainer) {
                            filterContainer.innerHTML = '';
                            
                            Array.from(this.availableVesselTypes).sort().forEach(type => {
                                const normalizedType = this._normalizeVesselType(type);
                                const div = document.createElement('div');
                                div.style.margin = '2px 0';
                                div.innerHTML = `
                                    <label>
                                        <input type="checkbox" class="vesselTypeFilter" value="${normalizedType}" 
                                               ${this.vesselTypeFilters.includes(normalizedType) ? 'checked' : ''}>
                                        ${normalizedType}
                                    </label>
                                `;
                                filterContainer.appendChild(div);
                                
                                // Add event listener
                                const checkbox = div.querySelector('.vesselTypeFilter');
                                const self = this;
                                checkbox.addEventListener('change', function(e) {
                                    const type = e.target.value;
                                    if (e.target.checked) {
                                        if (!self.vesselTypeFilters.includes(type)) {
                                            self.vesselTypeFilters.push(type);
                                        }
                                    } else {
                                        self.vesselTypeFilters = self.vesselTypeFilters.filter(t => t !== type);
                                    }
                                    self.applyVesselTypeFilters();
                                });
                            });
                        }
                    }
                } catch (error) {
                    console.error('Error updating vessel types:', error);
                }
            },
            
            // Search in current visible area
            searchInVisibleArea: async function() {
                try {
                    if (!this.viewer) {
                        addConsoleMessage('Cesium viewer not available', 'alert');
                        return;
                    }
                    
                    // Get current visible bounding box
                    const bbox = this.getCurrentVisibleBoundingBox();
                    if (!bbox) {
                        addConsoleMessage('Could not determine visible area', 'alert');
                        return;
                    }
                    
                    addConsoleMessage(`Searching AIS traffic in visible area: ${bbox.min_lat.toFixed(2)}°N to ${bbox.max_lat.toFixed(2)}°N, ${bbox.min_lon.toFixed(2)}°E to ${bbox.max_lon.toFixed(2)}°E`, 'command');

                    // First attempt: request server to start AISStream for this bounding box
                    // AISStream expects bounding boxes as [[[lon_sw, lat_sw], [lon_ne, lat_ne]]]
                    const aisstream_bbox = [
                        [
                            [bbox.min_lon, bbox.min_lat],
                            [bbox.max_lon, bbox.max_lat]
                        ]
                    ];

                    let usedStream = false;
                    try {
                        const startResp = await fetch('/api/ais/stream/start', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ bounding_box: aisstream_bbox })
                        });

                        if (startResp.ok) {
                            const startData = await startResp.json();
                            if (startData.status === 'started') {
                                usedStream = true;
                                addConsoleMessage('Requested AISStream subscription for visible area', 'response');
                            }
                        }
                    } catch (e) {
                        console.warn('[AIS] Failed to request AISStream start:', e);
                    }

                    // If AISStream request succeeded, fetch live vessels from server; otherwise fallback to search API
                    if (usedStream) {
                        try {
                            // Ask server for current live vessels (use a generous per_page)
                            const resp = await fetch('/api/ais/vessels?per_page=500');
                            const live = await resp.json();
                            if (live && live.status === 'ok') {
                                // Convert vessel list into search-like result expected by displaySearchResults
                                const vessels = (live.vessels || []).map(v => ({
                                    MMSI: v.mmsi,
                                    VesselName: v.name || v.callsign || `MMSI_${v.mmsi}`,
                                    LAT: v.lat,
                                    LON: v.lon,
                                    VesselType: v.vessel_type || 'Unknown'
                                }));

                                const out = {
                                    status: 'ok',
                                    search_results: vessels.length,
                                    total_records: vessels.length,
                                    unique_vessels: vessels.length,
                                    vessels: vessels
                                };

                                this.displaySearchResults(out);
                                if (out.unique_vessels > 0) {
                                    addConsoleMessage(`Found ${out.unique_vessels} vessels in visible area (live)`, 'response');
                                    showNotification('AIS Area Search', `Found ${out.unique_vessels} vessels in current view (live)`, 'info');
                                } else {
                                    addConsoleMessage('No live vessels found in current visible area', 'response');
                                }
                                return;
                            }
                        } catch (e) {
                            console.warn('[AIS] Failed to fetch live vessels after stream start:', e);
                        }
                    }

                    // Fallback: perform historic/search-based area query
                    const params = new URLSearchParams({
                        'min_lat': bbox.min_lat,
                        'max_lat': bbox.max_lat,
                        'min_lon': bbox.min_lon,
                        'max_lon': bbox.max_lon,
                        'limit': '100'  // Reasonable limit for area search
                    });

                    const response = await fetch(`/api/ais/search?${params}`);
                    const data = await response.json();

                    if (data.status === 'ok') {
                        this.displaySearchResults(data);

                        if (data.unique_vessels > 0) {
                            addConsoleMessage(`Found ${data.unique_vessels} vessels in visible area`, 'response');
                            showNotification('AIS Area Search', `Found ${data.unique_vessels} vessels in current view`, 'info');
                        } else {
                            addConsoleMessage('No vessels found in current visible area', 'response');
                        }
                    } else {
                        addConsoleMessage('Area search failed: ' + data.message, 'alert');
                    }
                } catch (error) {
                    console.error('Area search error:', error);
                    addConsoleMessage('Area search error: ' + error.message, 'alert');
                }
            },
            
            // Get current visible bounding box from Cesium camera
            getCurrentVisibleBoundingBox: function() {
                try {
                    const rectangle = this.viewer.camera.computeViewRectangle();
                    if (!rectangle) {
                        // If computeViewRectangle fails (e.g., when looking at poles), use a fallback
                        const center = this.viewer.camera.positionCartographic;
                        if (!center) return null;
                        
                        // Create a bounding box around the camera position
                        const lat = Cesium.Math.toDegrees(center.latitude);
                        const lon = Cesium.Math.toDegrees(center.longitude);
                        const altitude = center.height;
                        
                        // Estimate bounds based on altitude (rough approximation)
                        const degreeSpan = Math.max(0.1, altitude / 111000); // ~1 degree per 111km
                    
                        return {
                            min_lat: Math.max(-90, lat - degreeSpan),
                            max_lat: Math.min(90, lat + degreeSpan),
                            min_lon: Math.max(-180, lon - degreeSpan),
                            max_lon: Math.min(180, lon + degreeSpan)
                        };
                    }
                    
                    const west = Cesium.Math.toDegrees(rectangle.west);
                    const south = Cesium.Math.toDegrees(rectangle.south);
                    const east = Cesium.Math.toDegrees(rectangle.east);
                    const north = Cesium.Math.toDegrees(rectangle.north);
                    
                    return {
                        min_lat: south,
                        max_lat: north,
                        min_lon: west,
                        max_lon: east
                    };
                } catch (e) {
                    console.warn('[AIS] Could not compute visible bounding box:', e);
                    return null;
                }
            },
            
            // AIS Search functionality
            searchRecords: async function(query, vesselType) {
                try {
                    const params = new URLSearchParams();
                    if (query) params.append('q', query);
                    if (vesselType && vesselType !== 'all') params.append('type', vesselType);
                    params.append('limit', '50'); // Limit results for UI
                    
                    const response = await fetch(`/api/ais/search?${params}`);
                    const data = await response.json();
                    
                    if (data.status === 'ok') {
                        this.displaySearchResults(data);
                        addConsoleMessage(`Found ${data.search_results} records, ${data.unique_vessels} unique vessels`, 'response');
                    } else {
                        addConsoleMessage('Search failed: ' + data.message, 'alert');
                    }
                } catch (error) {
                    console.error('Search error:', error);
                    addConsoleMessage('Search error: ' + error.message, 'alert');
                }
            },

            // Load all AIS records from server in paged chunks and display unique vessels
            loadAllRecords: async function() {
                try {
                    addConsoleMessage('Starting full AIS records load...', 'command');
                    const resultsDiv = document.getElementById('aisSearchResults');
                    const statsDiv = document.getElementById('aisSearchStats');
                    const listDiv = document.getElementById('aisSearchList');
                    if (resultsDiv) resultsDiv.style.display = 'block';

                    const per_page = 1000;
                    let offset = 0;
                    let allRecords = [];
                    let total_matches = null;

                    while (true) {
                        const params = new URLSearchParams({ offset: offset, limit: per_page });
                        const resp = await fetch(`/api/ais/search?${params}`);
                        if (!resp.ok) {
                            addConsoleMessage('Failed to fetch AIS records page: ' + resp.status, 'alert');
                            break;
                        }
                        const pageData = await resp.json();
                        if (pageData.status !== 'ok') {
                            addConsoleMessage('Error fetching AIS records: ' + (pageData.message || 'unknown'), 'alert');
                            break;
                        }

                        allRecords = allRecords.concat(pageData.records || []);
                        total_matches = pageData.total_matches || pageData.total_records || allRecords.length;

                        // Update progress
                        if (statsDiv) statsDiv.innerHTML = `Loaded ${allRecords.length} / ${total_matches} records...`;

                        // Break if we've loaded all
                        if (allRecords.length >= total_matches || (pageData.records || []).length === 0) break;

                        offset += per_page;
                    }

                    // Reduce to unique vessels (take last seen record per MMSI)
                    const byMmsi = {};
                    allRecords.forEach(r => {
                        const m = r.MMSI || r.mmsi || r.Mmsi || r.MMSI;
                        if (!m) return;
                        byMmsi[m] = r; // later records will overwrite earlier
                    });

                    const vessels = Object.values(byMmsi).map(r => ({
                        MMSI: r.MMSI || r.mmsi,
                        VesselName: r.VesselName || r.Vessel || r.name || '',
                        LAT: r.LAT || r.lat || r.Latitude || 0,
                        LON: r.LON || r.lon || r.Longitude || 0,
                        VesselType: r.VesselType || r.vessel_type || 'Unknown'
                    }));

                    const out = {
                        status: 'ok',
                        search_results: allRecords.length,
                        total_records: allRecords.length,
                        unique_vessels: vessels.length,
                        vessels: vessels,
                        records: allRecords
                    };

                    this.displaySearchResults(out);
                    addConsoleMessage(`Loaded all records: ${allRecords.length} records, ${vessels.length} unique vessels`, 'response');
                    showNotification('AIS Full Load', `Loaded ${allRecords.length} AIS records`, 'info');

                    // Display a random sample of unique vessels on the map (1000 max)
                    try {
                        const SAMPLE_SIZE = 1000;
                        const shuffled = vessels.slice();
                        for (let i = shuffled.length - 1; i > 0; i--) {
                            const j = Math.floor(Math.random() * (i + 1));
                            const tmp = shuffled[i]; shuffled[i] = shuffled[j]; shuffled[j] = tmp;
                        }
                        const sample = shuffled.slice(0, Math.min(SAMPLE_SIZE, shuffled.length));

                        // Replace current vessels with sample set
                        this.vessels = {};
                        sample.forEach(v => {
                            const mmsi = v.MMSI;
                            const lat = parseFloat(v.LAT) || 0;
                            const lon = parseFloat(v.LON) || 0;
                            this.vessels[mmsi] = {
                                mmsi: mmsi,
                                lat: lat,
                                lon: lon,
                                name: v.VesselName || `MMSI_${mmsi}`,
                                vessel_type: v.VesselType || 'Unknown'
                            };
                        });

                        // Update count display and render
                        const countEl = document.getElementById('ais-vessel-count');
                        if (countEl) countEl.textContent = Object.keys(this.vessels).length;
                        this.renderVessels();
                        addConsoleMessage(`Displaying ${Object.keys(this.vessels).length} random unique vessels on map`, 'response');
                    } catch (e) {
                        console.warn('Error sampling vessels for display:', e);
                    }
                } catch (e) {
                    console.error('Error loading all records:', e);
                    addConsoleMessage('Error loading all records: ' + e.message, 'alert');
                }
            },
            
            displaySearchResults: function(data) {
                const resultsDiv = document.getElementById('aisSearchResults');
                const statsDiv = document.getElementById('aisSearchStats');
                const listDiv = document.getElementById('aisSearchList');
                
                if (!resultsDiv || !statsDiv || !listDiv) return;
                
                // Show results container
                resultsDiv.style.display = 'block';
                
                // Update stats
                statsDiv.innerHTML = `Found ${data.search_results} records from ${data.total_records} total, ${data.unique_vessels} unique vessels`;
                
                // Clear previous results
                listDiv.innerHTML = '';
                
                if (data.vessels.length === 0) {
                    listDiv.innerHTML = '<div style="color: #888;">No vessels found</div>';
                    return;
                }
                
                // Display vessels
                data.vessels.forEach(vessel => {
                    const vesselDiv = document.createElement('div');
                    vesselDiv.style.cssText = 'margin: 3px 0; padding: 3px; background: rgba(255,255,255,0.05); border-radius: 2px; cursor: pointer;';
                    vesselDiv.innerHTML = `
                        <div style="font-weight: bold; color: #4a9eff;">${vessel.VesselName || 'Unknown'} (${vessel.MMSI})</div>
                        <div style="font-size: 8px; color: #ccc;">
                            Type: ${vessel.VesselType || 'Unknown'} | 
                            Pos: ${parseFloat(vessel.LAT || 0).toFixed(4)}, ${parseFloat(vessel.LON || 0).toFixed(4)}
                        </div>
                    `;
                    
                    // Click to focus on vessel
                    vesselDiv.onclick = () => {
                        this.focusOnSearchResult(vessel);
                    };
                    
                    listDiv.appendChild(vesselDiv);
                });
            },
            
            focusOnSearchResult: function(vessel) {
                const mmsi = vessel.MMSI;
                const lat = parseFloat(vessel.LAT || 0);
                const lon = parseFloat(vessel.LON || 0);
                
                // Add to current vessels if not present
                if (!this.vessels[mmsi]) {
                    this.vessels[mmsi] = {
                        mmsi: mmsi,
                        lat: lat,
                        lon: lon,
                        name: vessel.VesselName || `MMSI_${mmsi}`,
                        vessel_type: vessel.VesselType || 'Unknown'
                    };
                    
                    // Add entity to map
                    this.addVesselEntity(this.vessels[mmsi]);
                }
                
                // Fly to vessel
                this.flyToVessel(mmsi);
                
                addConsoleMessage(`Focused on ${vessel.VesselName || 'Unknown'} (${mmsi})`, 'response');
            },
            
            clearSearch: function() {
                const resultsDiv = document.getElementById('aisSearchResults');
                const searchInput = document.getElementById('aisSearchInput');
                
                if (resultsDiv) resultsDiv.style.display = 'none';
                if (searchInput) searchInput.value = '';
                
                addConsoleMessage('Search cleared', 'command');
            }
        };
        
        // Make AIS visualization globally available
        window.AISVisualization = AISVisualization;

        // =====================================================================
        // OPERATOR SESSION MANAGEMENT (Based on Lattice SDK Patterns)
        // =====================================================================
        
        const OperatorSession = {
            operatorId: null,
            operatorName: null,
            callsign: null,
            role: null,
            teamId: null,
            sessionToken: null,
            sessionId: null,
            isAuthenticated: false,
            heartbeatInterval: null,
            
            HEARTBEAT_INTERVAL: 30000, // 30 seconds
            
            // Initialize from localStorage if available
            init: function() {
                // First try to restore from localStorage
                const savedSession = localStorage.getItem('operatorSession');
                let restored = false;
                if (savedSession) {
                    try {
                        const data = JSON.parse(savedSession);
                        if (data && data.sessionToken) {
                            this.sessionToken = data.sessionToken;
                            this.validateSession();
                            restored = true;
                        }
                    } catch (e) {
                        console.warn('[OperatorSession] Invalid saved session:', e);
                        this.clearSession();
                    }
                }
                // If nothing in localStorage, fall back to cookie
                if (!restored) {
                    const cookieToken = this.getCookie('operatorSessionToken');
                    if (cookieToken) {
                        this.sessionToken = cookieToken;
                        this.validateSession();
                    }
                }
            },

            // Helper: get a cookie value by name
            getCookie: function(name) {
                const value = `; ${document.cookie}`;
                const parts = value.split(`; ${name}=`);
                if (parts.length === 2) {
                    return parts.pop().split(';').shift();
                }
                return null;
            },

            // Helper: set a cookie (optionally specify days to expire)
            setCookie: function(name, value, days) {
                let expires = '';
                if (typeof days === 'number') {
                    const date = new Date();
                    date.setTime(date.getTime() + days * 24 * 60 * 60 * 1000);
                    expires = '; expires=' + date.toUTCString();
                }
                document.cookie = `${name}=${value || ''}${expires}; path=/`;
            },

            // Helper: clear a cookie
            clearCookie: function(name) {
                document.cookie = `${name}=; expires=Thu, 01 Jan 1970 00:00:00 GMT; path=/`;
            },
            
            // Validate existing session with server
            validateSession: async function() {
                if (!this.sessionToken) return false;
                
                try {
                    const response = await fetch('/api/operator/session', {
                        headers: { 'X-Session-Token': this.sessionToken }
                    });
                    // If unauthorized, silently clear session (no noisy console error)
                    if (response.status === 401) {
                        this.clearSession();
                        return false;
                    }

                    if (response.ok) {
                        const data = await response.json();
                        if (data.status === 'ok') {
                            this._setSessionData(data.session, data.operator);
                            this.startHeartbeat();
                            this.onSessionRestored();
                            return true;
                        }
                    } else {
                        // For other non-OK statuses, log minimal info
                        console.debug('[OperatorSession] validateSession response:', response.status);
                    }
                } catch (e) {
                    console.warn('[OperatorSession] Session validation failed (network):', e);
                }
                
                this.clearSession();
                return false;
            },
            
            // Login with callsign and password
            login: async function(callsign, password) {
                try {
                    const response = await fetch('/api/operator/login', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ callsign, password })
                    });
                    
                    const data = await response.json();
                    
                    if (data.status === 'ok') {
                        this._setSessionData(data.session, data.operator);
                        this.startHeartbeat();
                        this.onLoginSuccess();
                        return { success: true, operator: data.operator };
                    } else {
                        return { success: false, message: data.message };
                    }
                } catch (e) {
                    console.error('[OperatorSession] Login error:', e);
                    return { success: false, message: e.message };
                }
            },
            
            // Register new operator
            register: async function(callsign, email, password, role = 'operator') {
                try {
                    const response = await fetch('/api/operator/register', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ callsign, email, password, role })
                    });
                    
                    const data = await response.json();
                    
                    if (data.status === 'ok') {
                        // Auto-login after registration
                        return this.login(callsign, password);
                    } else {
                        return { success: false, message: data.message };
                    }
                } catch (e) {
                    console.error('[OperatorSession] Registration error:', e);
                    return { success: false, message: e.message };
                }
            },
            
            // Logout
            logout: async function() {
                if (!this.sessionToken) return;
                
                try {
                    await fetch('/api/operator/logout', {
                        method: 'POST',
                        headers: { 'X-Session-Token': this.sessionToken }
                    });
                } catch (e) {
                    console.warn('[OperatorSession] Logout error:', e);
                }
                
                this.clearSession();
                this.onLogout();
            },
            
            // Clear session data
            clearSession: function() {
                this.stopHeartbeat();
                this.operatorId = null;
                this.operatorName = null;
                this.callsign = null;
                this.role = null;
                this.teamId = null;
                this.sessionToken = null;
                this.sessionId = null;
                this.isAuthenticated = false;
                localStorage.removeItem('operatorSession');
                // Also remove the session token cookie so it doesn't linger
                this.clearCookie('operatorSessionToken');
            },
            
            // Set session data from server response
            _setSessionData: function(session, operator) {
                this.sessionId = session.session_id;
                this.sessionToken = session.session_token;
                this.operatorId = operator.operator_id;
                this.operatorName = operator.email;
                this.callsign = operator.callsign;
                this.role = operator.role;
                this.teamId = operator.team_id;
                this.isAuthenticated = true;
                
                // Persist to localStorage
                localStorage.setItem('operatorSession', JSON.stringify({
                    sessionToken: this.sessionToken
                }));

                // Persist to cookie with a generous expiry (e.g., 7 days)
                try {
                    this.setCookie('operatorSessionToken', this.sessionToken, 7);
                } catch (e) {
                    console.warn('[OperatorSession] Could not set session cookie:', e);
                }
                
                console.log(`[OperatorSession] Logged in as ${this.callsign} (${this.role})`);
            },
            
            // Start heartbeat to keep session alive
            startHeartbeat: function() {
                this.stopHeartbeat();
                
                const self = this;
                this.heartbeatInterval = setInterval(async function() {
                    if (!self.sessionToken) return;
                    
                    // Get current view bounds
                    let currentView = null;
                    if (window.viewer && window.viewer.camera) {
                        const pos = window.viewer.camera.positionCartographic;
                        currentView = {
                            center: [
                                Cesium.Math.toDegrees(pos.latitude),
                                Cesium.Math.toDegrees(pos.longitude)
                            ],
                            altitude: pos.height,
                            heading: Cesium.Math.toDegrees(window.viewer.camera.heading)
                        };
                    }
                    
                    try {
                        await fetch('/api/operator/heartbeat', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'X-Session-Token': self.sessionToken
                            },
                            body: JSON.stringify({ current_view: currentView })
                        });
                    } catch (e) {
                        console.warn('[OperatorSession] Heartbeat failed:', e);
                    }
                }, this.HEARTBEAT_INTERVAL);
            },
            
            stopHeartbeat: function() {
                if (this.heartbeatInterval) {
                    clearInterval(this.heartbeatInterval);
                    this.heartbeatInterval = null;
                }
            },
            
            // Get active operators
            getActiveOperators: async function() {
                try {
                    const response = await fetch('/api/operator/active');
                    const data = await response.json();
                    return data.operators || [];
                } catch (e) {
                    console.error('[OperatorSession] Error getting active operators:', e);
                    return [];
                }
            },
            
            // Event callbacks (can be overridden)
            onLoginSuccess: function() {
                addConsoleMessage(`👤 Operator ${this.callsign} logged in`, 'info');
                updateOperatorStatusUI();
                
                // Connect to entity stream (prefer WebSocket if available)
                if (window.WebSocketSync && WebSocketSync.useWebSocket) {
                    WebSocketSync.connect();
                } else if (window.EntitySync) {
                    EntitySync.connect();
                }
                
                // Fetch and auto-join rooms
                if (window.RoomManager) {
                    RoomManager.fetchRooms();
                    RoomManager.fetchMyRooms();
                }
                
                // Populate room selector in DSL explorer (if available)
                if (typeof populateRooms === 'function') {
                    try { populateRooms(); } catch(e) { console.debug('populateRooms failed:', e); }
                }
            },
            
            onSessionRestored: function() {
                addConsoleMessage(`👤 Session restored for ${this.callsign}`, 'info');
                updateOperatorStatusUI();
                
                // Connect to entity stream
                if (window.WebSocketSync && WebSocketSync.useWebSocket) {
                    WebSocketSync.connect();
                } else if (window.EntitySync) {
                    EntitySync.connect();
                }
                
                // Fetch rooms
                if (window.RoomManager) {
                    RoomManager.fetchRooms();
                    RoomManager.fetchMyRooms();
                }
            },
            
            onLogout: function() {
                addConsoleMessage('👤 Operator logged out', 'info');
                updateOperatorStatusUI();
                
                // Disconnect from streams
                if (window.WebSocketSync) {
                    WebSocketSync.disconnect();
                }
                if (window.EntitySync) {
                    EntitySync.disconnect();
                }
                
                // Clear room data
                if (window.RoomManager) {
                    RoomManager.joinedRooms = {};
                    RoomManager.currentRoomId = null;
                    RoomManager.updateJoinedRoomsList();
                    RoomManager.updateRoomUI();
                }
            }
        };
        
        // Make globally available
        window.OperatorSession = OperatorSession;
        
        // =====================================================================
        // REAL-TIME ENTITY SYNC VIA SSE (Based on Lattice SDK Patterns)
        // =====================================================================
        
        const EntitySync = {
            eventSource: null,
            connected: false,
            reconnectAttempts: 0,
            maxReconnectAttempts: 5,
            reconnectDelay: 3000, // 3 seconds
            entityCache: {},
            eventHandlers: {},
            lastEventId: 0,
            
            // Connect to SSE stream
            connect: async function(since) {
                if (!OperatorSession.sessionToken) {
                    console.warn('[EntitySync] Cannot connect - no session token');
                    return;
                }

                if (this.eventSource) {
                    this.disconnect();
                }

                let url = `/api/entities/stream?token=${encodeURIComponent(OperatorSession.sessionToken)}`;
                if(since){
                    url += `&since=${encodeURIComponent(since)}`;
                }
                const self = this;

                // Preflight: check endpoint availability and auth using fetch
                try {
                    const probe = await fetch(url, { method: 'GET', headers: { 'Accept': 'text/event-stream' } });
                    if (probe.status === 401) {
                        // Unauthorized - clear session silently and bail
                        console.debug('[EntitySync] SSE probe returned 401 - clearing session');
                        OperatorSession.clearSession();
                        addConsoleMessage('Entity stream unauthorized - please log in', 'alert');
                        return;
                    }
                    if (!probe.ok) {
                        console.debug(`[EntitySync] SSE probe returned status ${probe.status}`);
                        // Schedule reconnect attempt with backoff
                        this._scheduleReconnect();
                        return;
                    }
                } catch (e) {
                    console.debug('[EntitySync] SSE probe failed:', e);
                    this._scheduleReconnect();
                    return;
                }

                // Create EventSource after successful probe
                try {
                    this.eventSource = new EventSource(url);

                    this.eventSource.onopen = function() {
                        self.connected = true;
                        self.reconnectAttempts = 0;
                        self.reconnectDelay = 3000; // reset delay
                        console.log('[EntitySync] Connected to entity stream');
                        addConsoleMessage('📡 Connected to real-time entity stream', 'response');
                        self._notifyHandlers('connected', {});
                    };

                    this.eventSource.onerror = function(e) {
                        // EventSource error objects are opaque; log minimally
                        console.debug('[EntitySync] Connection error (SSE event)', e);
                        self.connected = false;
                        self._notifyHandlers('error', { error: e });

                        // Attempt reconnect with exponential backoff
                        self._scheduleReconnect();
                    };
                } catch (e) {
                    console.debug('[EntitySync] Failed to create EventSource:', e);
                    this._scheduleReconnect();
                    return;
                }
                
                // Entity event handlers
                this.eventSource.addEventListener('PREEXISTING', function(e) {
                    self._handleEntityEvent('PREEXISTING', JSON.parse(e.data));
                });
                
                this.eventSource.addEventListener('CREATE', function(e) {
                    self._handleEntityEvent('CREATE', JSON.parse(e.data));
                });
                
                this.eventSource.addEventListener('UPDATE', function(e) {
                    self._handleEntityEvent('UPDATE', JSON.parse(e.data));
                });
                
                this.eventSource.addEventListener('DELETE', function(e) {
                    self._handleEntityEvent('DELETE', JSON.parse(e.data));
                });
                
                this.eventSource.addEventListener('HEARTBEAT', function(e) {
                    // Silent heartbeat
                    self.lastEventId = JSON.parse(e.data).sequence_id || self.lastEventId;
                });
            },
            
            // Disconnect from SSE stream
            disconnect: function() {
                if (this.eventSource) {
                    this.eventSource.close();
                    this.eventSource = null;
                }
                this.connected = false;
                console.log('[EntitySync] Disconnected from entity stream');
            },
            
            // Handle incoming entity events
            _handleEntityEvent: function(eventType, data) {
                const entityId = data.entity_id;
                const entityType = data.entity_type;
                const entityData = data.entity_data;
                const provenance = data.provenance;
                
                this.lastEventId = data.sequence_id || this.lastEventId;
                
                // Update local cache
                if (eventType === 'DELETE') {
                    delete this.entityCache[entityId];
                } else {
                    this.entityCache[entityId] = {
                        id: entityId,
                        type: entityType,
                        data: entityData,
                        provenance: provenance,
                        lastUpdated: data.timestamp
                    };
                }
                
                // Log the event
                const editor = provenance?.source_description || 'System';
                if (eventType !== 'PREEXISTING') {
                    console.log(`[EntitySync] ${eventType}: ${entityId} (${entityType}) by ${editor}`);
                }
                
                // Notify registered handlers
                this._notifyHandlers(eventType.toLowerCase(), data);
                this._notifyHandlers('entity', { eventType, ...data });
            },
            
            // Notify event handlers
            _notifyHandlers: function(event, data) {
                const handlers = this.eventHandlers[event] || [];
                handlers.forEach(handler => {
                    try {
                        handler(data);
                    } catch (e) {
                        console.error(`[EntitySync] Handler error for ${event}:`, e);
                    }
                });
            },

            // Schedule reconnect with exponential backoff
            _scheduleReconnect: function() {
                const self = this;
                if (self.reconnectAttempts >= self.maxReconnectAttempts) {
                    addConsoleMessage('⚠️ Entity stream disconnected - max reconnects reached', 'alert');
                    return;
                }

                self.reconnectAttempts = (self.reconnectAttempts || 0) + 1;
                // Exponential backoff: base * 2^(attempt-1)
                const delay = Math.min(60000, (self.reconnectDelay || 3000) * Math.pow(2, self.reconnectAttempts - 1));
                console.log(`[EntitySync] Reconnect attempt ${self.reconnectAttempts}/${self.maxReconnectAttempts} in ${delay}ms`);
                setTimeout(() => {
                    try {
                        self.connect();
                    } catch (e) {
                        console.debug('[EntitySync] reconnect.connect error:', e);
                        self._scheduleReconnect();
                    }
                }, delay);
            },
            
            // Register event handler
            on: function(event, handler) {
                if (!this.eventHandlers[event]) {
                    this.eventHandlers[event] = [];
                }
                this.eventHandlers[event].push(handler);
                return this; // Allow chaining
            },
            
            // Remove event handler
            off: function(event, handler) {
                if (this.eventHandlers[event]) {
                    this.eventHandlers[event] = this.eventHandlers[event].filter(h => h !== handler);
                }
                return this;
            },
            
            // Publish entity to server (broadcasts to all clients)
            publishEntity: async function(entityId, entityType, entityData) {
                if (!OperatorSession.sessionToken) {
                    console.warn('[EntitySync] Cannot publish - no session');
                    return { success: false, message: 'Not authenticated' };
                }
                
                try {
                    const response = await fetch('/api/entities/publish', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-Session-Token': OperatorSession.sessionToken
                        },
                        body: JSON.stringify({
                            entity_id: entityId,
                            entity_type: entityType,
                            entity_data: entityData
                        })
                    });
                    
                    const data = await response.json();
                    return { success: data.status === 'ok', ...data };
                } catch (e) {
                    console.error('[EntitySync] Publish error:', e);
                    return { success: false, message: e.message };
                }
            },
            
            // Delete entity (broadcasts to all clients)
            deleteEntity: async function(entityId) {
                if (!OperatorSession.sessionToken) {
                    return { success: false, message: 'Not authenticated' };
                }
                
                try {
                    const response = await fetch(`/api/entities/delete/${entityId}`, {
                        method: 'DELETE',
                        headers: { 'X-Session-Token': OperatorSession.sessionToken }
                    });
                    
                    const data = await response.json();
                    return { success: data.status === 'ok', ...data };
                } catch (e) {
                    console.error('[EntitySync] Delete error:', e);
                    return { success: false, message: e.message };
                }
            },
            
            // Get entity from local cache
            getEntity: function(entityId) {
                return this.entityCache[entityId];
            },
            
            // Get all cached entities
            getAllEntities: function() {
                return Object.values(this.entityCache);
            },
            
            // Get entities by type
            getEntitiesByType: function(entityType) {
                return Object.values(this.entityCache).filter(e => e.type === entityType);
            }
        };
        
        // Make globally available
        window.EntitySync = EntitySync;
        
        // =====================================================================
        // OPERATOR PRESENCE VISUALIZATION
        // =====================================================================
        
        const OperatorPresence = {
            operators: {},
            presenceEntities: {},
            updateInterval: null,
            visible: true,
            
            // Initialize presence tracking
            initialize: function(cesiumViewer) {
                this.viewer = cesiumViewer;
                this.startTracking();
            },
            
            // Start periodic presence updates
            startTracking: function() {
                if (this.updateInterval) return;
                
                const self = this;
                this.updateInterval = setInterval(async function() {
                    await self.fetchActiveOperators();
                }, 10000); // Update every 10 seconds
                
                // Initial fetch
                this.fetchActiveOperators();
            },
            
            // Stop presence tracking
            stopTracking: function() {
                if (this.updateInterval) {
                    clearInterval(this.updateInterval);
                    this.updateInterval = null;
                }
            },
            
            // Fetch active operators from server
            fetchActiveOperators: async function() {
                try {
                    const operators = await OperatorSession.getActiveOperators();
                    this.operators = {};
                    
                    operators.forEach(op => {
                        this.operators[op.operator_id] = op;
                    });
                    
                    this.updatePresenceIndicators();
                    this.updatePresenceList();
                } catch (e) {
                    console.error('[OperatorPresence] Error fetching operators:', e);
                }
            },
            
            // Update visual indicators on map
            updatePresenceIndicators: function() {
                if (!this.viewer || !this.visible) return;
                
                // Clear old indicators
                Object.values(this.presenceEntities).forEach(entity => {
                    if (this.viewer.entities.contains(entity)) {
                        this.viewer.entities.remove(entity);
                    }
                });
                this.presenceEntities = {};
                
                // Create new indicators for operators with views
                Object.values(this.operators).forEach(op => {
                    if (op.current_view && op.operator_id !== OperatorSession.operatorId) {
                        this._createPresenceIndicator(op);
                    }
                });
            },
            
            // Create visual indicator for an operator's view
            _createPresenceIndicator: function(operator) {
                if (!operator.current_view || !operator.current_view.center) return;
                
                const [lat, lon] = operator.current_view.center;
                const altitude = operator.current_view.altitude || 100000;
                
                // Create a simple marker showing where operator is looking
                const entity = this.viewer.entities.add({
                    id: `operator_presence_${operator.operator_id}`,
                    position: Cesium.Cartesian3.fromDegrees(lon, lat, 0),
                    point: {
                        pixelSize: 12,
                        color: this._getRoleColor(operator.role),
                        outlineColor: Cesium.Color.WHITE,
                        outlineWidth: 2
                    },
                    label: {
                        text: `👤 ${operator.callsign}`,
                        font: '12px sans-serif',
                        fillColor: Cesium.Color.WHITE,
                        outlineColor: Cesium.Color.BLACK,
                        outlineWidth: 2,
                        style: Cesium.LabelStyle.FILL_AND_OUTLINE,
                        verticalOrigin: Cesium.VerticalOrigin.BOTTOM,
                        pixelOffset: new Cesium.Cartesian2(0, -15)
                    }
                });
                
                this.presenceEntities[operator.operator_id] = entity;
            },
            
            // Get color based on role
            _getRoleColor: function(role) {
                switch (role) {
                    case 'admin': return Cesium.Color.RED;
                    case 'supervisor': return Cesium.Color.ORANGE;
                    case 'operator': return Cesium.Color.CYAN;
                    case 'observer': return Cesium.Color.GRAY;
                    default: return Cesium.Color.WHITE;
                }
            },
            
            // Update the presence list in UI
            updatePresenceList: function() {
                const listEl = document.getElementById('operator-presence-list');
                if (!listEl) return;
                
                const operators = Object.values(this.operators);
                
                if (operators.length === 0) {
                    listEl.innerHTML = '<div class="empty-message">No active operators</div>';
                    return;
                }
                
                let html = '';
                operators.forEach(op => {
                    const isMe = op.operator_id === OperatorSession.operatorId;
                    const roleIcon = this._getRoleIcon(op.role);
                    html += `
                        <div class="operator-presence-item ${isMe ? 'current-operator' : ''}" data-operator-id="${op.operator_id}">
                            <span class="operator-icon">${roleIcon}</span>
                            <span class="operator-callsign">${op.callsign}${isMe ? ' (You)' : ''}</span>
                            <span class="operator-role">${op.role}</span>
                        </div>
                    `;
                });
                
                listEl.innerHTML = html;
            },
            
            // Get icon for role
            _getRoleIcon: function(role) {
                switch (role) {
                    case 'admin': return '👑';
                    case 'supervisor': return '⭐';
                    case 'operator': return '👤';
                    case 'observer': return '👁️';
                    default: return '👤';
                }
            },
            
            // Toggle visibility
            toggleVisibility: function(visible) {
                this.visible = visible;
                this.updatePresenceIndicators();
            }
        };
        
        // Make globally available
        window.OperatorPresence = OperatorPresence;
        
        // =====================================================================
        // ROOM/CHANNEL MANAGER (Based on cesium-rts patterns)
        // =====================================================================
        
        const RoomManager = {
            rooms: {},           // Available rooms
            joinedRooms: {},     // Rooms we've joined
            currentRoomId: null, // Currently active room for UI
            eventHandlers: {},
            
            // Fetch available rooms from server
            fetchRooms: async function() {
                try {
                    const response = await fetch('/api/rooms');
                    const data = await response.json();
                    
                    if (data.status === 'ok') {
                        this.rooms = {};
                        data.rooms.forEach(room => {
                            this.rooms[room.room_id] = room;
                        });
                        this._notifyHandlers('rooms_updated', this.rooms);
                        this.updateRoomsList();
                        return data.rooms;
                    }
                } catch (e) {
                    console.error('[RoomManager] Error fetching rooms:', e);
                }
                return [];
            },
            
            // Fetch rooms I've joined
            fetchMyRooms: async function() {
                if (!OperatorSession.sessionToken) return [];
                
                try {
                    const response = await fetch('/api/rooms/my', {
                        headers: { 'X-Session-Token': OperatorSession.sessionToken }
                    });
                    const data = await response.json();
                    
                    if (data.status === 'ok') {
                        this.joinedRooms = {};
                        data.rooms.forEach(room => {
                            this.joinedRooms[room.room_id] = room;
                        });
                        this._notifyHandlers('my_rooms_updated', this.joinedRooms);
                        this.updateJoinedRoomsList();
                        return data.rooms;
                    }
                } catch (e) {
                    console.error('[RoomManager] Error fetching my rooms:', e);
                }
                return [];
            },
            
            // Create a new room
            createRoom: async function(roomName, options = {}) {
                if (!OperatorSession.sessionToken) {
                    return { success: false, message: 'Not authenticated' };
                }
                
                try {
                    const response = await fetch('/api/rooms/create', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-Session-Token': OperatorSession.sessionToken
                        },
                        body: JSON.stringify({
                            room_name: roomName,
                            room_type: options.type || 'custom',
                            capacity: options.capacity || 50,
                            is_private: options.isPrivate || false,
                            password: options.password,
                            metadata: options.metadata
                        })
                    });
                    
                    const data = await response.json();
                    
                    if (data.status === 'ok') {
                        addConsoleMessage(`🏠 Created room: ${roomName}`, 'response');
                        await this.fetchRooms();
                        await this.fetchMyRooms();
                        return { success: true, room: data.room };
                    }
                    return { success: false, message: data.message };
                } catch (e) {
                    console.error('[RoomManager] Error creating room:', e);
                    return { success: false, message: e.message };
                }
            },
            
            // Join a room
            joinRoom: async function(roomId, password = null) {
                if (!OperatorSession.sessionToken) {
                    return { success: false, message: 'Not authenticated' };
                }
                
                try {
                    const response = await fetch(`/api/rooms/${roomId}/join`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-Session-Token': OperatorSession.sessionToken
                        },
                        body: JSON.stringify({ password })
                    });
                    
                    const data = await response.json();
                    
                    if (data.status === 'ok') {
                        const room = data.room || this.rooms[roomId];
                        if (room) {
                            this.joinedRooms[roomId] = room;
                        }
                        addConsoleMessage(`📥 Joined room: ${room?.room_name || roomId}`, 'response');
                        this._notifyHandlers('room_joined', { roomId, room });
                        this.updateJoinedRoomsList();
                        return { success: true, room: data.room };
                    }
                    return { success: false, message: data.message };
                } catch (e) {
                    console.error('[RoomManager] Error joining room:', e);
                    return { success: false, message: e.message };
                }
            },
            
            // Leave a room
            leaveRoom: async function(roomId) {
                if (!OperatorSession.sessionToken) {
                    return { success: false, message: 'Not authenticated' };
                }
                
                try {
                    const response = await fetch(`/api/rooms/${roomId}/leave`, {
                        method: 'POST',
                        headers: { 'X-Session-Token': OperatorSession.sessionToken }
                    });
                    
                    const data = await response.json();
                    
                    if (data.status === 'ok') {
                        const room = this.joinedRooms[roomId];
                        delete this.joinedRooms[roomId];
                        addConsoleMessage(`📤 Left room: ${room?.room_name || roomId}`, 'response');
                        this._notifyHandlers('room_left', { roomId });
                        this.updateJoinedRoomsList();
                        return { success: true };
                    }
                    return { success: false, message: data.message };
                } catch (e) {
                    console.error('[RoomManager] Error leaving room:', e);
                    return { success: false, message: e.message };
                }
            },
            
            // Get room details and members
            getRoomDetails: async function(roomId) {
                try {
                    const response = await fetch(`/api/rooms/${roomId}`);
                    return await response.json();
                } catch (e) {
                    console.error('[RoomManager] Error getting room details:', e);
                    return null;
                }
            },
            
            // Publish entity to a room
            publishToRoom: async function(roomId, entityId, entityType, entityData) {
                if (!OperatorSession.sessionToken) {
                    return { success: false, message: 'Not authenticated' };
                }
                
                try {
                    const response = await fetch(`/api/rooms/${roomId}/publish`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-Session-Token': OperatorSession.sessionToken
                        },
                        body: JSON.stringify({
                            entity_id: entityId,
                            entity_type: entityType,
                            entity_data: entityData
                        })
                    });
                    
                    const data = await response.json();
                    return { success: data.status === 'ok', ...data };
                } catch (e) {
                    console.error('[RoomManager] Error publishing to room:', e);
                    return { success: false, message: e.message };
                }
            },
            
            // Send message to a room
            sendMessage: async function(roomId, message, messageType = 'chat') {
                if (!OperatorSession.sessionToken) {
                    return { success: false, message: 'Not authenticated' };
                }
                
                try {
                    const response = await fetch(`/api/rooms/${roomId}/message`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-Session-Token': OperatorSession.sessionToken
                        },
                        body: JSON.stringify({ message, message_type: messageType })
                    });
                    
                    const data = await response.json();
                    return { success: data.status === 'ok' };
                } catch (e) {
                    console.error('[RoomManager] Error sending message:', e);
                    return { success: false, message: e.message };
                }
            },
            
            // Set current active room for UI
            setCurrentRoom: function(roomId) {
                this.currentRoomId = roomId;
                this._notifyHandlers('current_room_changed', { roomId });
                this.updateRoomUI();
            },
            
            // Event handlers
            on: function(event, handler) {
                if (!this.eventHandlers[event]) {
                    this.eventHandlers[event] = [];
                }
                this.eventHandlers[event].push(handler);
                return this;
            },
            
            off: function(event, handler) {
                if (this.eventHandlers[event]) {
                    this.eventHandlers[event] = this.eventHandlers[event].filter(h => h !== handler);
                }
                return this;
            },
            
            _notifyHandlers: function(event, data) {
                const handlers = this.eventHandlers[event] || [];
                handlers.forEach(handler => {
                    try {
                        handler(data);
                    } catch (e) {
                        console.error(`[RoomManager] Handler error for ${event}:`, e);
                    }
                });
            },
            
            // UI Update functions
            updateRoomsList: function() {
                const listEl = document.getElementById('available-rooms-list');
                if (!listEl) return;
                
                const rooms = Object.values(this.rooms);
                
                if (rooms.length === 0) {
                    listEl.innerHTML = '<div class="empty-message">No rooms available</div>';
                    return;
                }
                
                let html = '';
                rooms.forEach(room => {
                    const isJoined = this.joinedRooms[room.room_id];
                    const typeIcon = this._getRoomTypeIcon(room.room_type);
                    html += `
                        <div class="room-item ${isJoined ? 'joined' : ''}" data-room-id="${room.room_id}">
                            <div class="room-icon">${typeIcon}</div>
                            <div class="room-info">
                                <div class="room-name">${room.room_name}${room.is_private ? ' 🔒' : ''}</div>
                                <div class="room-meta">${room.member_count || 0}/${room.capacity} members</div>
                            </div>
                            <div class="room-actions">
                                ${isJoined 
                                    ? `<button class="small-btn danger" onclick="RoomManager.leaveRoom('${room.room_id}')">Leave</button>`
                                    : `<button class="small-btn primary" onclick="RoomManager.joinRoom('${room.room_id}')">Join</button>`
                                }
                            </div>
                        </div>
                    `;
                });
                
                listEl.innerHTML = html;
            },
            
            updateJoinedRoomsList: function() {
                const listEl = document.getElementById('joined-rooms-list');
                if (!listEl) return;
                
                const rooms = Object.values(this.joinedRooms);
                
                if (rooms.length === 0) {
                    listEl.innerHTML = '<div class="empty-message">Not in any rooms</div>';
                    return;
                }
                
                let html = '';
                rooms.forEach(room => {
                    const isActive = room.room_id === this.currentRoomId;
                    const typeIcon = this._getRoomTypeIcon(room.room_type);
                    html += `
                        <div class="room-item joined ${isActive ? 'active' : ''}" 
                             data-room-id="${room.room_id}"
                             onclick="RoomManager.setCurrentRoom('${room.room_id}')">
                            <div class="room-icon">${typeIcon}</div>
                            <div class="room-info">
                                <div class="room-name">${room.room_name}</div>
                                <div class="room-meta">${room.entity_count || 0} entities</div>
                            </div>
                        </div>
                    `;
                });
                
                listEl.innerHTML = html;
            },
            
            updateRoomUI: function() {
                const currentRoomEl = document.getElementById('current-room-name');
                const currentRoom = this.joinedRooms[this.currentRoomId];
                
                if (currentRoomEl) {
                    currentRoomEl.textContent = currentRoom ? currentRoom.room_name : 'No room selected';
                }
            },
            
            _getRoomTypeIcon: function(type) {
                switch (type) {
                    case 'global': return '🌐';
                    case 'mission': return '🎯';
                    case 'team': return '👥';
                    case 'geographic': return '📍';
                    default: return '💬';
                }
            }
        };
        
        // Make globally available
        window.RoomManager = RoomManager;
        
        // =====================================================================
        // WEBSOCKET CLIENT (Bidirectional real-time communication)
        // =====================================================================
        
        const WebSocketSync = {
            socket: null,
            connected: false,
            reconnectAttempts: 0,
            maxReconnectAttempts: 5,
            reconnectDelay: 3000,
            eventHandlers: {},
            useWebSocket: false, // Will be set based on server capability
            
            // Initialize - detect if WebSocket is available
            init: async function() {
                try {
                    const response = await fetch('/api/status');
                    const data = await response.json();
                    this.useWebSocket = data.components?.rooms?.websocket_available || false;
                    console.log(`[WebSocketSync] WebSocket available: ${this.useWebSocket}`);
                } catch (e) {
                    console.warn('[WebSocketSync] Could not detect WebSocket support:', e);
                    this.useWebSocket = false;
                }
            },
            
            // Connect via WebSocket (requires socket.io client)
            connect: function() {
                if (!this.useWebSocket || !OperatorSession.sessionToken) {
                    console.log('[WebSocketSync] Using SSE fallback');
                    EntitySync.connect();
                    return;
                }
                
                // Check if socket.io is loaded
                if (typeof io === 'undefined') {
                    console.warn('[WebSocketSync] socket.io not loaded, falling back to SSE');
                    EntitySync.connect();
                    return;
                }
                
                if (this.socket) {
                    this.disconnect();
                }
                
                const url = `${window.location.origin}?token=${encodeURIComponent(OperatorSession.sessionToken)}`;
                this.socket = io(url, {
                    transports: ['websocket', 'polling'],
                    query: { token: OperatorSession.sessionToken }
                });
                
                const self = this;
                
                this.socket.on('connect', function() {
                    self.connected = true;
                    self.reconnectAttempts = 0;
                    console.log('[WebSocketSync] Connected');
                    addConsoleMessage('🔌 WebSocket connected', 'response');
                    self._notifyHandlers('connected', {});
                });
                
                this.socket.on('disconnect', function() {
                    self.connected = false;
                    console.log('[WebSocketSync] Disconnected');
                    self._notifyHandlers('disconnected', {});
                });
                
                this.socket.on('error', function(error) {
                    console.error('[WebSocketSync] Error:', error);
                    self._notifyHandlers('error', { error });
                });
                
                this.socket.on('connected', function(data) {
                    console.log('[WebSocketSync] Authenticated:', data);
                });
                
                // Entity events
                this.socket.on('entity_event', function(data) {
                    self._handleEntityEvent(data);
                });
                
                // Room events
                this.socket.on('room_joined', function(data) {
                    console.log('[WebSocketSync] Room joined:', data);
                    RoomManager.fetchMyRooms();
                });
                
                this.socket.on('room_left', function(data) {
                    console.log('[WebSocketSync] Room left:', data);
                    RoomManager.fetchMyRooms();
                });
                
                this.socket.on('room_created', function(data) {
                    console.log('[WebSocketSync] Room created:', data);
                    RoomManager.fetchRooms();
                });
                
                this.socket.on('rooms_list', function(data) {
                    if (data.rooms) {
                        RoomManager.rooms = {};
                        data.rooms.forEach(r => RoomManager.rooms[r.room_id] = r);
                        RoomManager.updateRoomsList();
                    }
                });
                
                this.socket.on('heartbeat_ack', function(data) {
                    // Heartbeat acknowledged
                });
            },
            
            // Disconnect WebSocket
            disconnect: function() {
                if (this.socket) {
                    this.socket.disconnect();
                    this.socket = null;
                }
                this.connected = false;
            },
            
            // Handle incoming entity event
            _handleEntityEvent: function(data) {
                const eventType = data.event_type;
                const entityId = data.entity_id;
                
                // Update EntitySync cache
                if (eventType === 'DELETE') {
                    delete EntitySync.entityCache[entityId];
                } else if (entityId) {
                    EntitySync.entityCache[entityId] = {
                        id: entityId,
                        type: data.entity_type,
                        data: data.entity_data,
                        provenance: data.provenance,
                        lastUpdated: data.timestamp
                    };
                }
                
                // Notify handlers
                this._notifyHandlers(eventType.toLowerCase(), data);
                this._notifyHandlers('entity', { eventType, ...data });
                
                // Also notify EntitySync handlers for compatibility
                EntitySync._notifyHandlers(eventType.toLowerCase(), data);
                EntitySync._notifyHandlers('entity', { eventType, ...data });
            },
            
            // Send via WebSocket
            send: function(action, data = {}) {
                if (!this.socket || !this.connected) {
                    console.warn('[WebSocketSync] Not connected');
                    return false;
                }
                
                this.socket.emit(action, data);
                return true;
            },
            
            // Join room via WebSocket
            joinRoom: function(roomId, password = null) {
                return this.send('join_room', { room_id: roomId, password });
            },
            
            // Leave room via WebSocket
            leaveRoom: function(roomId) {
                return this.send('leave_room', { room_id: roomId });
            },
            
            // Create room via WebSocket
            createRoom: function(roomName, options = {}) {
                return this.send('create_room', {
                    room_name: roomName,
                    room_type: options.type || 'custom',
                    capacity: options.capacity || 50,
                    is_private: options.isPrivate || false,
                    password: options.password,
                    metadata: options.metadata
                });
            },
            
            // Publish entity via WebSocket
            publishEntity: function(entityId, entityType, entityData, roomId = null) {
                return this.send('publish_entity', {
                    entity_id: entityId,
                    entity_type: entityType,
                    entity_data: entityData,
                    room_id: roomId
                });
            },
            
            // Send message to room via WebSocket
            sendMessage: function(roomId, message, messageType = 'chat') {
                return this.send('send_message', {
                    room_id: roomId,
                    message: message,
                    message_type: messageType
                });
            },
            
            // Send heartbeat via WebSocket
            sendHeartbeat: function(currentView = null) {
                return this.send('heartbeat', { current_view: currentView });
            },
            
            // Event handlers
            on: function(event, handler) {
                if (!this.eventHandlers[event]) {
                    this.eventHandlers[event] = [];
                }
                this.eventHandlers[event].push(handler);
                return this;
            },
            
            off: function(event, handler) {
                if (this.eventHandlers[event]) {
                    this.eventHandlers[event] = this.eventHandlers[event].filter(h => h !== handler);
                }
                return this;
            },
            
            _notifyHandlers: function(event, data) {
                const handlers = this.eventHandlers[event] || [];
                handlers.forEach(handler => {
                    try {
                        handler(data);
                    } catch (e) {
                        console.error(`[WebSocketSync] Handler error for ${event}:`, e);
                    }
                });
            }
        };
        
        // Make globally available
        window.WebSocketSync = WebSocketSync;

        // =====================================================================
        // AIS STREAM MANAGER - Real-time vessel tracking with zoom filtering
        // =====================================================================
        
        const AISStreamManager = {
            active: false,
            streamSocket: null,
            currentBBox: null,
            updateThrottle: 1000, // ms between bbox updates
            lastBBoxUpdate: 0,
            zoomThreshold: 100000, // Only stream when zoomed closer than 100km altitude
            
            // Initialize and monitor camera for zoom-based streaming
            init: function() {
                const self = this;
                
                // Listen for WebSocket connections
                WebSocketSync.on('connected', function() {
                    console.log('[AISStream] WebSocket connected');
                    self.checkAndStartStream();
                });
                
                // Listen for AIS updates from server
                if (WebSocketSync.socket) {
                    WebSocketSync.socket.on('ais_update', function(vessel) {
                        self.handleVesselUpdate(vessel);
                    });
                }
                
                // Monitor camera changes to update bounding box
                if (viewer && viewer.camera) {
                    viewer.camera.changed.addEventListener(function() {
                        self.onCameraChange();
                    });
                }
                
                console.log('[AISStream] Initialized');
            },
            
            // Check zoom level and start/stop streaming accordingly
            onCameraChange: function() {
                if (!this.active) return;
                
                const now = Date.now();
                if (now - this.lastBBoxUpdate < this.updateThrottle) return;
                
                const altitude = viewer.camera.positionCartographic.height;
                
                // Only stream when zoomed in close enough
                if (altitude < this.zoomThreshold) {
                    this.updateBoundingBox();
                } else if (this.streamSocket) {
                    this.stopStreaming();
                }
            },
            
            // Calculate current visible bounding box
            getCurrentBoundingBox: function() {
                try {
                    const rectangle = viewer.camera.computeViewRectangle();
                    if (!rectangle) return null;
                    
                    const west = Cesium.Math.toDegrees(rectangle.west);
                    const south = Cesium.Math.toDegrees(rectangle.south);
                    const east = Cesium.Math.toDegrees(rectangle.east);
                    const north = Cesium.Math.toDegrees(rectangle.north);
                    
                    // AISStream format: [[[lon_sw, lat_sw], [lon_ne, lat_ne]]]
                    return [[[west, south], [east, north]]];
                } catch (e) {
                    console.warn('[AISStream] Could not compute bbox:', e);
                    return null;
                }
            },
            
            // Update bounding box on server
            updateBoundingBox: function() {
                const bbox = this.getCurrentBoundingBox();
                if (!bbox || JSON.stringify(bbox) === JSON.stringify(this.currentBBox)) {
                    return; // No change
                }
                
                this.currentBBox = bbox;
                this.lastBBoxUpdate = Date.now();
                
                fetch('/api/ais/stream/start', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ bounding_box: bbox })
                })
                .then(r => r.json())
                .then(data => {
                    console.log('[AISStream] Bounding box updated:', bbox);
                })
                .catch(e => console.error('[AISStream] Failed to update bbox:', e));
            },
            
            // Check conditions and start streaming if appropriate
            checkAndStartStream: function() {
                const altitude = viewer?.camera?.positionCartographic?.height || 1000000;
                
                if (altitude < this.zoomThreshold && !this.streamSocket) {
                    this.startStreaming();
                }
            },
            
            // Start AIS streaming
            startStreaming: async function() {
                if (this.active) return;
                
                try {
                    const bbox = this.getCurrentBoundingBox() || [[[-180, -90], [180, 90]]];
                    
                    const response = await fetch('/api/ais/stream/start', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ bounding_box: bbox })
                    });
                    
                    const data = await response.json();
                    
                    if (data.status === 'started') {
                        this.active = true;
                        this.currentBBox = bbox;
                        addConsoleMessage('🚢 AIS real-time streaming started', 'response');
                        console.log('[AISStream] Streaming started with bbox:', bbox);
                    }
                } catch (e) {
                    console.error('[AISStream] Failed to start:', e);
                }
            },
            
            // Stop AIS streaming
            stopStreaming: async function() {
                if (!this.active) return;
                
                try {
                    await fetch('/api/ais/stream/stop', { method: 'POST' });
                    this.active = false;
                    this.currentBBox = null;
                    addConsoleMessage('🚢 AIS streaming stopped', 'response');
                    console.log('[AISStream] Streaming stopped');
                } catch (e) {
                    console.error('[AISStream] Failed to stop:', e);
                }
            },
            
            // Handle real-time vessel update from WebSocket
            handleVesselUpdate: function(vessel) {
                if (!vessel || !vessel.mmsi) return;
                
                // Update AISVisualization vessels data
                if (window.AISVisualization && AISVisualization.visible) {
                    // Add/update vessel in the vessels object
                    AISVisualization.vessels[vessel.mmsi] = {
                        mmsi: vessel.mmsi,
                        lat: vessel.lat,
                        lon: vessel.lon,
                        sog: vessel.speed || 0,
                        cog: vessel.course || 0,
                        heading: vessel.heading || 0,
                        name: vessel.name || `MMSI_${vessel.mmsi}`,
                        vessel_type: vessel.vessel_type || 'Unknown',
                        timestamp: vessel.timestamp
                    };
                    
                    // Check if vessel type should be displayed
                    const normalizedType = AISVisualization._normalizeVesselType(vessel.vessel_type);
                    if (AISVisualization.vesselTypeFilters.includes(normalizedType)) {
                        // Update or add vessel entity
                        AISVisualization.updateVesselPosition(vessel);
                    } else {
                        // Remove vessel entity if it's filtered out
                        if (AISVisualization.vesselEntities[vessel.mmsi]) {
                            AISVisualization.viewer.entities.remove(AISVisualization.vesselEntities[vessel.mmsi]);
                            delete AISVisualization.vesselEntities[vessel.mmsi];
                        }
                    }
                    
                    // Update vessel count
                    const filteredCount = Object.keys(AISVisualization.vesselEntities).length;
                    const countEl = document.getElementById('ais-vessel-count');
                    if (countEl) {
                        countEl.textContent = filteredCount;
                    }
                }
                
                // Legacy support for AISModule
                if (window.AISModule && AISModule.visible) {
                    AISModule.updateVesselPosition(vessel.mmsi, {
                        latitude: vessel.lat,
                        longitude: vessel.lon,
                        speed: vessel.speed,
                        course: vessel.course,
                        heading: vessel.heading,
                        timestamp: vessel.timestamp
                    });
                }
            },
            
            // Get current streaming status
            getStatus: async function() {
                try {
                    const response = await fetch('/api/ais/stream/status');
                    return await response.json();
                } catch (e) {
                    console.error('[AISStream] Failed to get status:', e);
                    return { active: false, bounding_box: null, vessel_count: 0 };
                }
            }
        };
        
        // Make globally available
        window.AISStreamManager = AISStreamManager;

        // =====================================================================
        // UI UPDATE FUNCTIONS FOR OPERATOR STATUS
        // =====================================================================
        
        function updateOperatorStatusUI() {
            const statusEl = document.getElementById('operator-status');
            const loginBtn = document.getElementById('operator-login-btn');
            const logoutBtn = document.getElementById('operator-logout-btn');
            
            if (OperatorSession.isAuthenticated) {
                if (statusEl) {
                    statusEl.innerHTML = `
                        <span class="operator-badge role-${OperatorSession.role}">
                            ${OperatorSession.callsign}
                        </span>
                    `;
                }
                if (loginBtn) loginBtn.style.display = 'none';
                if (logoutBtn) logoutBtn.style.display = 'inline-block';
            } else {
                if (statusEl) {
                    statusEl.innerHTML = '<span class="not-logged-in">Not logged in</span>';
                }
                if (loginBtn) loginBtn.style.display = 'inline-block';
                if (logoutBtn) logoutBtn.style.display = 'none';
            }
        }
        
        function showOperatorLoginDialog() {
            const existingDialog = document.getElementById('operator-login-dialog');
            if (existingDialog) {
                existingDialog.style.display = 'flex';
                return;
            }
            
            const dialog = document.createElement('div');
            dialog.id = 'operator-login-dialog';
            dialog.className = 'modal-overlay';
            dialog.innerHTML = `
                <div class="modal-content" style="max-width: 400px;">
                    <div class="modal-header">
                        <h3>👤 Operator Login</h3>
                        <button class="close-btn" onclick="closeOperatorLoginDialog()">×</button>
                    </div>
                    <div class="modal-body">
                        <div class="form-tabs">
                            <button class="tab-btn active" onclick="switchLoginTab('login')">Login</button>
                            <button class="tab-btn" onclick="switchLoginTab('register')">Register</button>
                        </div>
                        
                        <div id="login-form" class="tab-content active">
                            <div class="form-group">
                                <label>Callsign:</label>
                                <input type="text" id="login-callsign" placeholder="e.g., ALPHA-1" autocomplete="username">
                            </div>
                            <div class="form-group">
                                <label>Password:</label>
                                <input type="password" id="login-password" placeholder="Password" autocomplete="current-password">
                            </div>
                            <div id="login-error" class="error-message" style="display: none;"></div>
                            <button class="action-btn primary" onclick="doOperatorLogin()">Login</button>
                        </div>
                        
                        <div id="register-form" class="tab-content">
                            <div class="form-group">
                                <label>Callsign:</label>
                                <input type="text" id="register-callsign" placeholder="e.g., ALPHA-1" autocomplete="username">
                            </div>
                            <div class="form-group">
                                <label>Email:</label>
                                <input type="email" id="register-email" placeholder="operator@command.local" autocomplete="email">
                            </div>
                            <div class="form-group">
                                <label>Password:</label>
                                <input type="password" id="register-password" placeholder="Password" autocomplete="new-password">
                            </div>
                            <div class="form-group">
                                <label>Role:</label>
                                <select id="register-role">
                                    <option value="observer">Observer (Read Only)</option>
                                    <option value="operator" selected>Operator</option>
                                    <option value="supervisor">Supervisor</option>
                                </select>
                            </div>
                            <div id="register-error" class="error-message" style="display: none;"></div>
                            <button class="action-btn primary" onclick="doOperatorRegister()">Register & Login</button>
                        </div>
                    </div>
                </div>
            `;
            
            document.body.appendChild(dialog);
        }
        
        function closeOperatorLoginDialog() {
            const dialog = document.getElementById('operator-login-dialog');
            if (dialog) {
                dialog.style.display = 'none';
            }
        }
        
        function switchLoginTab(tab) {
            document.querySelectorAll('.form-tabs .tab-btn').forEach(btn => {
                btn.classList.toggle('active', btn.textContent.toLowerCase().includes(tab));
            });
            document.getElementById('login-form').classList.toggle('active', tab === 'login');
            document.getElementById('register-form').classList.toggle('active', tab === 'register');
        }
        
        async function doOperatorLogin() {
            const callsign = document.getElementById('login-callsign').value.trim();
            const password = document.getElementById('login-password').value;
            const errorEl = document.getElementById('login-error');
            
            if (!callsign || !password) {
                errorEl.textContent = 'Please enter callsign and password';
                errorEl.style.display = 'block';
                return;
            }
            
            errorEl.style.display = 'none';
            const result = await OperatorSession.login(callsign, password);
            
            if (result.success) {
                closeOperatorLoginDialog();
            } else {
                errorEl.textContent = result.message || 'Login failed';
                errorEl.style.display = 'block';
            }
        }
        
        async function doOperatorRegister() {
            const callsign = document.getElementById('register-callsign').value.trim();
            const email = document.getElementById('register-email').value.trim();
            const password = document.getElementById('register-password').value;
            const role = document.getElementById('register-role').value;
            const errorEl = document.getElementById('register-error');
            
            if (!callsign || !email || !password) {
                errorEl.textContent = 'Please fill in all fields';
                errorEl.style.display = 'block';
                return;
            }
            
            errorEl.style.display = 'none';
            const result = await OperatorSession.register(callsign, email, password, role);
            
            if (result.success) {
                closeOperatorLoginDialog();
            } else {
                errorEl.textContent = result.message || 'Registration failed';
                errorEl.style.display = 'block';
            }
        }
        
        // Helper functions for operator panel
        function updateSyncIndicator(connected) {
            const dot = document.getElementById('entity-sync-dot');
            const status = document.getElementById('entity-sync-status');
            const panelStatus = document.getElementById('operator-sync-status');
            
            if (dot) {
                dot.classList.toggle('connected', connected);
                dot.classList.toggle('disconnected', !connected);
            }
            if (status) {
                status.textContent = connected ? 'Connected' : 'Offline';
                status.style.color = connected ? '#00ff00' : '#888';
            }
            if (panelStatus) {
                panelStatus.textContent = connected ? '🟢 Online' : '🔴 Offline';
                panelStatus.style.color = connected ? '#00ff00' : '#ff4444';
            }
        }
        
        function updateOperatorPanelStats() {
            if (typeof EntitySync !== 'undefined') {
                const cachedEl = document.getElementById('operator-cached-count');
                if (cachedEl) {
                    cachedEl.textContent = Object.keys(EntitySync.entityCache).length;
                }
            }
            
            if (typeof OperatorPresence !== 'undefined') {
                const activeEl = document.getElementById('operator-active-count');
                if (activeEl) {
                    activeEl.textContent = Object.keys(OperatorPresence.operators).length;
                }
            }
            
            // Update session info panel
            updateSessionInfoPanel();
        }
        
        function updateSessionInfoPanel() {
            const infoEl = document.getElementById('operator-session-info');
            if (!infoEl) return;
            
            if (OperatorSession.isAuthenticated) {
                infoEl.innerHTML = `
                    <div style="padding: 10px; background: rgba(42, 42, 42, 0.8); border-radius: 4px;">
                        <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 10px;">
                            <span class="operator-badge role-${OperatorSession.role}">${OperatorSession.callsign}</span>
                        </div>
                        <div style="font-size: 11px; color: #888;">
                            <div>Role: ${OperatorSession.role}</div>
                            <div>Email: ${OperatorSession.operatorName}</div>
                            ${OperatorSession.teamId ? `<div>Team: ${OperatorSession.teamId}</div>` : ''}
                        </div>
                    </div>
                `;
            } else {
                infoEl.innerHTML = `
                    <div style="padding: 10px; background: rgba(42, 42, 42, 0.8); border-radius: 4px; text-align: center;">
                        <p style="color: #888; margin: 0 0 10px 0;">Not logged in</p>
                        <button class="action-button" onclick="showOperatorLoginDialog()" style="width: 100%;">
                            🔐 Login / Register
                        </button>
                    </div>
                `;
            }
        }
        
        function logEntityEvent(data) {
            const logEl = document.getElementById('entity-stream-log');
            if (!logEl) return;
            
            const time = new Date().toLocaleTimeString();
            const editor = data.provenance?.source_description || 'System';
            const eventColor = {
                'PREEXISTING': '#888',
                'CREATE': '#00ff00',
                'UPDATE': '#ffaa00',
                'DELETE': '#ff4444'
            }[data.eventType] || '#fff';
            
            const entry = document.createElement('div');
            entry.style.color = eventColor;
            entry.style.marginBottom = '2px';
            entry.textContent = `[${time}] ${data.eventType}: ${data.entity_id} (${data.entity_type}) - ${editor}`;
            
            logEl.insertBefore(entry, logEl.firstChild);
            
            // Keep only last 50 entries
            while (logEl.children.length > 50) {
                logEl.removeChild(logEl.lastChild);
            }
        }
        
        async function publishTestEntity() {
            if (!OperatorSession.isAuthenticated) {
                addConsoleMessage('⚠️ Please log in to publish entities', 'alert');
                return;
            }
            
            const entityId = document.getElementById('test-entity-id')?.value || `test-${Date.now()}`;
            const entityType = document.getElementById('test-entity-type')?.value || 'marker';
            
            // Get current camera position for test entity
            let position = { lat: 40.7, lon: -74.0, alt: 0 };
            if (window.viewer && window.viewer.camera) {
                const pos = window.viewer.camera.positionCartographic;
                position = {
                    lat: Cesium.Math.toDegrees(pos.latitude),
                    lon: Cesium.Math.toDegrees(pos.longitude),
                    alt: 0
                };
            }
            
            const result = await EntitySync.publishEntity(entityId, entityType, {
                name: `Test ${entityType}`,
                position: position,
                created: new Date().toISOString()
            });
            
            if (result.success) {
                addConsoleMessage(`✅ Published entity: ${entityId} (${result.event_type})`, 'response');
            } else {
                addConsoleMessage(`❌ Failed to publish: ${result.message}`, 'alert');
            }
        }
        
        // =====================================================================
        // ROOM/CHANNEL HELPER FUNCTIONS
        // =====================================================================
        
        function showCreateRoomDialog() {
            if (!OperatorSession.isAuthenticated) {
                addConsoleMessage('⚠️ Please log in to create rooms', 'alert');
                return;
            }
            
            const existingDialog = document.getElementById('create-room-dialog');
            if (existingDialog) {
                existingDialog.style.display = 'flex';
                return;
            }
            
            const dialog = document.createElement('div');
            dialog.id = 'create-room-dialog';
            dialog.className = 'modal-overlay';
            dialog.innerHTML = `
                <div class="modal-content" style="max-width: 400px;">
                    <div class="modal-header">
                        <h3>🏠 Create New Room</h3>
                        <button class="close-btn" onclick="closeCreateRoomDialog()">×</button>
                    </div>
                    <div class="modal-body">
                        <div class="form-group">
                            <label>Room Name:</label>
                            <input type="text" id="new-room-name" placeholder="e.g., Operation Alpha" style="width: 100%;">
                        </div>
                        <div class="form-group">
                            <label>Room Type:</label>
                            <select id="new-room-type" style="width: 100%;">
                                <option value="custom">💬 Custom</option>
                                <option value="mission">🎯 Mission</option>
                                <option value="team">👥 Team</option>
                                <option value="geographic">📍 Geographic</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label>Max Capacity:</label>
                            <input type="number" id="new-room-capacity" value="50" min="2" max="500" style="width: 100%;">
                        </div>
                        <div class="form-group">
                            <label>
                                <input type="checkbox" id="new-room-private"> Private Room (requires password)
                            </label>
                        </div>
                        <div class="form-group" id="room-password-group" style="display: none;">
                            <label>Password:</label>
                            <input type="password" id="new-room-password" placeholder="Room password" style="width: 100%;">
                        </div>
                        <div id="create-room-error" class="error-message" style="display: none;"></div>
                        <button class="action-btn primary" onclick="doCreateRoom()" style="width: 100%; margin-top: 15px;">
                            Create Room
                        </button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(dialog);
            
            // Toggle password field visibility
            document.getElementById('new-room-private').addEventListener('change', function() {
                document.getElementById('room-password-group').style.display = this.checked ? 'block' : 'none';
            });
        }
        
        function closeCreateRoomDialog() {
            const dialog = document.getElementById('create-room-dialog');
            if (dialog) {
                dialog.style.display = 'none';
            }
        }
        
        async function doCreateRoom() {
            const roomName = document.getElementById('new-room-name').value.trim();
            const roomType = document.getElementById('new-room-type').value;
            const capacity = parseInt(document.getElementById('new-room-capacity').value) || 50;
            const isPrivate = document.getElementById('new-room-private').checked;
            const password = document.getElementById('new-room-password')?.value;
            const errorEl = document.getElementById('create-room-error');
            
            if (!roomName) {
                errorEl.textContent = 'Please enter a room name';
                errorEl.style.display = 'block';
                return;
            }
            
            errorEl.style.display = 'none';
            
            const result = await RoomManager.createRoom(roomName, {
                type: roomType,
                capacity: capacity,
                isPrivate: isPrivate,
                password: isPrivate ? password : null
            });
            
            if (result.success) {
                closeCreateRoomDialog();
                RoomManager.setCurrentRoom(result.room.room_id);
            } else {
                errorEl.textContent = result.message || 'Failed to create room';
                errorEl.style.display = 'block';
            }
        }
        
        function sendRoomChatMessage() {
            const input = document.getElementById('room-chat-input');
            const message = input?.value.trim();
            
            if (!message) return;
            
            if (!OperatorSession.isAuthenticated) {
                addConsoleMessage('⚠️ Please log in to send messages', 'alert');
                return;
            }
            
            if (!RoomManager.currentRoomId) {
                addConsoleMessage('⚠️ Please select a room first', 'alert');
                return;
            }
            
            // Send via WebSocket if available, otherwise via REST
            if (WebSocketSync.connected) {
                WebSocketSync.sendMessage(RoomManager.currentRoomId, message);
            } else {
                RoomManager.sendMessage(RoomManager.currentRoomId, message);
            }
            
            // Clear input
            input.value = '';
        }
        
        function addRoomChatMessage(data) {
            const chatLog = document.getElementById('room-chat-log');
            if (!chatLog) return;
            
            // Clear placeholder if first message
            if (chatLog.querySelector('.empty-message') || chatLog.textContent.includes('Join a room')) {
                chatLog.innerHTML = '';
            }
            
            const time = new Date(data.timestamp || Date.now()).toLocaleTimeString();
            const isMe = data.sender_id === OperatorSession.operatorId;
            
            const msgEl = document.createElement('div');
            msgEl.className = 'chat-message';
            msgEl.innerHTML = `
                <span class="sender" style="color: ${isMe ? '#0f0' : '#0af'}">${data.sender_callsign || 'Unknown'}</span>
                <span class="time">${time}</span>
                <div class="text">${escapeHtml(data.message)}</div>
            `;
            
            chatLog.appendChild(msgEl);
            chatLog.scrollTop = chatLog.scrollHeight;
            
            // Keep only last 100 messages
            while (chatLog.children.length > 100) {
                chatLog.removeChild(chatLog.firstChild);
            }
        }
        
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // =====================================================================
        // POINTS OF INTEREST (POI) VISUALIZATION
        // =====================================================================
        
        const POIVisualization = {
            viewer: null,
            pois: [],
            poiEntities: {},
            dataSource: null,
            visible: true,
            showLabels: true,
            categories: {},
            categoryVisibility: {},
            
            // Category colors for different POI types
            CATEGORY_COLORS: {
                'intelligence': Cesium.Color.RED,
                'military': Cesium.Color.DARKRED,
                'infrastructure': Cesium.Color.ORANGE,
                'commercial': Cesium.Color.BLUE,
                'government': Cesium.Color.PURPLE,
                'residential': Cesium.Color.GREEN,
                'transportation': Cesium.Color.CYAN,
                'imported': Cesium.Color.YELLOW,
                'manual': Cesium.Color.WHITE,
                'general': Cesium.Color.GRAY
            },
            
            // Category icons (Cesium pin colors)
            CATEGORY_ICONS: {
                'intelligence': Cesium.Color.RED,
                'military': Cesium.Color.MAROON,
                'infrastructure': Cesium.Color.ORANGE,
                'commercial': Cesium.Color.ROYALBLUE,
                'government': Cesium.Color.PURPLE,
                'general': Cesium.Color.YELLOW
            },
            
            initialize: function(cesiumViewer) {
                this.viewer = cesiumViewer;
                this.dataSource = new Cesium.CustomDataSource('POIs');
                this.viewer.dataSources.add(this.dataSource);
                console.log('[POI] Visualization initialized');
                
                // Load POIs from server
                this.loadPOIs();
            },
            
            async loadPOIs() {
                try {
                    addConsoleMessage('Loading Points of Interest...', 'info');
                    const response = await fetch('/api/poi/visualization');
                    const data = await response.json();
                    
                    if (data.status === 'ok') {
                        this.pois = data.pois || [];
                        this.categories = data.categories || {};
                        
                        // Initialize category visibility (all visible by default)
                        Object.keys(this.categories).forEach(cat => {
                            this.categoryVisibility[cat] = true;
                        });
                        
                        // Create visualization entities
                        this.createEntities();
                        
                        addConsoleMessage(`Loaded ${this.pois.length} POIs in ${Object.keys(this.categories).length} categories`, 'response');
                        console.log('[POI] Loaded POIs:', this.pois.length);
                    } else {
                        console.warn('[POI] Failed to load POIs:', data.message);
                        addConsoleMessage('POI system not available', 'alert');
                    }
                } catch (error) {
                    console.error('[POI] Error loading POIs:', error);
                    addConsoleMessage('Error loading POIs: ' + error.message, 'alert');
                }
            },
            
            createEntities: function() {
                // Clear existing entities
                this.dataSource.entities.removeAll();
                this.poiEntities = {};
                
                this.pois.forEach(poi => {
                    this.createPOIEntity(poi);
                });
                
                console.log(`[POI] Created ${Object.keys(this.poiEntities).length} POI entities`);
            },
            
            createPOIEntity: function(poi) {
                if (!this.viewer || !poi.latitude || !poi.longitude) return;
                
                const category = poi.category || 'general';
                const color = this.CATEGORY_COLORS[category] || Cesium.Color.YELLOW;
                const iconColor = this.CATEGORY_ICONS[category] || Cesium.Color.YELLOW;
                
                // Parse metadata if it's a string
                let metadata = poi.metadata;
                if (typeof metadata === 'string') {
                    try {
                        metadata = JSON.parse(metadata);
                    } catch (e) {
                        metadata = {};
                    }
                }
                
                // Create pin billboard
                const entity = this.dataSource.entities.add({
                    id: `poi_${poi.id}`,
                    name: poi.name,
                    description: this.createPOIDescription(poi, metadata),
                    position: Cesium.Cartesian3.fromDegrees(
                        poi.longitude,
                        poi.latitude,
                        poi.altitude || 0
                    ),
                    billboard: {
                        image: this.createPinCanvas(iconColor),
                        verticalOrigin: Cesium.VerticalOrigin.BOTTOM,
                        heightReference: Cesium.HeightReference.CLAMP_TO_GROUND,
                        scale: 0.8,
                        disableDepthTestDistance: Number.POSITIVE_INFINITY
                    },
                    label: this.showLabels ? {
                        text: poi.name,
                        font: '12px sans-serif',
                        fillColor: Cesium.Color.WHITE,
                        outlineColor: Cesium.Color.BLACK,
                        outlineWidth: 2,
                        style: Cesium.LabelStyle.FILL_AND_OUTLINE,
                        verticalOrigin: Cesium.VerticalOrigin.TOP,
                        pixelOffset: new Cesium.Cartesian2(0, 10),
                        heightReference: Cesium.HeightReference.CLAMP_TO_GROUND,
                        disableDepthTestDistance: Number.POSITIVE_INFINITY,
                        scaleByDistance: new Cesium.NearFarScalar(1.5e2, 1.0, 1.5e7, 0.3)
                    } : undefined,
                    properties: {
                        poiId: poi.id,
                        category: category,
                        sourceFile: poi.source_file,
                        metadata: metadata
                    }
                });
                
                this.poiEntities[poi.id] = entity;
                return entity;
            },
            
            createPinCanvas: function(color) {
                // Create a colored pin icon using canvas
                const canvas = document.createElement('canvas');
                canvas.width = 48;
                canvas.height = 48;
                const ctx = canvas.getContext('2d');
                
                // Draw pin shape
                ctx.beginPath();
                ctx.moveTo(24, 48);  // Bottom point
                ctx.bezierCurveTo(24, 32, 8, 28, 8, 16);
                ctx.arc(24, 16, 16, Math.PI, 0, false);
                ctx.bezierCurveTo(40, 28, 24, 32, 24, 48);
                ctx.closePath();
                
                // Fill with gradient
                const gradient = ctx.createRadialGradient(24, 16, 0, 24, 16, 16);
                const cssColor = `rgba(${Math.floor(color.red * 255)}, ${Math.floor(color.green * 255)}, ${Math.floor(color.blue * 255)}, 1)`;
                const darkColor = `rgba(${Math.floor(color.red * 180)}, ${Math.floor(color.green * 180)}, ${Math.floor(color.blue * 180)}, 1)`;
                gradient.addColorStop(0, cssColor);
                gradient.addColorStop(1, darkColor);
                ctx.fillStyle = gradient;
                ctx.fill();
                
                // Draw border
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // Draw inner circle
                ctx.beginPath();
                ctx.arc(24, 16, 6, 0, 2 * Math.PI);
                ctx.fillStyle = 'white';
                ctx.fill();
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.lineWidth = 1;
                ctx.stroke();
                
                return canvas.toDataURL();
            },
            
            createPOIDescription: function(poi, metadata) {
                let desc = `<div style="padding: 10px; font-family: Arial, sans-serif;">`;
                desc += `<h3 style="margin: 0 0 10px 0; color: #ffd700;">${poi.name}</h3>`;
                
                if (poi.description) {
                    desc += `<p style="margin: 5px 0;">${poi.description}</p>`;
                }
                
                desc += `<table style="width: 100%; border-collapse: collapse;">`;
                desc += `<tr><td style="padding: 3px; color: #888;">Category:</td><td style="padding: 3px;">${poi.category}</td></tr>`;
                desc += `<tr><td style="padding: 3px; color: #888;">Coordinates:</td><td style="padding: 3px;">${poi.latitude.toFixed(6)}, ${poi.longitude.toFixed(6)}</td></tr>`;
                
                if (poi.source_file) {
                    desc += `<tr><td style="padding: 3px; color: #888;">Source:</td><td style="padding: 3px;">${poi.source_file}</td></tr>`;
                }
                
                // Add metadata if available
                if (metadata) {
                    if (metadata.time_begin) {
                        desc += `<tr><td style="padding: 3px; color: #888;">Time Begin:</td><td style="padding: 3px;">${metadata.time_begin}</td></tr>`;
                    }
                    if (metadata.time_end) {
                        desc += `<tr><td style="padding: 3px; color: #888;">Time End:</td><td style="padding: 3px;">${metadata.time_end}</td></tr>`;
                    }
                    if (metadata.view_range) {
                        desc += `<tr><td style="padding: 3px; color: #888;">View Range:</td><td style="padding: 3px;">${(metadata.view_range / 1000).toFixed(1)} km</td></tr>`;
                    }
                }
                
                desc += `</table></div>`;
                return desc;
            },
            
            flyToPOI: function(poiId) {
                const entity = this.poiEntities[poiId];
                if (!entity || !this.viewer) return;
                
                const self = this;
                this.viewer.flyTo(entity, {
                    duration: 2.0,
                    offset: new Cesium.HeadingPitchRange(0, -Math.PI / 4, 100000)
                }).then(function() {
                    // Reset camera transform after flyTo
                    self.viewer.camera.lookAtTransform(Cesium.Matrix4.IDENTITY);
                    self.viewer.trackedEntity = undefined;
                    
                    const controller = self.viewer.scene.screenSpaceCameraController;
                    controller.enableRotate = true;
                    controller.enableTilt = true;
                    controller.enableZoom = true;
                    controller.enableTranslate = true;
                    controller.enableLook = true;
                });
                
                addConsoleMessage(`Flying to POI: ${entity.name}`, 'info');
            },
            
            flyToAllPOIs: function() {
                if (!this.viewer || this.pois.length === 0) return;
                
                // Calculate bounding sphere for all POIs
                const positions = this.pois.map(poi => 
                    Cesium.Cartesian3.fromDegrees(poi.longitude, poi.latitude, poi.altitude || 0)
                );
                
                if (positions.length > 0) {
                    const boundingSphere = Cesium.BoundingSphere.fromPoints(positions);
                    const self = this;
                    
                    this.viewer.camera.flyToBoundingSphere(boundingSphere, {
                        duration: 2.5,
                        offset: new Cesium.HeadingPitchRange(0, -Math.PI / 4, boundingSphere.radius * 2.5),
                        complete: function() {
                            // Use ensureCameraFree if available, otherwise manual reset
                            if (typeof ensureCameraFree === 'function') {
                                ensureCameraFree();
                            } else {
                                self.viewer.camera.lookAtTransform(Cesium.Matrix4.IDENTITY);
                                self.viewer.trackedEntity = undefined;
                            }
                            // Always re-enable all camera controls
                            const controller = self.viewer.scene.screenSpaceCameraController;
                            controller.enableRotate = true;
                            controller.enableTilt = true;
                            controller.enableZoom = true;
                            controller.enableTranslate = true;
                            controller.enableLook = true;
                        }
                    });
                    
                    addConsoleMessage(`Flying to view all ${this.pois.length} POIs`, 'info');
                }
            },
            
            setVisible: function(visible) {
                this.visible = visible;
                this.dataSource.show = visible;
                console.log(`[POI] Visibility set to ${visible}`);
            },
            
            setCategoryVisible: function(category, visible) {
                this.categoryVisibility[category] = visible;
                
                // Update entity visibility for this category
                this.pois.forEach(poi => {
                    if (poi.category === category) {
                        const entity = this.poiEntities[poi.id];
                        if (entity) {
                            entity.show = visible && this.visible;
                        }
                    }
                });
            },
            
            toggleLabels: function(show) {
                this.showLabels = show;
                // Recreate entities to update labels
                this.createEntities();
            },
            
            async addPOI(name, latitude, longitude, category = 'manual', description = '') {
                try {
                    const response = await fetch('/api/poi/add', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            name: name,
                            latitude: latitude,
                            longitude: longitude,
                            category: category,
                            description: description
                        })
                    });
                    
                    const data = await response.json();
                    if (data.status === 'ok') {
                        addConsoleMessage(`POI "${name}" added successfully`, 'response');
                        // Reload POIs to get the new one
                        await this.loadPOIs();
                        return data.poi_id;
                    } else {
                        addConsoleMessage('Failed to add POI: ' + data.message, 'alert');
                        return null;
                    }
                } catch (error) {
                    console.error('[POI] Error adding POI:', error);
                    addConsoleMessage('Error adding POI: ' + error.message, 'alert');
                    return null;
                }
            },
            
            async deletePOI(poiId) {
                try {
                    const response = await fetch(`/api/poi/delete/${poiId}`, {
                        method: 'DELETE'
                    });
                    
                    const data = await response.json();
                    if (data.status === 'ok') {
                        addConsoleMessage(`POI deleted successfully`, 'response');
                        // Remove from local data
                        const entity = this.poiEntities[poiId];
                        if (entity) {
                            this.dataSource.entities.remove(entity);
                            delete this.poiEntities[poiId];
                        }
                        this.pois = this.pois.filter(p => p.id !== poiId);
                        return true;
                    } else {
                        addConsoleMessage('Failed to delete POI: ' + data.message, 'alert');
                        return false;
                    }
                } catch (error) {
                    console.error('[POI] Error deleting POI:', error);
                    return false;
                }
            },
            
            getStatus: function() {
                return {
                    visible: this.visible,
                    totalPOIs: this.pois.length,
                    categories: this.categories,
                    entitiesCreated: Object.keys(this.poiEntities).length
                };
            }
        };
        
        // Make POI visualization globally available
        window.POIVisualization = POIVisualization;

        // =====================================================================
        // AUTO-RECONNAISSANCE VISUALIZATION
        // =====================================================================
        
        const AutoReconVisualization = {
            viewer: null,
            entities: {},
            entityMarkers: {},
            proximityCircles: {},
            taskLines: {},
            alerts: [],
            visible: false,
            showProximityRings: true,
            showLabels: true,
            autoUpdate: false,
            updateInterval: null,
            referencePoint: { lat: 37.7749, lon: -122.4194 },
            
            // Clustering support
            dataSource: null,
            clusteringEnabled: true,
            quadtree: null,
            
            // Disposition colors matching MIL-STD-2525
            DISPOSITION_COLORS: {
                'UNKNOWN': Cesium.Color.YELLOW,
                'PENDING': Cesium.Color.YELLOW,
                'ASSUMED_FRIEND': Cesium.Color.BLUE.withAlpha(0.8),
                'FRIEND': Cesium.Color.BLUE,
                'NEUTRAL': Cesium.Color.LIME,
                'SUSPICIOUS': Cesium.Color.ORANGE,
                'HOSTILE': Cesium.Color.RED,
                'JOKER': Cesium.Color.MAGENTA,
                'FAKER': Cesium.Color.PURPLE
            },
            
            // Threat level colors
            THREAT_COLORS: {
                'CRITICAL': Cesium.Color.RED,
                'HIGH': Cesium.Color.ORANGERED,
                'MEDIUM': Cesium.Color.ORANGE,
                'LOW': Cesium.Color.YELLOW,
                'MINIMAL': Cesium.Color.LIME,
                'NONE': Cesium.Color.CYAN
            },
            
            initialize: function(cesiumViewer) {
                this.viewer = cesiumViewer;
                console.log('Auto-Recon Visualization initialized');
                
                // Setup clustered data source if HierarchicalRenderManager is available
                if (typeof HierarchicalRenderManager !== 'undefined' && HierarchicalRenderManager.viewer) {
                    this.dataSource = HierarchicalRenderManager.createClusteredDataSource('Recon_Entities', {
                        pixelRange: 45,
                        minimumClusterSize: 2
                    });
                    
                    // Setup custom cluster styling for recon entities
                    this.setupClusterStyling();
                }
                
                this.setupEventListeners();
                
                // Listen for altitude changes
                this.setupAltitudeListener();
                
                return this;
            },
            
            setupClusterStyling: function() {
                if (!this.dataSource) return;
                
                const self = this;
                
                this.dataSource.clustering.clusterEvent.addEventListener(function(clusteredEntities, cluster) {
                    // Analyze dispositions in cluster
                    const dispositionCounts = {
                        'HOSTILE': 0,
                        'SUSPICIOUS': 0,
                        'UNKNOWN': 0,
                        'NEUTRAL': 0,
                        'FRIEND': 0
                    };
                    
                    let maxThreat = 'NONE';
                    const threatOrder = ['NONE', 'MINIMAL', 'LOW', 'MEDIUM', 'HIGH', 'CRITICAL'];
                    
                    clusteredEntities.forEach(entity => {
                        const props = entity.properties;
                        if (props && props.entityData) {
                            const data = props.entityData.getValue();
                            if (data.disposition && dispositionCounts[data.disposition] !== undefined) {
                                dispositionCounts[data.disposition]++;
                            }
                            
                            // Track highest threat level
                            if (data.threat_level && threatOrder.indexOf(data.threat_level) > threatOrder.indexOf(maxThreat)) {
                                maxThreat = data.threat_level;
                            }
                        }
                    });
                    
                    // Determine cluster color based on dispositions (prioritize hostile)
                    let clusterColor;
                    if (dispositionCounts['HOSTILE'] > 0) {
                        clusterColor = self.DISPOSITION_COLORS['HOSTILE'];
                    } else if (dispositionCounts['SUSPICIOUS'] > 0) {
                        clusterColor = self.DISPOSITION_COLORS['SUSPICIOUS'];
                    } else if (dispositionCounts['UNKNOWN'] > 0) {
                        clusterColor = self.DISPOSITION_COLORS['UNKNOWN'];
                    } else if (dispositionCounts['NEUTRAL'] > 0) {
                        clusterColor = self.DISPOSITION_COLORS['NEUTRAL'];
                    } else {
                        clusterColor = self.DISPOSITION_COLORS['FRIEND'];
                    }
                    
                    // Style the cluster
                    cluster.label.text = clusteredEntities.length.toString();
                    cluster.label.font = 'bold 14px sans-serif';
                    cluster.label.fillColor = Cesium.Color.WHITE;
                    cluster.label.outlineColor = Cesium.Color.BLACK;
                    cluster.label.outlineWidth = 2;
                    cluster.label.style = Cesium.LabelStyle.FILL_AND_OUTLINE;
                    cluster.label.verticalOrigin = Cesium.VerticalOrigin.CENTER;
                    cluster.label.horizontalOrigin = Cesium.HorizontalOrigin.CENTER;
                    
                    // Create tactical cluster icon
                    cluster.billboard.image = self.createTacticalClusterIcon(
                        clusteredEntities.length, 
                        clusterColor, 
                        dispositionCounts,
                        maxThreat
                    );
                    cluster.billboard.width = 44;
                    cluster.billboard.height = 44;
                });
            },
            
            createTacticalClusterIcon: function(count, color, dispositions, threatLevel) {
                const size = Math.min(60, 36 + Math.sqrt(count) * 4);
                const canvas = document.createElement('canvas');
                canvas.width = size;
                canvas.height = size;
                const ctx = canvas.getContext('2d');
                
                // Threat glow effect for high/critical threats
                if (threatLevel === 'HIGH' || threatLevel === 'CRITICAL') {
                    ctx.beginPath();
                    ctx.arc(size/2, size/2, size/2, 0, 2 * Math.PI);
                    const gradient = ctx.createRadialGradient(size/2, size/2, 0, size/2, size/2, size/2);
                    gradient.addColorStop(0, threatLevel === 'CRITICAL' ? 'rgba(255,0,0,0.6)' : 'rgba(255,100,0,0.4)');
                    gradient.addColorStop(1, 'rgba(255,0,0,0)');
                    ctx.fillStyle = gradient;
                    ctx.fill();
                }
                
                // Main circle
                ctx.beginPath();
                ctx.arc(size/2, size/2, size/2 - 4, 0, 2 * Math.PI);
                ctx.fillStyle = color.withAlpha(0.85).toCssColorString();
                ctx.fill();
                
                // Border
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // Tactical diamond shape in center
                ctx.beginPath();
                const dSize = size / 4;
                ctx.moveTo(size/2, size/2 - dSize);
                ctx.lineTo(size/2 + dSize, size/2);
                ctx.lineTo(size/2, size/2 + dSize);
                ctx.lineTo(size/2 - dSize, size/2);
                ctx.closePath();
                ctx.fillStyle = 'rgba(255,255,255,0.9)';
                ctx.fill();
                
                return canvas.toDataURL();
            },
            
            setupAltitudeListener: function() {
                const self = this;
                
                document.addEventListener('altitudeChanged', function(e) {
                    if (!self.visible) return;
                    
                    const shouldShowLabels = HierarchicalRenderManager.shouldShowDetail('labels');
                    const shouldShowRings = HierarchicalRenderManager.shouldShowDetail('rings');
                    
                    // Update label visibility based on altitude
                    self.updateLabelVisibilityForAltitude(shouldShowLabels);
                    
                    // Update proximity rings visibility based on altitude
                    self.updateProximityRingsForAltitude(shouldShowRings);
                });
            },
            
            updateLabelVisibilityForAltitude: function(show) {
                const entityCollection = this.dataSource ? this.dataSource.entities : this.viewer.entities;
                
                entityCollection.values.forEach(entity => {
                    if (entity.id && entity.id.startsWith('recon_entity_') && entity.label) {
                        entity.label.show = show && this.showLabels;
                    }
                });
            },
            
            updateProximityRingsForAltitude: function(show) {
                Object.values(this.proximityCircles).forEach(ring => {
                    if (ring && ring.ellipse) {
                        ring.show = show && this.showProximityRings;
                    }
                });
            },
            
            setupEventListeners: function() {
                const self = this;
                
                // Toggle Recon entities
                const reconToggle = document.getElementById('toggleReconEntities');
                if (reconToggle) {
                    reconToggle.addEventListener('change', function(e) {
                        if (e.target.checked) {
                            self.show();
                        } else {
                            self.hide();
                        }
                    });
                }
                
                // Proximity rings toggle
                const ringsToggle = document.getElementById('reconShowRings');
                if (ringsToggle) {
                    ringsToggle.addEventListener('change', function(e) {
                        self.showProximityRings = e.target.checked;
                        self.updateProximityRingsVisibility();
                    });
                }
                
                // Labels toggle
                const labelsToggle = document.getElementById('reconShowLabels');
                if (labelsToggle) {
                    labelsToggle.addEventListener('change', function(e) {
                        self.showLabels = e.target.checked;
                        self.updateLabelVisibility();
                    });
                }
                
                // Auto-update toggle
                const autoUpdateToggle = document.getElementById('reconAutoUpdate');
                if (autoUpdateToggle) {
                    autoUpdateToggle.addEventListener('change', function(e) {
                        self.autoUpdate = e.target.checked;
                        if (self.autoUpdate) {
                            self.startAutoUpdate();
                        } else {
                            self.stopAutoUpdate();
                        }
                    });
                }
                
                // Set reference point button
                const setRefBtn = document.getElementById('reconSetReference');
                if (setRefBtn) {
                    setRefBtn.addEventListener('click', function() {
                        self.setReferenceFromView();
                    });
                }
                
                // Check alerts button
                const alertsBtn = document.getElementById('reconCheckAlerts');
                if (alertsBtn) {
                    alertsBtn.addEventListener('click', function() {
                        self.loadAlerts();
                    });
                }
            },
            
            show: function() {
                this.visible = true;
                const filtersEl = document.getElementById('reconFilters');
                if (filtersEl) filtersEl.style.display = 'block';
                this.loadEntities();
            },
            
            hide: function() {
                this.visible = false;
                const filtersEl = document.getElementById('reconFilters');
                if (filtersEl) filtersEl.style.display = 'none';
                this.clearAllEntities();
                this.stopAutoUpdate();
            },
            
            loadEntities: async function() {
                try {
                    addConsoleMessage('Loading Auto-Recon entities...', 'command');
                    
                    const response = await fetch('/api/recon/entities');
                    const data = await response.json();
                    
                    if (data.status === 'ok') {
                        this.entities = {};
                        data.entities.forEach(e => {
                            // Normalize entity structure: some entities have data nested in 'data' field
                            let normalized = e;
                            if (e.data && typeof e.data === 'object') {
                                // Merge nested data to top level, preserving entity_id
                                normalized = { ...e.data, entity_id: e.data.entity_id || e.id || e.entity_id };
                            }
                            // Validate that entity has required location data
                            if (!normalized.location || typeof normalized.location.lat !== 'number' || typeof normalized.location.lon !== 'number') {
                                console.warn(`[AutoRecon] Skipping entity ${normalized.entity_id || 'unknown'}: missing valid location data`);
                                return;
                            }
                            this.entities[normalized.entity_id] = normalized;
                        });
                        
                        // Update count display
                        const countEl = document.getElementById('recon-entity-count');
                        if (countEl) countEl.textContent = data.entity_count;
                        
                        // Render entities on map
                        this.renderEntities();
                        
                        // Load alerts
                        this.loadAlerts();
                        
                        addConsoleMessage(`Loaded ${data.entity_count} reconnaissance entities`, 'response');
                        showNotification('Recon Data Loaded', `Tracking ${data.entity_count} entities`, 'info');
                    }
                } catch (error) {
                    console.error('Error loading recon entities:', error);
                    addConsoleMessage('Error loading recon entities: ' + error.message, 'alert');
                }
            },
            
            loadAlerts: async function() {
                try {
                    const response = await fetch('/api/recon/alerts');
                    const data = await response.json();
                    
                    if (data.status === 'ok') {
                        this.alerts = data.alerts;
                        
                        // Update alert count display
                        const alertCountEl = document.getElementById('recon-alert-count');
                        if (alertCountEl) alertCountEl.textContent = data.alert_count;
                        
                        // Update alert list UI
                        this.updateAlertList();
                        
                        if (data.alert_count > 0) {
                            addConsoleMessage(`⚠️ ${data.alert_count} proximity alerts active!`, 'alert');
                        }
                    }
                } catch (error) {
                    console.error('Error loading alerts:', error);
                }
            },
            
            updateAlertList: function() {
                const listEl = document.getElementById('recon-alert-list');
                if (!listEl) return;
                
                if (this.alerts.length === 0) {
                    listEl.innerHTML = '<div class="no-alerts">No active alerts</div>';
                    return;
                }
                
                let html = '';
                this.alerts.forEach(alert => {
                    const threatClass = alert.threat_level.toLowerCase();
                    html += `
                        <div class="alert-item threat-${threatClass}" onclick="AutoReconVisualization.flyToEntity('${alert.entity_id}')">
                            <div class="alert-header">
                                <span class="alert-name">${alert.name}</span>
                                <span class="alert-threat">${alert.threat_level}</span>
                            </div>
                            <div class="alert-details">
                                <span>${alert.disposition}</span>
                                <span>${alert.distance_nm.toFixed(1)} NM @ ${alert.bearing_deg.toFixed(0)}°</span>
                            </div>
                        </div>
                    `;
                });
                listEl.innerHTML = html;
            },
            
            renderEntities: function() {
                if (!this.viewer || !this.visible) return;
                
                // Clear existing
                this.clearAllEntities();
                
                // Build quadtree for spatial queries
                if (typeof HierarchicalRenderManager !== 'undefined') {
                    this.quadtree = HierarchicalRenderManager.createQuadtree(Object.values(this.entities));
                }
                
                // Add reference point marker (always to viewer, not clustered)
                this.addReferencePointMarker();
                
                // Add proximity rings (show/hide based on altitude)
                if (this.showProximityRings) {
                    const shouldShowRings = typeof HierarchicalRenderManager !== 'undefined' 
                        ? HierarchicalRenderManager.shouldShowDetail('rings')
                        : true;
                    if (shouldShowRings) {
                        this.addProximityRings();
                    }
                }
                
                // Render each entity (to clustered data source if available)
                Object.values(this.entities).forEach(entity => {
                    this.addEntityMarker(entity);
                });

                // After rendering entities, update the Recon list UI if available
                try {
                    if (window.updateReconList) window.updateReconList();
                } catch (e) {
                    console.debug('updateReconList failed:', e);
                }
            },
            
            addReferencePointMarker: function() {
                if (!this.viewer) return;
                
                try {
                    const refEntity = this.viewer.entities.add({
                        id: 'recon_reference_point',
                        name: 'Reference Point (Own Position)',
                        position: Cesium.Cartesian3.fromDegrees(
                            this.referencePoint.lon,
                            this.referencePoint.lat,
                            0
                        ),
                        billboard: {
                            image: this.createOwnShipIcon(),
                            scale: 0.8,
                            verticalOrigin: Cesium.VerticalOrigin.CENTER,
                            horizontalOrigin: Cesium.HorizontalOrigin.CENTER
                        },
                        label: this.showLabels ? {
                            text: 'OWN POSITION',
                            font: 'bold 12px sans-serif',
                            fillColor: Cesium.Color.CYAN,
                            outlineColor: Cesium.Color.BLACK,
                            outlineWidth: 2,
                            style: Cesium.LabelStyle.FILL_AND_OUTLINE,
                            verticalOrigin: Cesium.VerticalOrigin.TOP,
                            pixelOffset: new Cesium.Cartesian2(0, 20)
                        } : undefined
                    });
                    
                    this.entityMarkers['reference'] = refEntity;
                } catch (error) {
                    console.error('Error adding reference point:', error);
                }
            },
            
            addProximityRings: function() {
                if (!this.viewer) return;
                
                const ringConfigs = [
                    { radius: 1.0, color: Cesium.Color.RED.withAlpha(0.3), name: 'CRITICAL (1 NM)' },
                    { radius: 3.0, color: Cesium.Color.ORANGE.withAlpha(0.2), name: 'WARNING (3 NM)' },
                    { radius: 5.0, color: Cesium.Color.YELLOW.withAlpha(0.15), name: 'ALERT (5 NM)' },
                    { radius: 10.0, color: Cesium.Color.LIME.withAlpha(0.1), name: 'AWARENESS (10 NM)' }
                ];
                
                ringConfigs.forEach((config, idx) => {
                    try {
                        const ring = this.viewer.entities.add({
                            id: `recon_proximity_ring_${idx}`,
                            name: config.name,
                            position: Cesium.Cartesian3.fromDegrees(
                                this.referencePoint.lon,
                                this.referencePoint.lat
                            ),
                            ellipse: {
                                semiMajorAxis: config.radius * 1852, // Convert NM to meters
                                semiMinorAxis: config.radius * 1852,
                                material: config.color,
                                outline: true,
                                outlineColor: config.color.withAlpha(0.8),
                                outlineWidth: 2,
                                height: 0,
                                heightReference: Cesium.HeightReference.CLAMP_TO_GROUND
                            }
                        });
                        
                        this.proximityCircles[idx] = ring;
                    } catch (error) {
                        console.error(`Error adding proximity ring ${idx}:`, error);
                    }
                });
            },
            
            addEntityMarker: function(entity) {
                if (!this.viewer) return;
                
                // Validate entity has required location data
                if (!entity || !entity.location || 
                    typeof entity.location.lat !== 'number' || 
                    typeof entity.location.lon !== 'number') {
                    console.warn('[AutoRecon] Skipping marker for entity without valid location:', entity?.entity_id);
                    return;
                }
                
                const entityId = entity.entity_id;
                const lat = entity.location.lat;
                const lon = entity.location.lon;
                const altitude = entity.location.altitude_m || 0;
                const disposition = entity.disposition || 'UNKNOWN';
                const threatLevel = entity.threat_level || 'NONE';
                const isAircraft = entity.ontology && entity.ontology.includes('aircraft');
                
                // Get color based on disposition
                const color = this.DISPOSITION_COLORS[disposition] || Cesium.Color.GRAY;
                
                // Use clustered data source if available
                const entityCollection = this.dataSource ? this.dataSource.entities : this.viewer.entities;
                
                // Determine if labels should be shown based on altitude
                const showLabelsNow = this.showLabels && 
                    (typeof HierarchicalRenderManager === 'undefined' || HierarchicalRenderManager.shouldShowDetail('labels'));
                
                try {
                    // Check if entity already exists in collection
                    const duplicate = entityCollection.getById(`recon_entity_${entityId}`);
                    if (duplicate) {
                        entityCollection.remove(duplicate);
                    }

                    const marker = entityCollection.add({
                        id: `recon_entity_${entityId}`,
                        name: `${entity.name} (${entityId})`,
                        position: Cesium.Cartesian3.fromDegrees(lon, lat, altitude),
                        billboard: {
                            image: this.createEntityIcon(color, disposition, isAircraft),
                            scale: 0.6,
                            verticalOrigin: Cesium.VerticalOrigin.CENTER,
                            horizontalOrigin: Cesium.HorizontalOrigin.CENTER,
                            rotation: entity.velocity ? Cesium.Math.toRadians(-entity.velocity.heading_deg) : 0
                        },
                        label: {
                            text: `${entity.name}\n${disposition}`,
                            font: '10px sans-serif',
                            fillColor: color,
                            outlineColor: Cesium.Color.BLACK,
                            outlineWidth: 2,
                            style: Cesium.LabelStyle.FILL_AND_OUTLINE,
                            verticalOrigin: Cesium.VerticalOrigin.TOP,
                            pixelOffset: new Cesium.Cartesian2(0, 18),
                            show: showLabelsNow
                        },
                        description: this.createEntityDescription(entity),
                        properties: {
                            type: 'recon_entity',
                            entityId: entityId,
                            entityData: entity
                        }
                    });
                    
                    this.entityMarkers[entityId] = marker;
                    
                    // Add altitude line for aircraft (only if zoomed in)
                    const showAltLines = typeof HierarchicalRenderManager === 'undefined' || 
                        HierarchicalRenderManager.shouldShowDetail('altitudeLines');
                    
                    if (isAircraft && altitude > 100 && showAltLines) {
                        const altLine = this.viewer.entities.add({
                            id: `recon_alt_line_${entityId}`,
                            polyline: {
                                positions: Cesium.Cartesian3.fromDegreesArrayHeights([
                                    lon, lat, 0,
                                    lon, lat, altitude
                                ]),
                                width: 1,
                                material: new Cesium.PolylineDashMaterialProperty({
                                    color: color.withAlpha(0.5)
                                })
                            }
                        });
                        this.entityMarkers[`${entityId}_alt`] = altLine;
                    }
                    
                    // Add threat indicator for hostile/suspicious
                    if (threatLevel === 'CRITICAL' || threatLevel === 'HIGH') {
                        this.addThreatIndicator(entity);
                    }
                    
                } catch (error) {
                    console.error(`Error adding entity ${entityId}:`, error);
                }
            },
            
            addThreatIndicator: function(entity) {
                if (!this.viewer) return;
                
                const entityId = entity.entity_id;
                const lat = entity.location.lat;
                const lon = entity.location.lon;
                const threatColor = this.THREAT_COLORS[entity.threat_level];
                
                try {
                    // Pulsing circle around threat
                    const threatCircle = this.viewer.entities.add({
                        id: `recon_threat_${entityId}`,
                        position: Cesium.Cartesian3.fromDegrees(lon, lat),
                        ellipse: {
                            semiMajorAxis: 500,
                            semiMinorAxis: 500,
                            material: threatColor.withAlpha(0.3),
                            outline: true,
                            outlineColor: threatColor,
                            outlineWidth: 2,
                            height: 0
                        }
                    });
                    
                    this.entityMarkers[`${entityId}_threat`] = threatCircle;
                } catch (error) {
                    console.error(`Error adding threat indicator for ${entityId}:`, error);
                }
            },
            
            createOwnShipIcon: function() {
                const canvas = document.createElement('canvas');
                canvas.width = 40;
                canvas.height = 40;
                const ctx = canvas.getContext('2d');
                
                ctx.clearRect(0, 0, 40, 40);
                ctx.save();
                ctx.translate(20, 20);
                
                // Draw diamond shape for own position
                ctx.beginPath();
                ctx.moveTo(0, -15);
                ctx.lineTo(12, 0);
                ctx.lineTo(0, 15);
                ctx.lineTo(-12, 0);
                ctx.closePath();
                
                ctx.fillStyle = '#00FFFF';
                ctx.fill();
                ctx.strokeStyle = '#FFFFFF';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // Center dot
                ctx.beginPath();
                ctx.arc(0, 0, 3, 0, Math.PI * 2);
                ctx.fillStyle = '#FFFFFF';
                ctx.fill();
                
                ctx.restore();
                return canvas.toDataURL();
            },
            
            createEntityIcon: function(color, disposition, isAircraft) {
                const canvas = document.createElement('canvas');
                canvas.width = 32;
                canvas.height = 32;
                const ctx = canvas.getContext('2d');
                
                ctx.clearRect(0, 0, 32, 32);
                ctx.save();
                ctx.translate(16, 16);
                
                if (isAircraft) {
                    // Aircraft symbol (triangle)
                    ctx.beginPath();
                    ctx.moveTo(0, -12);
                    ctx.lineTo(10, 10);
                    ctx.lineTo(0, 6);
                    ctx.lineTo(-10, 10);
                    ctx.closePath();
                } else {
                    // Surface vessel/ground symbol (semicircle with line)
                    ctx.beginPath();
                    ctx.arc(0, 2, 10, Math.PI, 0);
                    ctx.lineTo(10, 10);
                    ctx.lineTo(-10, 10);
                    ctx.closePath();
                }
                
                ctx.fillStyle = color.toCssColorString();
                ctx.fill();
                ctx.strokeStyle = '#FFFFFF';
                ctx.lineWidth = 1.5;
                ctx.stroke();
                
                // Add disposition indicator
                if (disposition === 'HOSTILE') {
                    ctx.beginPath();
                    ctx.moveTo(-8, -8);
                    ctx.lineTo(8, 8);
                    ctx.moveTo(8, -8);
                    ctx.lineTo(-8, 8);
                    ctx.strokeStyle = '#FF0000';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                } else if (disposition === 'FRIEND' || disposition === 'ASSUMED_FRIEND') {
                    ctx.beginPath();
                    ctx.arc(0, 0, 4, 0, Math.PI * 2);
                    ctx.fillStyle = '#00FF00';
                    ctx.fill();
                }
                
                ctx.restore();
                return canvas.toDataURL();
            },
            
            createEntityDescription: function(entity) {
                const threatClass = entity.threat_level.toLowerCase();
                const dispClass = entity.disposition.toLowerCase();
                
                return `
                    <div style="padding: 10px; font-family: sans-serif;">
                        <h3 style="margin: 0 0 10px 0; color: #00aaff;">🎯 ${entity.name}</h3>
                        <table style="width: 100%; border-collapse: collapse;">
                            <tr><td style="padding: 3px; color: #888;">Entity ID:</td><td style="padding: 3px;">${entity.entity_id}</td></tr>
                            <tr><td style="padding: 3px; color: #888;">Disposition:</td><td style="padding: 3px; color: ${this.getDispositionCssColor(entity.disposition)};">${entity.disposition}</td></tr>
                            <tr><td style="padding: 3px; color: #888;">Threat Level:</td><td style="padding: 3px; color: ${this.getThreatCssColor(entity.threat_level)};">${entity.threat_level}</td></tr>
                            <tr><td style="padding: 3px; color: #888;">Position:</td><td style="padding: 3px;">${(Number(entity.location?.lat ?? 0)).toFixed(5)}°, ${(Number(entity.location?.lon ?? 0)).toFixed(5)}°</td></tr>
                            <tr><td style="padding: 3px; color: #888;">Distance:</td><td style="padding: 3px;">${(Number(entity.distance_nm ?? 0)).toFixed(2)} NM</td></tr>
                            <tr><td style="padding: 3px; color: #888;">Bearing:</td><td style="padding: 3px;">${(Number(entity.bearing_deg ?? 0)).toFixed(1)}°</td></tr>
                            <tr><td style="padding: 3px; color: #888;">Speed:</td><td style="padding: 3px;">${entity.velocity.speed_kts.toFixed(1)} kts</td></tr>
                            <tr><td style="padding: 3px; color: #888;">Heading:</td><td style="padding: 3px;">${entity.velocity.heading_deg.toFixed(1)}°</td></tr>
                            <tr><td style="padding: 3px; color: #888;">Ontology:</td><td style="padding: 3px;">${entity.ontology}</td></tr>
                            <tr><td style="padding: 3px; color: #888;">RF Emissions:</td><td style="padding: 3px;">${entity.rf_emissions ? '📡 Detected' : 'None'}</td></tr>
                            <tr><td style="padding: 3px; color: #888;">IFF Response:</td><td style="padding: 3px;">${entity.iff_response ? '✅ Valid' : '❌ None'}</td></tr>
                        </table>
                        <div style="margin-top: 10px;">
                            <button onclick="AutoReconVisualization.createTaskForEntity('${entity.entity_id}')" 
                                    style="padding: 5px 10px; background: #0066aa; color: white; border: none; border-radius: 3px; cursor: pointer;">
                                📋 Create Task
                            </button>
                            <button onclick="AutoReconVisualization.updateDisposition('${entity.entity_id}')" 
                                    style="padding: 5px 10px; background: #aa6600; color: white; border: none; border-radius: 3px; cursor: pointer; margin-left: 5px;">
                                🏷️ Change Disposition
                            </button>
                        </div>
                    </div>
                `;
            },
            
            getDispositionCssColor: function(disposition) {
                const colors = {
                    'UNKNOWN': '#FFFF00',
                    'PENDING': '#FFFF00',
                    'ASSUMED_FRIEND': '#4444FF',
                    'FRIEND': '#0000FF',
                    'NEUTRAL': '#00FF00',
                    'SUSPICIOUS': '#FFA500',
                    'HOSTILE': '#FF0000',
                    'JOKER': '#FF00FF',
                    'FAKER': '#800080'
                };
                return colors[disposition] || '#AAAAAA';
            },
            
            getThreatCssColor: function(threat) {
                const colors = {
                    'CRITICAL': '#FF0000',
                    'HIGH': '#FF4500',
                    'MEDIUM': '#FFA500',
                    'LOW': '#FFFF00',
                    'MINIMAL': '#00FF00',
                    'NONE': '#00FFFF'
                };
                return colors[threat] || '#AAAAAA';
            },
            
            clearAllEntities: function() {
                // Clear from clustered data source if available
                if (this.dataSource) {
                    this.dataSource.entities.removeAll();
                }
                
                // Remove entity markers from viewer
                Object.values(this.entityMarkers).forEach(entity => {
                    if (this.viewer && this.viewer.entities.contains(entity)) {
                        this.viewer.entities.remove(entity);
                    }
                });
                this.entityMarkers = {};
                
                // Remove proximity circles
                Object.values(this.proximityCircles).forEach(entity => {
                    if (this.viewer && this.viewer.entities.contains(entity)) {
                        this.viewer.entities.remove(entity);
                    }
                });
                this.proximityCircles = {};
                
                // Remove task lines
                Object.values(this.taskLines).forEach(entity => {
                    if (this.viewer && this.viewer.entities.contains(entity)) {
                        this.viewer.entities.remove(entity);
                    }
                });
                this.taskLines = {};
            },
            
            updateProximityRingsVisibility: function() {
                Object.values(this.proximityCircles).forEach(entity => {
                    entity.show = this.showProximityRings;
                });
            },
            
            updateLabelVisibility: function() {
                Object.values(this.entityMarkers).forEach(entity => {
                    if (entity.label) {
                        entity.label.show = this.showLabels;
                    }
                });
            },
            
            // Track last update timestamp for incremental updates
            lastUpdateTimestamp: null,
            
            // Performance metrics for frontend
            perfMetrics: {
                updateCount: 0,
                lastUpdateMs: 0,
                avgUpdateMs: 0,
                entityUpdates: 0
            },
            
            startAutoUpdate: function() {
                if (this.updateInterval) return;
                
                const self = this;
                
                // Initialize timestamp for incremental updates
                this.lastUpdateTimestamp = Date.now() / 1000;
                
                this.updateInterval = setInterval(async function() {
                    if (!self.visible) return;
                    
                    const updateStart = performance.now();
                    
                    try {
                        // Simulate movement
                        await fetch('/api/recon/simulate');
                        
                        // OPTIMIZATION: Use incremental updates - only fetch changed entities
                        const response = await fetch(`/api/recon/changes?since=${self.lastUpdateTimestamp}`);
                        const data = await response.json();
                        
                        if (data.status === 'ok') {
                            // Update timestamp for next incremental fetch
                            self.lastUpdateTimestamp = data.timestamp;
                            
                            // Only update changed entities (not the full list)
                            if (data.entity_count > 0) {
                                data.entities.forEach(e => {
                                    self.entities[e.entity_id] = e;
                                    self.updateEntityPosition(e);
                                });
                                self.perfMetrics.entityUpdates += data.entity_count;
                            }
                            
                            // Update performance metrics
                            const updateDuration = performance.now() - updateStart;
                            self.perfMetrics.updateCount++;
                            self.perfMetrics.lastUpdateMs = updateDuration;
                            self.perfMetrics.avgUpdateMs = 
                                (self.perfMetrics.avgUpdateMs * (self.perfMetrics.updateCount - 1) + updateDuration) 
                                / self.perfMetrics.updateCount;
                            
                            // Refresh alerts (these are cached on backend)
                            self.loadAlerts();
                        }
                    } catch (error) {
                        console.error('Error updating recon entities:', error);
                    }
                }, 2000); // Update every 2 seconds
                
                addConsoleMessage('Recon auto-update started (incremental mode)', 'command');
            },
            
            stopAutoUpdate: function() {
                if (this.updateInterval) {
                    clearInterval(this.updateInterval);
                    this.updateInterval = null;
                    addConsoleMessage('Recon auto-update stopped', 'command');
                }
            },
            
            updateEntityPosition: function(entity) {
                const marker = this.entityMarkers[entity.entity_id];
                if (!marker) return;
                
                marker.position = Cesium.Cartesian3.fromDegrees(
                    entity.location.lon,
                    entity.location.lat,
                    entity.location.altitude_m || 0
                );
                
                if (marker.billboard && entity.velocity) {
                    marker.billboard.rotation = Cesium.Math.toRadians(-entity.velocity.heading_deg);
                }
                
                // Update label
                if (marker.label) {
                    marker.label.text = `${entity.name}\n${entity.disposition}`;
                    marker.label.fillColor = this.DISPOSITION_COLORS[entity.disposition] || Cesium.Color.GRAY;
                }
            },
            
            setReferenceFromView: async function() {
                if (!this.viewer) return;
                
                try {
                    const camera = this.viewer.camera;
                    const cartographic = Cesium.Cartographic.fromCartesian(camera.position);
                    const lat = Cesium.Math.toDegrees(cartographic.latitude);
                    const lon = Cesium.Math.toDegrees(cartographic.longitude);
                    
                    // Update server reference point
                    const response = await fetch('/api/recon/reference', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ lat, lon })
                    });
                    
                    const data = await response.json();
                    if (data.status === 'ok') {
                        this.referencePoint = data.reference_point;
                        addConsoleMessage(`Reference point set to: ${lat.toFixed(4)}, ${lon.toFixed(4)}`, 'response');
                        
                        // Reload entities with new reference
                        this.loadEntities();
                    }
                } catch (error) {
                    console.error('Error setting reference point:', error);
                    addConsoleMessage('Error setting reference point: ' + error.message, 'alert');
                }
            },
            
            flyToEntity: function(entityId) {
                const entity = this.entities[entityId];
                if (!entity || !this.viewer) return;

                // Always clear any prior tracking or custom transforms before flying.
                // Without this, camera operations such as rotate/tilt can remain locked
                // after a programmatic flight (e.g. from an nmap scan).
                try {
                    this.viewer.camera.lookAtTransform(Cesium.Matrix4.IDENTITY);
                    this.viewer.trackedEntity = undefined;
                    const ctrlPre = this.viewer.scene.screenSpaceCameraController;
                    ctrlPre.enableRotate = ctrlPre.enableTilt = ctrlPre.enableZoom = ctrlPre.enableTranslate = ctrlPre.enableLook = true;
                } catch (e) {
                    console.warn('[Recon] Failed to reset camera before flyTo:', e);
                }
                
                // Derive a destination from the entity's current location.  If the marker
                // exists in our map, use its position; otherwise compute one from
                // the stored coordinates.  Using the camera API directly avoids
                // reliance on flyTo(marker) which can silently fail when the
                // underlying entity is clustered or otherwise unavailable.
                let destination;
                const marker = this.entityMarkers[entityId];
                if (marker && marker.position) {
                    destination = marker.position.getValue ? marker.position.getValue(new Date()) : marker.position;
                }
                if (!destination) {
                    destination = Cesium.Cartesian3.fromDegrees(
                        entity.location.lon,
                        entity.location.lat,
                        entity.location.altitude_m || 0
                    );
                }
                const self = this;
                // Use the camera API directly.  Fly to the entity with a gentle
                // tilt so the user can see context.  When finished, ensure the
                // camera transform is reset and controls are re-enabled.
                this.viewer.camera.flyTo({
                    destination: destination,
                    orientation: {
                        heading: self.viewer.camera.heading,
                        pitch: Cesium.Math.toRadians(-45),
                        roll: 0
                    },
                    duration: 1.5,
                    complete: function() {
                        // Reset camera transform to re-enable user control
                        try {
                            self.viewer.camera.lookAtTransform(Cesium.Matrix4.IDENTITY);
                            self.viewer.trackedEntity = undefined;
                            const controller = self.viewer.scene.screenSpaceCameraController;
                            controller.enableRotate = controller.enableTilt = controller.enableZoom = controller.enableTranslate = controller.enableLook = true;
                        } catch (e) {
                            console.warn('[Recon] Failed to reset camera after flyTo:', e);
                        }
                    }
                });
            },
            
            createTaskForEntity: async function(entityId) {
                try {
                    const response = await fetch('/api/recon/task', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            entity_id: entityId,
                            task_type: 'INVESTIGATE',
                            priority: 5
                        })
                    });
                    
                    const data = await response.json();
                    if (data.status === 'ok') {
                        addConsoleMessage(`Task ${data.task.task_id} created for ${data.task.entity_name}`, 'response');
                        showNotification('Task Created', `Investigation task assigned: ${data.task.task_id}`, 'info');
                        
                        // Show task line on map
                        this.addTaskLine(data.task);
                    } else {
                        addConsoleMessage('Failed to create task: ' + data.message, 'alert');
                    }
                } catch (error) {
                    console.error('Error creating task:', error);
                    addConsoleMessage('Error creating task: ' + error.message, 'alert');
                }
            },
            
            addTaskLine: function(task) {
                if (!this.viewer) return;
                
                const entity = this.entities[task.entity_id];
                if (!entity) return;
                
                try {
                    const taskLine = this.viewer.entities.add({
                        id: `recon_task_${task.task_id}`,
                        name: `Task: ${task.task_id}`,
                        polyline: {
                            positions: Cesium.Cartesian3.fromDegreesArray([
                                this.referencePoint.lon, this.referencePoint.lat,
                                entity.location.lon, entity.location.lat
                            ]),
                            width: 2,
                            material: new Cesium.PolylineDashMaterialProperty({
                                color: Cesium.Color.YELLOW.withAlpha(0.7),
                                dashLength: 16.0
                            }),
                            clampToGround: true
                        }
                    });
                    
                    this.taskLines[task.task_id] = taskLine;
                } catch (error) {
                    console.error('Error adding task line:', error);
                }
            },
            
            updateDisposition: async function(entityId) {
                const entity = this.entities[entityId];
                if (!entity) return;
                
                const dispositions = ['UNKNOWN', 'PENDING', 'ASSUMED_FRIEND', 'FRIEND', 'NEUTRAL', 'SUSPICIOUS', 'HOSTILE'];
                const currentIdx = dispositions.indexOf(entity.disposition);
                const newDisposition = prompt(
                    `Update disposition for ${entity.name}\nCurrent: ${entity.disposition}\n\nOptions: ${dispositions.join(', ')}`,
                    entity.disposition
                );
                
                if (!newDisposition || newDisposition.toUpperCase() === entity.disposition) return;
                
                try {
                    // Include session token for provenance tracking
                    const headers = { 'Content-Type': 'application/json' };
                    if (window.OperatorSession && window.OperatorSession.sessionToken) {
                        headers['X-Session-Token'] = window.OperatorSession.sessionToken;
                    }
                    
                    const response = await fetch(`/api/recon/entity/${entityId}/disposition`, {
                        method: 'POST',
                        headers: headers,
                        body: JSON.stringify({ disposition: newDisposition.toUpperCase() })
                    });
                    
                    const data = await response.json();
                    if (data.status === 'ok') {
                        this.entities[entityId] = data.entity;
                        addConsoleMessage(`${entity.name} disposition changed to ${newDisposition.toUpperCase()}`, 'response');
                        
                        // Re-render to update colors
                        this.renderEntities();
                    } else {
                        addConsoleMessage('Failed to update disposition: ' + data.message, 'alert');
                    }
                } catch (error) {
                    console.error('Error updating disposition:', error);
                    addConsoleMessage('Error updating disposition: ' + error.message, 'alert');
                }
            },
            
            // ========================================================================
            // PERFORMANCE MONITORING (Optimization: visibility into system performance)
            // ========================================================================
            
            getPerformanceStats: function() {
                return {
                    frontend: {
                        updateCount: this.perfMetrics.updateCount,
                        lastUpdateMs: this.perfMetrics.lastUpdateMs.toFixed(2),
                        avgUpdateMs: this.perfMetrics.avgUpdateMs.toFixed(2),
                        entityUpdatesTotal: this.perfMetrics.entityUpdates,
                        entitiesTracked: Object.keys(this.entities).length
                    },
                    incremental: {
                        enabled: true,
                        lastTimestamp: this.lastUpdateTimestamp
                    }
                };
            },
            
            showPerformanceMetrics: async function() {
                try {
                    // Get backend metrics
                    const response = await fetch('/api/metrics');
                    const backendMetrics = await response.json();
                    
                    // Get frontend metrics
                    const frontendStats = this.getPerformanceStats();
                    
                    // Format and display
                    const msg = `
=== RECON SYSTEM PERFORMANCE ===
FRONTEND:
  Updates: ${frontendStats.frontend.updateCount}
  Last update: ${frontendStats.frontend.lastUpdateMs}ms
  Avg update: ${frontendStats.frontend.avgUpdateMs}ms
  Entities tracked: ${frontendStats.frontend.entitiesTracked}

BACKEND:
  Spatial Index: ${backendMetrics.spatial_index?.point_count || 'N/A'} points
  Build time: ${backendMetrics.spatial_index?.last_build_time_ms?.toFixed(2) || 'N/A'}ms
  Alerts cache: ${backendMetrics.recon_performance?.alerts_cache_valid ? 'VALID' : 'DIRTY'}
  
API TIMING (avg ms):
  get_all_entities: ${backendMetrics.operations?.get_all_entities?.avg_ms?.toFixed(3) || 'N/A'}
  get_nearest: ${backendMetrics.operations?.get_nearest_entities?.avg_ms?.toFixed(3) || 'N/A'}
  get_batch: ${backendMetrics.operations?.get_entities_batch?.avg_ms?.toFixed(3) || 'N/A'}
================================`;
                    
                    console.log(msg);
                    addConsoleMessage('Performance metrics retrieved (see console)', 'response');
                    
                    return { frontend: frontendStats, backend: backendMetrics };
                } catch (error) {
                    console.error('Error fetching metrics:', error);
                    return null;
                }
            },
            
            // ========================================================================
            // BATCH API HELPERS (Optimization: reduce network round-trips)
            // ========================================================================
            
            loadEntitiesBatch: async function(entityIds) {
                try {
                    const response = await fetch('/api/recon/entities/batch', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ entity_ids: entityIds })
                    });
                    
                    const data = await response.json();
                    
                    if (data.status === 'ok') {
                        data.entities.forEach(e => {
                            this.entities[e.entity_id] = e;
                        });
                        return data.entities;
                    }
                    return [];
                } catch (error) {
                    console.error('Error loading batch entities:', error);
                    return [];
                }
            },
            
            loadNearestEntities: async function(k = 10) {
                try {
                    const response = await fetch(`/api/recon/nearest?k=${k}`);
                    const data = await response.json();
                    
                    if (data.status === 'ok') {
                        // Clear and reload only nearest entities for focus view
                        this.clearAllEntities();
                        
                        data.entities.forEach(e => {
                            this.entities[e.entity_id] = e;
                        });
                        
                        this.renderEntities();
                        addConsoleMessage(`Showing ${data.entity_count} nearest entities`, 'response');
                        return data.entities;
                    }
                    return [];
                } catch (error) {
                    console.error('Error loading nearest entities:', error);
                    return [];
                }
            },

            // ========================================================================
            // ENTITY SYNC INTEGRATION (Real-time multi-operator synchronization)
            // ========================================================================
            
            /**
             * Apply an EntitySync event to the Recon visualization.
             * Handles CREATE, UPDATE, DELETE, and PREEXISTING events for RECON_ENTITY/NMAP_TARGET types.
             */
            applyEntitySyncEvent: function(evt) {
                if (!evt) return;
                
                const entityId = evt.entity_id;
                const entityType = evt.entity_type || '';
                const entityData = evt.entity_data || {};
                const eventType = evt.eventType || evt.event_type || 'UPDATE';
                
                // Filter: only process RECON_ENTITY and NMAP_TARGET types
                if (entityType !== 'RECON_ENTITY' && entityType !== 'NMAP_TARGET' && 
                    !entityId?.startsWith('AIS-') && !entityId?.startsWith('ENTITY-')) {
                    return;
                }
                
                console.log(`[AutoRecon] EntitySync ${eventType}: ${entityId} (${entityType})`);
                
                switch (eventType.toUpperCase()) {
                    case 'CREATE':
                    case 'PREEXISTING':
                        // Add or update entity
                        this.entities[entityId] = this._normalizeEntityData(entityData);
                        if (this.visible) {
                            this.removeEntityMarker(entityId); // Remove existing if any
                            this.addEntityMarker(this.entities[entityId]);
                        }
                        break;
                        
                    case 'UPDATE':
                        // Update existing entity
                        if (this.entities[entityId]) {
                            // Merge updates while preserving existing fields
                            this.entities[entityId] = {
                                ...this.entities[entityId],
                                ...this._normalizeEntityData(entityData),
                                entity_id: entityId // Ensure ID is preserved
                            };
                        } else {
                            // Entity doesn't exist locally, create it
                            this.entities[entityId] = this._normalizeEntityData(entityData);
                        }
                        
                        if (this.visible) {
                            // Update marker (remove and re-add for color/disposition changes)
                            this.removeEntityMarker(entityId);
                            this.addEntityMarker(this.entities[entityId]);
                        }
                        break;
                        
                    case 'DELETE':
                        // Remove entity
                        if (this.entities[entityId]) {
                            delete this.entities[entityId];
                            if (this.visible) {
                                this.removeEntityMarker(entityId);
                            }
                        }
                        break;
                        
                    default:
                        console.debug(`[AutoRecon] Unhandled event type: ${eventType}`);
                        return;
                }
                
                // Update the Recon list UI
                if (window.updateReconList) {
                    try { window.updateReconList(); } catch(e) { /* ignore */ }
                }
                
                // Update count display
                const countEl = document.getElementById('recon-entity-count');
                if (countEl) countEl.textContent = Object.keys(this.entities).length;
            },
            
            /**
             * Normalize entity data to ensure consistent structure
             */
            _normalizeEntityData: function(data) {
                const entity = { ...data };
                
                // Ensure entity_id
                entity.entity_id = entity.entity_id || data.id || `ENTITY-${Date.now()}`;
                
                // Normalize location
                entity.location = entity.location || {};
                entity.location.lat = Number(entity.location.lat ?? data.lat ?? 0);
                entity.location.lon = Number(entity.location.lon ?? data.lon ?? 0);
                entity.location.altitude_m = Number(entity.location.altitude_m ?? entity.location.alt ?? 0);
                
                // Ensure required fields
                entity.name = entity.name || entity.entity_id;
                entity.disposition = entity.disposition || 'UNKNOWN';
                entity.threat_level = entity.threat_level || 'NONE';
                entity.velocity = entity.velocity || { speed_kts: 0, heading_deg: 0 };
                entity.ontology = entity.ontology || 'unknown';
                entity.distance_nm = entity.distance_nm || 0;
                entity.bearing_deg = entity.bearing_deg || 0;
                entity.last_update = entity.last_update || Date.now() / 1000;
                
                return entity;
            },
            
            /**
             * Remove a specific entity marker from the visualization
             */
            removeEntityMarker: function(entityId) {
                const marker = this.entityMarkers[entityId];
                if (marker) {
                    // Try to remove from clustered data source first
                    if (this.dataSource && this.dataSource.entities.contains(marker)) {
                        this.dataSource.entities.remove(marker);
                    }
                    // Also try viewer entities
                    else if (this.viewer && this.viewer.entities.contains(marker)) {
                        this.viewer.entities.remove(marker);
                    }
                    delete this.entityMarkers[entityId];
                }
                
                // Also remove associated markers (altitude line, threat indicator)
                const altMarker = this.entityMarkers[`${entityId}_alt`];
                if (altMarker && this.viewer && this.viewer.entities.contains(altMarker)) {
                    this.viewer.entities.remove(altMarker);
                    delete this.entityMarkers[`${entityId}_alt`];
                }
                
                const threatMarker = this.entityMarkers[`${entityId}_threat`];
                if (threatMarker && this.viewer && this.viewer.entities.contains(threatMarker)) {
                    this.viewer.entities.remove(threatMarker);
                    delete this.entityMarkers[`${entityId}_threat`];
                }
            },
            
            /**
             * Subscribe to EntitySync events for real-time updates
             */
            subscribeToEntitySync: function() {
                if (typeof EntitySync === 'undefined') {
                    console.warn('[AutoRecon] EntitySync not available - real-time sync disabled');
                    return;
                }
                
                const self = this;
                
                // Handler for all entity events
                const applyEvent = function(data) {
                    self.applyEntitySyncEvent(data);
                };
                
                // Subscribe to all relevant event types
                EntitySync.on('preexisting', applyEvent);
                EntitySync.on('create', applyEvent);
                EntitySync.on('update', applyEvent);
                EntitySync.on('delete', applyEvent);
                
                console.log('[AutoRecon] Subscribed to EntitySync for real-time updates');
            }
        };
        
        // Make Auto-Recon visualization globally available
        window.AutoReconVisualization = AutoReconVisualization;
        
        // Wire up EntitySync subscription after EntitySync is available
        // This runs when the page loads and EntitySync connects
        (function() {
            // Try to subscribe immediately if EntitySync is available
            if (typeof EntitySync !== 'undefined') {
                setTimeout(function() {
                    if (window.AutoReconVisualization) {
                        window.AutoReconVisualization.subscribeToEntitySync();
                    }
                }, 100);
            }
            
            // Also subscribe when EntitySync connects (handles async loading)
            document.addEventListener('DOMContentLoaded', function() {
                if (typeof EntitySync !== 'undefined' && window.AutoReconVisualization) {
                    window.AutoReconVisualization.subscribeToEntitySync();
                }
            });
        })();

        // Global helper: update Recon UI list from current AutoReconVisualization.entities
        window.updateReconList = function() {
            try {
                const listEl = document.getElementById('reconList');
                if (!listEl) return;

                const entities = (window.AutoReconVisualization && window.AutoReconVisualization.entities) ? window.AutoReconVisualization.entities : {};
                const ids = Object.keys(entities || {});

                // If no entities, show placeholder
                if (ids.length === 0) {
                    listEl.innerHTML = '<li class="list-item no-entities" style="color:#888; font-size:12px;">No recon entities available</li>';
                } else {
                    listEl.innerHTML = '';
                    ids.forEach(id => {
                        const e = entities[id];
                        const li = document.createElement('li');
                        li.className = 'list-item';
                        li.innerHTML = `
                            <div class="list-item-header">
                                <span class="list-item-title">${e.name}</span>
                                <span class="status-dot" style="background-color:${e.disposition === 'HOSTILE' ? '#ff4d4d' : '#4a9eff'}"></span>
                            </div>
                            <div class="list-item-subtitle">${e.disposition} | ${e.threat_level} | ${e.location.lat.toFixed(3)}, ${e.location.lon.toFixed(3)}</div>
                            <div class="list-item-actions">
                                <button class="action-button" data-entity-id="${e.entity_id}" data-action="track">Track</button>
                                <button class="action-button" data-entity-id="${e.entity_id}" data-action="task">Task</button>
                                <button class="action-button" data-entity-id="${e.entity_id}" data-action="info">Info</button>
                            </div>
                        `;

                        // Attach handlers
                        li.querySelectorAll('.list-item-actions .action-button').forEach(btn => {
                            btn.addEventListener('click', function() {
                                const entId = this.getAttribute('data-entity-id');
                                const action = this.getAttribute('data-action');
                                if (action === 'track') {
                                    if (window.AutoReconVisualization && window.AutoReconVisualization.flyToEntity) {
                                        window.AutoReconVisualization.flyToEntity(entId);
                                    }
                                } else if (action === 'task') {
                                    if (window.AutoReconVisualization && window.AutoReconVisualization.createTaskForEntity) {
                                        window.AutoReconVisualization.createTaskForEntity(entId);
                                    }
                                } else if (action === 'info') {
                                    const ent = (window.AutoReconVisualization && window.AutoReconVisualization.entities) ? window.AutoReconVisualization.entities[entId] : null;
                                    if (ent) {
                                    const desc = window.AutoReconVisualization.createEntityDescription ? window.AutoReconVisualization.createEntityDescription(ent) : `<pre>${JSON.stringify(ent, null, 2)}</pre>`;
                                        // Create a simple modal for entity info.  Use a
                                        // unique close button selector scoped to the panel
                                        // itself so we do not depend on a global id that
                                        // could conflict with other modals.
                                        const infoPanel = document.createElement('div');
                                        infoPanel.style.position = 'fixed';
                                        infoPanel.style.left = '50%';
                                        infoPanel.style.top = '50%';
                                        infoPanel.style.transform = 'translate(-50%, -50%)';
                                        infoPanel.style.background = 'rgba(20,20,20,0.95)';
                                        infoPanel.style.padding = '12px';
                                        infoPanel.style.borderRadius = '6px';
                                        infoPanel.style.zIndex = 99999;
                                        infoPanel.innerHTML = `${desc}<div style="text-align:right;margin-top:8px;"><button class="info-close-btn">Close</button></div>`;
                                        document.body.appendChild(infoPanel);
                                        // Attach click handler to close button within this panel
                                        const closeBtn = infoPanel.querySelector('.info-close-btn');
                                        if (closeBtn) {
                                            closeBtn.addEventListener('click', () => {
                                                if (infoPanel && infoPanel.parentNode) {
                                                    infoPanel.parentNode.removeChild(infoPanel);
                                                }
                                            });
                                        }
                                    }
                                }
                            });
                        });

                        listEl.appendChild(li);
                    });
                }

                // Update panel counters if present
                const countEl = document.getElementById('recon-panel-count');
                const badgeEl = document.getElementById('recon-entity-count');
                if (countEl) countEl.textContent = ids.length;
                if (badgeEl) badgeEl.textContent = ids.length;

            } catch (err) {
                console.debug('updateReconList error:', err);
            }
        };

        // =====================================================================
        // SENSOR MANAGER - Manages Tx/Rx Sensors with Hypergraph Integration
        // =====================================================================
        const SensorManager = {
            sensors: {},        // { sensor_id: { sensor_id, label, type, tx_config, rx_config, position, ... } }
            assignments: {},    // { entity_id: [sensor_id, ...] }
            markers: {},        // Cesium entity markers for sensors
            groupOrder: [],     // Order of entity groups for UI
            
            /**
             * Load all sensors from the API
             */
            load: async function() {
                try {
                    const headers = { 'Content-Type': 'application/json' };
                    if (window.OperatorSession && window.OperatorSession.sessionToken) {
                        headers['X-Session-Token'] = window.OperatorSession.sessionToken;
                    }
                    
                    const resp = await fetch('/api/sensors', { headers });
                    if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
                    
                    const data = await resp.json();
                    this.sensors = {};
                    (data.sensors || []).forEach(s => {
                        this.sensors[s.sensor_id] = s;
                    });
                    
                    this._updateUI();
                    this._visualize();
                    addConsoleMessage(`Loaded ${Object.keys(this.sensors).length} sensors`, 'response');
                    
                } catch (err) {
                    console.error('[SensorManager] Load error:', err);
                    addConsoleMessage('Error loading sensors: ' + err.message, 'alert');
                }
            },
            
            /**
             * Create or update a sensor
             */
            upsert: async function(sensorData) {
                try {
                    const headers = { 'Content-Type': 'application/json' };
                    if (window.OperatorSession && window.OperatorSession.sessionToken) {
                        headers['X-Session-Token'] = window.OperatorSession.sessionToken;
                    }
                    
                    const resp = await fetch('/api/sensors', {
                        method: 'POST',
                        headers,
                        body: JSON.stringify(sensorData)
                    });
                    
                    if (!resp.ok) {
                        const errData = await resp.json();
                        throw new Error(errData.error || `HTTP ${resp.status}`);
                    }
                    
                    const data = await resp.json();
                    this.sensors[data.sensor.sensor_id] = data.sensor;
                    
                    this._updateUI();
                    this._visualize();
                    addConsoleMessage(`Sensor ${data.sensor.label} ${data.created ? 'created' : 'updated'}`, 'response');
                    
                    return data.sensor;
                    
                } catch (err) {
                    console.error('[SensorManager] Upsert error:', err);
                    addConsoleMessage('Error saving sensor: ' + err.message, 'alert');
                    throw err;
                }
            },
            
            /**
             * Delete a sensor
             */
            delete: async function(sensorId) {
                try {
                    const headers = { 'Content-Type': 'application/json' };
                    if (window.OperatorSession && window.OperatorSession.sessionToken) {
                        headers['X-Session-Token'] = window.OperatorSession.sessionToken;
                    }
                    
                    const resp = await fetch(`/api/sensors/${sensorId}`, {
                        method: 'DELETE',
                        headers
                    });
                    
                    if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
                    
                    delete this.sensors[sensorId];
                    
                    // Remove from assignments
                    Object.keys(this.assignments).forEach(entityId => {
                        this.assignments[entityId] = this.assignments[entityId].filter(sid => sid !== sensorId);
                    });
                    
                    this._updateUI();
                    this._removeMarker(sensorId);
                    addConsoleMessage(`Sensor ${sensorId} deleted`, 'response');
                    
                } catch (err) {
                    console.error('[SensorManager] Delete error:', err);
                    addConsoleMessage('Error deleting sensor: ' + err.message, 'alert');
                }
            },
            
            /**
             * Assign sensor to a recon entity
             */
            assign: async function(sensorId, entityId) {
                try {
                    const headers = { 'Content-Type': 'application/json' };
                    if (window.OperatorSession && window.OperatorSession.sessionToken) {
                        headers['X-Session-Token'] = window.OperatorSession.sessionToken;
                    }
                    
                    const resp = await fetch(`/api/recon/entity/${entityId}/assign_sensor`, {
                        method: 'POST',
                        headers,
                        body: JSON.stringify({ sensor_id: sensorId })
                    });
                    
                    if (!resp.ok) {
                        const errData = await resp.json();
                        const errText = (errData && (errData.error || errData.message)) || `HTTP ${resp.status}`;
                        throw new Error(errText);
                    }
                    
                    // Update local assignments
                    if (!this.assignments[entityId]) {
                        this.assignments[entityId] = [];
                    }
                    if (!this.assignments[entityId].includes(sensorId)) {
                        this.assignments[entityId].push(sensorId);
                    }
                    
                    this._updateUI();
                    this._visualize();
                    addConsoleMessage(`Sensor ${sensorId} assigned to entity ${entityId}`, 'response');
                    
                } catch (err) {
                    console.error('[SensorManager] Assign error:', err);
                    addConsoleMessage('Error assigning sensor: ' + err.message, 'alert');
                }
            },
            
            /**
             * Unassign sensor from entity
             */
            unassign: async function(sensorId, entityId) {
                try {
                    const headers = { 'Content-Type': 'application/json' };
                    if (window.OperatorSession && window.OperatorSession.sessionToken) {
                        headers['X-Session-Token'] = window.OperatorSession.sessionToken;
                    }
                    
                    const resp = await fetch(`/api/sensors/${sensorId}/unassign/${entityId}`, {
                        method: 'DELETE',
                        headers
                    });
                    
                    if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
                    
                    // Update local assignments
                    if (this.assignments[entityId]) {
                        this.assignments[entityId] = this.assignments[entityId].filter(sid => sid !== sensorId);
                    }
                    
                    this._updateUI();
                    this._visualize();
                    addConsoleMessage(`Sensor ${sensorId} unassigned from entity ${entityId}`, 'response');
                    
                } catch (err) {
                    console.error('[SensorManager] Unassign error:', err);
                    addConsoleMessage('Error unassigning sensor: ' + err.message, 'alert');
                }
            },
            
            /**
             * Emit sensor activity (detection, transmission, etc.)
             */
            emitActivity: async function(sensorId, activityType, payload) {
                try {
                    const headers = { 'Content-Type': 'application/json' };
                    if (window.OperatorSession && window.OperatorSession.sessionToken) {
                        headers['X-Session-Token'] = window.OperatorSession.sessionToken;
                    }
                    
                    const resp = await fetch(`/api/sensors/${sensorId}/activity`, {
                        method: 'POST',
                        headers,
                        body: JSON.stringify({
                            activity_type: activityType,
                            payload: payload
                        })
                    });
                    
                    if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
                    
                    const data = await resp.json();
                    addConsoleMessage(`Sensor activity: ${activityType} from ${sensorId}`, 'response');
                    return data;
                    
                } catch (err) {
                    console.error('[SensorManager] Activity error:', err);
                    addConsoleMessage('Error emitting sensor activity: ' + err.message, 'alert');
                }
            },
            
            /**
             * Move a sensor group up or down in the list
             */
            _moveGroup: function(groupId, action) {
                const idx = this.groupOrder.indexOf(groupId);
                if (idx === -1) return;
                
                if (action === 'up' && idx > 0) {
                     // Swap with previous
                     [this.groupOrder[idx-1], this.groupOrder[idx]] = [this.groupOrder[idx], this.groupOrder[idx-1]];
                } else if (action === 'down' && idx < this.groupOrder.length - 1) {
                     // Swap with next
                     [this.groupOrder[idx+1], this.groupOrder[idx]] = [this.groupOrder[idx], this.groupOrder[idx+1]];
                }
                this._updateUI();
            },

            /**
             * Generate HTML for a sensor list item
             */
            _createSensorListItem: function(sensor) {
                const li = document.createElement('li');
                li.className = 'list-item signal-card';
                li.setAttribute('data-sensor-id', sensor.sensor_id);
                
                // Determine status color and text
                const statusColor = sensor.status === 'ACTIVE' ? '#55ff55' : 
                                   sensor.status === 'OFFLINE' ? '#888' : '#4a9eff';
                const statusText = sensor.status || 'UNKNOWN';

                // Prepare display values
                const txFreq = sensor.tx_config?.frequency_mhz ? `${sensor.tx_config.frequency_mhz} MHz` : '—';
                const rxFreq = sensor.rx_config?.frequency_mhz ? `${sensor.rx_config.frequency_mhz} MHz` : '—';
                const txPower = sensor.tx_config?.power_dbm ? `${sensor.tx_config.power_dbm} dBm` : '—';
                const bandwidth = sensor.rx_config?.bandwidth_mhz ? `${sensor.rx_config.bandwidth_mhz} MHz` : '—';
                const gain = sensor.rx_config?.gain_db ? `${sensor.rx_config.gain_db} dB` : '—';
                
                li.innerHTML = `
                    <div class="list-item-header">
                        <span class="list-item-title">${sensor.label || sensor.sensor_id}</span>
                        <span style="background-color: ${statusColor}; color: #000; padding: 2px 6px; border-radius: 3px; font-size: 11px; font-weight: bold;">${statusText}</span>
                    </div>
                    
                    <div class="feature-value" style="display: flex; justify-content: space-between; margin-bottom: 2px; font-size: 11px;">
                        <span class="feature-name" style="color: #aaa;">Type:</span>
                        <span>${sensor.type || 'SDR'}</span>
                    </div>

                    ${sensor.tx_config ? `
                    <div class="feature-value" style="display: flex; justify-content: space-between; margin-bottom: 2px; font-size: 11px;">
                        <span class="feature-name" style="color: #aaa;">Tx Freq/Pwr:</span>
                        <span>${txFreq} / ${txPower}</span>
                    </div>` : ''}

                    ${sensor.rx_config ? `
                    <div class="feature-value" style="display: flex; justify-content: space-between; margin-bottom: 2px; font-size: 11px;">
                        <span class="feature-name" style="color: #aaa;">Rx Freq/BW:</span>
                        <span>${rxFreq} / ${bandwidth}</span>
                    </div>` : ''}

                    <div class="feature-value" style="display: flex; justify-content: space-between; margin-bottom: 5px; font-size: 11px;">
                        <span class="feature-name" style="color: #aaa;">Gain:</span>
                        <span>${gain}</span>
                    </div>

                    <div class="confidence-bar">
                         <div class="confidence-level" style="width: 100%; background-color: ${statusColor}; opacity: 0.5;"></div>
                    </div>

                    <div class="list-item-actions">
                        <button class="action-button sensor-track-btn" data-sensor-id="${sensor.sensor_id}">Track</button>
                        <button class="action-button sensor-assign-btn" data-sensor-id="${sensor.sensor_id}">Assign</button>
                        <button class="action-button sensor-delete-btn" data-sensor-id="${sensor.sensor_id}" style="background:#a33;">Delete</button>
                    </div>
                `;
                return li;
            },

            /**
             * Update the sensor list UI with grouping
             */
            _updateUI: function() {
                const listEl = document.getElementById('sensorList');
                if (!listEl) return;
                
                const ids = Object.keys(this.sensors);
                
                // Update count
                const countEl = document.getElementById('sensors-panel-count');
                if (countEl) countEl.textContent = ids.length;
                
                if (ids.length === 0) {
                    listEl.innerHTML = '<li class="list-item no-entities" style="color:#888; font-size:12px;">No sensors loaded</li>';
                    return;
                }
                
                // Helper: Invert assignments { entity_id: [sensor_id, ...] }
                const sensorToEntity = {};
                Object.keys(this.assignments).forEach(entityId => {
                    this.assignments[entityId].forEach(sid => {
                         sensorToEntity[sid] = entityId; 
                    });
                });
                
                // Group sensors
                const groups = {}; // entityId -> [sensorObj]
                const unassigned = [];
                
                ids.forEach(id => {
                    const sensor = this.sensors[id];
                    const entId = sensorToEntity[id];
                    if (entId) {
                        if (!groups[entId]) groups[entId] = [];
                        groups[entId].push(sensor);
                    } else {
                        unassigned.push(sensor);
                    }
                });
                
                listEl.innerHTML = '';
                
                // Determine display order
                // Ensure all present groups are in groupOrder
                const presentGroups = Object.keys(groups);
                presentGroups.forEach(gId => {
                    if (!this.groupOrder.includes(gId)) {
                         this.groupOrder.push(gId);
                    }
                });
                
                // Filter groupOrder to only show present groups
                const groupsToRender = this.groupOrder.filter(gId => presentGroups.includes(gId));
                
                // Render Assigned Groups
                groupsToRender.forEach((entId, index) => {
                     // Get Entity Name if possible
                     let entName = entId;
                     if (window.AutoReconVisualization && window.AutoReconVisualization.entities && window.AutoReconVisualization.entities[entId]) {
                         entName = `${window.AutoReconVisualization.entities[entId].name} (${entId})`;
                     }

                     const headerLi = document.createElement('li');
                     headerLi.className = 'sensor-group-header';
                     headerLi.style.cssText = 'background: linear-gradient(90deg, #2a2a40, #1a1a20); padding: 8px 10px; margin-top: 15px; margin-bottom: 8px; border-radius: 4px; font-weight: bold; color: #add8e6; display: flex; justify-content: space-between; align-items: center; border-left: 3px solid #4a9eff; box-shadow: 0 2px 4px rgba(0,0,0,0.2);';
                     
                     headerLi.innerHTML = `
                        <span><span style="color:#888; font-size:11px; margin-right:5px;">TASK FORCE:</span>${entName}</span>
                        <div class="group-controls" style="display:flex;">
                            <button class="group-move-btn" data-action="up" data-group="${entId}" ${index === 0 ? 'disabled' : ''} style="cursor: pointer; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); color: #fff; width: 24px; height: 24px; display:flex; align-items:center; justify-content:center; border-radius:3px; margin-left:4px; opacity:${index === 0 ? 0.3 : 1};">▲</button>
                            <button class="group-move-btn" data-action="down" data-group="${entId}" ${index === groupsToRender.length - 1 ? 'disabled' : ''} style="cursor: pointer; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); color: #fff; width: 24px; height: 24px; display:flex; align-items:center; justify-content:center; border-radius:3px; margin-left:4px; opacity:${index === groupsToRender.length - 1 ? 0.3 : 1};">▼</button>
                        </div>
                     `;
                     listEl.appendChild(headerLi);
                     
                     // Render Sensors in group
                     groups[entId].forEach(sensor => {
                         listEl.appendChild(this._createSensorListItem(sensor));
                     });
                });
                
                // Render Unassigned
                if (unassigned.length > 0) {
                     if (groupsToRender.length > 0) {
                         const headerLi = document.createElement('li');
                         headerLi.className = 'sensor-group-header';
                         headerLi.style.cssText = 'background: #222; padding: 6px 10px; margin-top: 20px; margin-bottom: 8px; border-radius: 4px; font-weight: bold; color: #888; border-bottom: 1px dashed #444; font-size: 12px; text-transform: uppercase; letter-spacing: 1px;';
                         headerLi.textContent = 'Unassigned Sensors';
                         listEl.appendChild(headerLi);
                     }
                     
                     unassigned.forEach(sensor => {
                         listEl.appendChild(this._createSensorListItem(sensor));
                     });
                }
                
                // Wire up button handlers
                this._wireButtonHandlers();
            },
            
            /**
             * Wire up button click handlers
             */
            _wireButtonHandlers: function() {
                const self = this;
                
                // Track buttons
                document.querySelectorAll('.sensor-track-btn').forEach(btn => {
                    btn.addEventListener('click', function() {
                        const sensorId = this.getAttribute('data-sensor-id');
                        self.flyTo(sensorId);
                    });
                });

                // Group Move Buttons
                document.querySelectorAll('.group-move-btn').forEach(btn => {
                     btn.addEventListener('click', function(e) {
                         e.stopPropagation();
                         const group = this.getAttribute('data-group');
                         const action = this.getAttribute('data-action');
                         self._moveGroup(group, action);
                     });
                });
                
                // Assign buttons
                document.querySelectorAll('.sensor-assign-btn').forEach(btn => {
                    btn.addEventListener('click', function() {
                        const sensorId = this.getAttribute('data-sensor-id');
                        self._showAssignDialog(sensorId);
                    });
                });
                
                // Delete buttons
                document.querySelectorAll('.sensor-delete-btn').forEach(btn => {
                    btn.addEventListener('click', function() {
                        const sensorId = this.getAttribute('data-sensor-id');
                        if (confirm(`Delete sensor ${sensorId}?`)) {
                            self.delete(sensorId);
                        }
                    });
                });
            },
            
            /**
             * Show dialog to assign sensor to entity
             */
            _showAssignDialog: function(sensorId) {
                const sensor = this.sensors[sensorId];
                if (!sensor) return;
                
                // Get recon entities
                const reconEntities = (window.AutoReconVisualization && window.AutoReconVisualization.entities) || {};
                const entityIds = Object.keys(reconEntities);
                
                if (entityIds.length === 0) {
                    addConsoleMessage('No recon entities available to assign sensor to', 'alert');
                    return;
                }
                
                // Create dialog
                const dialog = document.createElement('div');
                dialog.className = 'sensor-assign-dialog';
                dialog.style.cssText = 'position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);background:rgba(20,20,20,0.98);padding:16px;border-radius:8px;border:1px solid #444;z-index:99999;min-width:300px;';
                
                let optionsHtml = '';
                entityIds.forEach(eid => {
                    const e = reconEntities[eid];
                    optionsHtml += `<option value="${eid}">${e.name || eid}</option>`;
                });
                
                dialog.innerHTML = `
                    <h4 style="margin:0 0 12px 0;color:#4a9eff;">Assign Sensor: ${sensor.label || sensorId}</h4>
                    <div style="margin-bottom:12px;">
                        <label style="font-size:11px;color:#888;">Select Recon Entity</label>
                        <select id="assign-entity-select" style="width:100%;padding:8px;background:#222;border:1px solid #444;border-radius:4px;color:#fff;">
                            ${optionsHtml}
                        </select>
                    </div>
                    <div style="display:flex;gap:8px;justify-content:flex-end;">
                        <button class="action-button assign-cancel-btn" style="background:#444;">Cancel</button>
                        <button class="action-button assign-confirm-btn" style="background:#4a9eff;">Assign</button>
                    </div>
                `;
                
                document.body.appendChild(dialog);
                
                // Wire handlers
                dialog.querySelector('.assign-cancel-btn').addEventListener('click', () => {
                    document.body.removeChild(dialog);
                });
                
                const self = this;
                dialog.querySelector('.assign-confirm-btn').addEventListener('click', async () => {
                    const entityId = dialog.querySelector('#assign-entity-select').value;
                    if (entityId) {
                        await self.assign(sensorId, entityId);
                    }
                    document.body.removeChild(dialog);
                });
            },
            
            /**
             * Fly camera to sensor location or assigned entity
             */
            flyTo: function(sensorId) {
                const sensor = this.sensors[sensorId];
                if (!sensor) return;

                // Check if assigned to an entity
                let assignedEntityId = null;
                for (const [eid, sids] of Object.entries(this.assignments)) {
                    if (sids.includes(sensorId)) {
                        assignedEntityId = eid;
                        break;
                    }
                }

                let targetPos = null;
                let targetLabel = sensor.label || sensorId;

                if (assignedEntityId) {
                    const reconEntities = (window.AutoReconVisualization && window.AutoReconVisualization.entities) || {};
                    const entity = reconEntities[assignedEntityId];
                    if (entity && entity.location) {
                        const lat = parseFloat(entity.location.lat || entity.location.latitude);
                        const lon = parseFloat(entity.location.lon || entity.location.longitude);
                        if (!isNaN(lat) && !isNaN(lon)) {
                            targetPos = Cesium.Cartesian3.fromDegrees(lon, lat, 2000); // 2km alt
                            targetLabel = `Entity ${entity.name || assignedEntityId}`;
                            addConsoleMessage(`Tracking assigned entity: ${targetLabel}`, 'response');
                        }
                    }
                }

                // Fallback to sensor position if no assigned entity or entity has no position
                if (!targetPos && sensor.position) {
                    const pos = sensor.position;
                    const lat = parseFloat(pos.lat || pos.latitude);
                    const lon = parseFloat(pos.lon || pos.longitude);
                    if (!isNaN(lat) && !isNaN(lon)) {
                        targetPos = Cesium.Cartesian3.fromDegrees(lon, lat, 10000); // 10km alt
                        addConsoleMessage(`Tracking sensor: ${targetLabel}`, 'response');
                    }
                }

                if (targetPos && window.viewer) {
                    if (typeof flyToWithReset === 'function') {
                        flyToWithReset({
                            destination: targetPos,
                            duration: 1.5,
                            orientation: {
                                heading: Cesium.Math.toRadians(0),
                                pitch: Cesium.Math.toRadians(-45),
                                roll: 0.0
                            }
                        });
                    } else {
                        window.viewer.camera.flyTo({
                            destination: targetPos,
                            duration: 1.5,
                            orientation: {
                                heading: Cesium.Math.toRadians(0),
                                pitch: Cesium.Math.toRadians(-45),
                                roll: 0.0
                            }
                        });
                    }
                } else {
                     addConsoleMessage(`Could not determine position for ${targetLabel}`, 'alert');
                }
            },
            
            /**
             * Visualize sensors on the Cesium map
             */
            _visualize: function() {
                if (!window.viewer) return;
                
                const sensorIds = Object.keys(this.sensors);
                
                // Remove markers for sensors no longer present
                Object.keys(this.markers).forEach(mid => {
                    if (!this.sensors[mid]) {
                        this._removeMarker(mid);
                    }
                });
                
                // Add/update markers for current sensors
                sensorIds.forEach(sid => {
                    const sensor = this.sensors[sid];
                    if (!sensor.position) return;
                    
                    const pos = sensor.position;
                    const lat = parseFloat(pos.lat || pos.latitude);
                    const lon = parseFloat(pos.lon || pos.longitude);
                    
                    if (isNaN(lat) || isNaN(lon)) return;
                    
                    // Determine marker color by type
                    const colorMap = {
                        'SDR': Cesium.Color.CYAN,
                        'RADAR': Cesium.Color.ORANGE,
                        'CAMERA': Cesium.Color.YELLOW,
                        'ACOUSTIC': Cesium.Color.PURPLE,
                        'SIGINT': Cesium.Color.LIME
                    };
                    const color = colorMap[sensor.type] || Cesium.Color.CYAN;
                    
                    if (this.markers[sid]) {
                        // Update existing marker
                        this.markers[sid].position = Cesium.Cartesian3.fromDegrees(lon, lat, 100);
                    } else {
                        // Create new marker (triangle shape via billboard or point)
                        this.markers[sid] = window.viewer.entities.add({
                            id: `sensor-${sid}`,
                            position: Cesium.Cartesian3.fromDegrees(lon, lat, 100),
                            point: {
                                pixelSize: 14,
                                color: color,
                                outlineColor: Cesium.Color.WHITE,
                                outlineWidth: 2
                            },
                            label: {
                                text: sensor.label || sid,
                                font: '11px sans-serif',
                                style: Cesium.LabelStyle.FILL_AND_OUTLINE,
                                outlineWidth: 2,
                                verticalOrigin: Cesium.VerticalOrigin.BOTTOM,
                                pixelOffset: new Cesium.Cartesian2(0, -18),
                                fillColor: color,
                                outlineColor: Cesium.Color.BLACK
                            },
                            description: `<div><strong>${sensor.label || sid}</strong><br>Type: ${sensor.type || 'SDR'}<br>Tx: ${sensor.tx_config?.frequency_mhz || '—'} MHz<br>Rx: ${sensor.rx_config?.frequency_mhz || '—'} MHz</div>`
                        });
                    }
                });
                
                // Draw assignment edges
                this._drawAssignmentEdges();
            },
            
            /**
             * Draw lines connecting sensors to their assigned entities
             */
            _drawAssignmentEdges: function() {
                if (!window.viewer) return;
                
                // Remove existing assignment lines
                window.viewer.entities.values
                    .filter(e => e.id && e.id.startsWith('sensor-assignment-'))
                    .forEach(e => window.viewer.entities.remove(e));
                
                // Draw new assignment lines
                Object.keys(this.assignments).forEach(entityId => {
                    const sensorIds = this.assignments[entityId];
                    if (!sensorIds || sensorIds.length === 0) return;
                    
                    // Get entity position
                    const reconEntities = (window.AutoReconVisualization && window.AutoReconVisualization.entities) || {};
                    const entity = reconEntities[entityId];
                    if (!entity || !entity.location) return;
                    
                    const eLat = parseFloat(entity.location.lat || entity.location.latitude);
                    const eLon = parseFloat(entity.location.lon || entity.location.longitude);
                    
                    if (isNaN(eLat) || isNaN(eLon)) return;

                    const entityPos = Cesium.Cartesian3.fromDegrees(eLon, eLat, 100);
                    
                    sensorIds.forEach(sid => {
                        const sensor = this.sensors[sid];
                        if (!sensor || !sensor.position) return;

                        const sLat = parseFloat(sensor.position.lat || sensor.position.latitude);
                        const sLon = parseFloat(sensor.position.lon || sensor.position.longitude);
                        
                        if (isNaN(sLat) || isNaN(sLon)) return;
                        
                        const sensorPos = Cesium.Cartesian3.fromDegrees(sLon, sLat, 100);
                        
                        // Check if points are too close/identical to avoid arc errors
                        const distance = Cesium.Cartesian3.distance(entityPos, sensorPos);
                        if (distance < 1.0) return; 

                        // Create assignment line
                        window.viewer.entities.add({
                            id: `sensor-assignment-${sid}-${entityId}`,
                            polyline: {
                                positions: [sensorPos, entityPos],
                                width: 2,
                                arcType: Cesium.ArcType.GEODESIC,
                                material: new Cesium.PolylineDashMaterialProperty({
                                    color: Cesium.Color.CYAN.withAlpha(0.6),
                                    dashLength: 16
                                })
                            }
                        });
                    });
                });
            },
            
            /**
             * Remove a sensor marker from the map
             */
            _removeMarker: function(sensorId) {
                if (this.markers[sensorId]) {
                    if (window.viewer) {
                        window.viewer.entities.remove(this.markers[sensorId]);
                    }
                    delete this.markers[sensorId];
                }
            },
            
            /**
             * Initialize the sensor panel UI bindings
             */
            init: function() {
                const self = this;
                
                // Load button
                const loadBtn = document.getElementById('sensorLoadBtn');
                if (loadBtn) {
                    loadBtn.addEventListener('click', () => self.load());
                }
                
                // Create button - show/hide form
                const createBtn = document.getElementById('sensorCreateBtn');
                const form = document.getElementById('sensor-create-form');
                if (createBtn && form) {
                    createBtn.addEventListener('click', () => {
                        form.style.display = form.style.display === 'none' ? 'block' : 'none';
                        self._populateEntityDropdown();
                    });
                }
                
                // Cancel button
                const cancelBtn = document.getElementById('sensor-cancel-btn');
                if (cancelBtn && form) {
                    cancelBtn.addEventListener('click', () => {
                        form.style.display = 'none';
                    });
                }
                
                // Save button
                const saveBtn = document.getElementById('sensor-save-btn');
                if (saveBtn) {
                    saveBtn.addEventListener('click', async () => {
                        const label = document.getElementById('sensor-label')?.value || '';
                        const type = document.getElementById('sensor-type')?.value || 'SDR';
                        const txFreq = parseFloat(document.getElementById('sensor-tx-freq')?.value) || null;
                        const rxFreq = parseFloat(document.getElementById('sensor-rx-freq')?.value) || null;
                        const txPower = parseFloat(document.getElementById('sensor-tx-power')?.value) || null;
                        const rxSens = parseFloat(document.getElementById('sensor-rx-sens')?.value) || null;
                        const lat = parseFloat(document.getElementById('sensor-lat')?.value) || null;
                        const lon = parseFloat(document.getElementById('sensor-lon')?.value) || null;
                        const assignEntity = document.getElementById('sensor-assign-entity')?.value || null;
                        
                        if (!label) {
                            addConsoleMessage('Please enter a sensor label', 'alert');
                            return;
                        }
                        
                        const sensorData = {
                            label: label,
                            type: type,
                            tx_config: txFreq ? { frequency_mhz: txFreq, power_dbm: txPower } : null,
                            rx_config: rxFreq ? { frequency_mhz: rxFreq, sensitivity_dbm: rxSens } : null,
                            position: (lat !== null && lon !== null) ? { lat, lon } : null
                        };
                        
                        try {
                            const sensor = await self.upsert(sensorData);
                            
                            // Assign to entity if selected
                            if (assignEntity && sensor) {
                                await self.assign(sensor.sensor_id, assignEntity);
                            }
                            
                            // Hide form and clear inputs
                            if (form) form.style.display = 'none';
                            document.getElementById('sensor-label').value = '';
                            document.getElementById('sensor-tx-freq').value = '';
                            document.getElementById('sensor-rx-freq').value = '';
                            document.getElementById('sensor-tx-power').value = '';
                            document.getElementById('sensor-rx-sens').value = '';
                            document.getElementById('sensor-lat').value = '';
                            document.getElementById('sensor-lon').value = '';
                            
                        } catch (err) {
                            // Error already logged
                        }
                    });
                }
                
                console.log('[SensorManager] Initialized');
            },
            
            /**
             * Populate the entity dropdown with current recon entities
             */
            _populateEntityDropdown: function() {
                const select = document.getElementById('sensor-assign-entity');
                if (!select) return;
                
                const reconEntities = (window.AutoReconVisualization && window.AutoReconVisualization.entities) || {};
                const entityIds = Object.keys(reconEntities);
                
                select.innerHTML = '<option value="">-- None --</option>';
                entityIds.forEach(eid => {
                    const e = reconEntities[eid];
                    const opt = document.createElement('option');
                    opt.value = eid;
                    opt.textContent = e.name || eid;
                    select.appendChild(opt);
                });
            },
            
            /**
             * Handle EntitySync events for SENSOR and SENSOR_ASSIGNMENT types
             */
            applyEntitySyncEvent: function(event) {
                const entityType = event.entity?.type || event.type;
                
                if (entityType === 'SENSOR') {
                    if (event.event === 'DELETE') {
                        delete this.sensors[event.entity_id];
                        this._removeMarker(event.entity_id);
                    } else {
                        // CREATE or UPDATE
                        this.sensors[event.entity_id] = event.entity;
                    }
                    this._updateUI();
                    this._visualize();
                    
                } else if (entityType === 'SENSOR_ASSIGNMENT') {
                    // Handle assignment changes
                    const entityId = event.entity?.entity_id;
                    const sensorId = event.entity?.sensor_id;
                    
                    if (!entityId || !sensorId) return;
                    
                    if (event.event === 'DELETE') {
                        if (this.assignments[entityId]) {
                            this.assignments[entityId] = this.assignments[entityId].filter(sid => sid !== sensorId);
                        }
                    } else {
                        if (!this.assignments[entityId]) {
                            this.assignments[entityId] = [];
                        }
                        if (!this.assignments[entityId].includes(sensorId)) {
                            this.assignments[entityId].push(sensorId);
                        }
                    }
                    this._visualize();
                }
            },
            
            /**
             * Subscribe to EntitySync for SENSOR events
             */
            subscribeToEntitySync: function() {
                if (typeof EntitySync === 'undefined') {
                    console.warn('[SensorManager] EntitySync not available');
                    return;
                }
                
                const self = this;
                const applyEvent = (event) => {
                    const entityType = event.entity?.type || event.type;
                    if (entityType === 'SENSOR' || entityType === 'SENSOR_ASSIGNMENT') {
                        self.applyEntitySyncEvent(event);
                    }
                };
                
                EntitySync.on('preexisting', applyEvent);
                EntitySync.on('create', applyEvent);
                EntitySync.on('update', applyEvent);
                EntitySync.on('delete', applyEvent);
                
                console.log('[SensorManager] Subscribed to EntitySync for SENSOR events');
            }
        };
        
        // Make SensorManager globally available
        window.SensorManager = SensorManager;
        
        // Initialize SensorManager when DOM is ready
        document.addEventListener('DOMContentLoaded', function() {
            if (window.SensorManager) {
                window.SensorManager.init();
                
                // Subscribe to EntitySync
                if (typeof EntitySync !== 'undefined') {
                    setTimeout(() => window.SensorManager.subscribeToEntitySync(), 200);
                }
            }
        });


        // =====================================================================
        // LPI PROCESSING MODULE - "Pace-compliant" Signal Intelligence
        // =====================================================================
        const LPIManager = {
            state: {
                feedBySensor: {}, // { [sensor_id]: [] }
                latestBySensor: {}, // { [sensor_id]: { lastSeen, lastCandidate, lastClass, snr_db } }
                artifacts: {}, // { [hash]: { uri, type, createdAt } }
                eventCount: 0
            },
            
            config: {
                maxFeedItems: 500,
                pulseDuration: 3000 // ms for Cesium pulse
            },

            init: function() {
                // Wire up UI controls
                const clearBtn = document.getElementById('lpi-clear-btn');
                if (clearBtn) {
                    clearBtn.addEventListener('click', () => {
                        this.state.feedBySensor = {};
                        this.state.eventCount = 0;
                        this._renderFeed(true);
                        document.getElementById('lpi-summary-container').innerHTML = '<div style="padding: 10px; background: rgba(30,30,30,0.6); border: 1px dashed #444; border-radius: 4px; text-align: center; color: #666; font-size: 12px;">Waiting for signal activity...</div>';
                    });
                }
                
                const runSimBtn = document.getElementById('lpi-run-sim-btn');
                if (runSimBtn) {
                    runSimBtn.addEventListener('click', async () => {
                         addConsoleMessage('Starting LPI Simulation...', 'response');
                         const families = ['fmcw', 'phase_coded', 'noise_like'];
                         const family = families[Math.floor(Math.random() * families.length)];
                         const snr = 5.0 + Math.random() * 20.0;
                         
                         // Try to pick an existing sensor so the map pulse works
                         let sensorId = 'SENSOR-TEST';
                         if (window.SensorManager && window.SensorManager.sensors) {
                             const ids = Object.keys(window.SensorManager.sensors);
                             if (ids.length > 0) {
                                 sensorId = ids[Math.floor(Math.random() * ids.length)];
                             }
                         }

                         try {
                              const resp = await fetch(`/api/sensors/${sensorId}/process/lpi`, {
                                  method: 'POST',
                                  headers: {'Content-Type': 'application/json'},
                                  body: JSON.stringify({
                                      window: { center_freq_hz: 915000000 + Math.floor(Math.random()*1000000) },
                                      simulate_detection: true,
                                      snr_db: snr,
                                      signal_family: family
                                  })
                              });
                              if (resp.ok) {
                                  const data = await resp.json();
                                  // addConsoleMessage(`Simulated ${family.toUpperCase()} at ${snr.toFixed(1)}dB`, 'success');
                                  
                                  // DIRECT FEEDBACK: Inject the trace immediately
                                  if (data.pipeline_trace) {
                                      data.pipeline_trace.forEach(item => {
                                          this.handleActivityEvent({
                                              sensor_id: sensorId,
                                              activity_type: item.kind,
                                              payload: item,
                                              timestamp: item.timestamp
                                          });
                                      });
                                  }
                                  
                                  // CAMERA TRACKING
                                  if (window.SensorManager && window.SensorManager.flyTo) {
                                      window.SensorManager.flyTo(sensorId);
                                  }

                              } else {
                                  console.error('Sim error', resp);
                              }
                         } catch(e) {
                              console.error(e);
                              addConsoleMessage('Simulation failed: ' + e.message, 'alert');
                         }
                    });
                }

                console.log('[LPIManager] Initialized');
            },

            subscribeToEntitySync: function() {
                if (typeof EntitySync === 'undefined') {
                     console.warn('[LPIManager] EntitySync unavailable');
                     return;
                }
                
                const handler = (evt) => {
                   const entity = evt.entity || evt; // Adapt to EntitySync event format
                   if (entity && entity.type === 'SENSOR_ACTIVITY') {
                       this.handleActivityEvent(entity);
                   }
                };

                EntitySync.on('create', handler);
                EntitySync.on('update', handler); // If activity updates happen
                console.log('[LPIManager] Subscribed to EntitySync');
            },

            handleActivityEvent: function(data) {
                // data: { sensor_id, activity_type, payload, timestamp }
                const sensorId = data.sensor_id;
                const kind = data.activity_type || 'unknown';
                const payload = data.payload || {};
                
                // 1. Update State
                if (!this.state.feedBySensor[sensorId]) {
                    this.state.feedBySensor[sensorId] = [];
                }
                
                const eventRecord = {
                    t: payload.timestamp || Date.now() / 1000,
                    kind: kind,
                    snr_db: payload.snr_db,
                    confidence: payload.confidence,
                    algo: payload.algo,
                    classes: payload.classes,
                    evidence: payload.evidence,
                    raw: data
                };
                
                this.state.feedBySensor[sensorId].unshift(eventRecord);
                if (this.state.feedBySensor[sensorId].length > this.config.maxFeedItems) {
                    this.state.feedBySensor[sensorId].pop();
                }
                
                this.state.eventCount++;

                // Update Latest
                if (!this.state.latestBySensor[sensorId]) {
                    this.state.latestBySensor[sensorId] = {};
                }
                const latest = this.state.latestBySensor[sensorId];
                latest.lastSeen = Date.now();
                if(payload.snr_db) latest.snr_db = payload.snr_db;
                
                if (kind === 'lpi_candidate_detected') latest.lastCandidate = eventRecord;
                if (kind === 'waveform_classified') latest.lastClass = eventRecord;

                // Index Artifacts
                if (payload.evidence) {
                    const ev = payload.evidence;
                    if (ev.iq_hash) {
                         this.state.artifacts[ev.iq_hash] = { uri: ev.iq_ptr, type: 'iq', createdAt: Date.now() };
                    }
                    if (ev.artifact_ptrs) {
                        Object.keys(ev.artifact_ptrs).forEach(key => {
                             const ptr = ev.artifact_ptrs[key];
                             // quick hash based on ptr string if no hash provided
                             const h = key + '_' + (ev.iq_hash||'').substring(0,6);
                             this.state.artifacts[h] = { uri: ptr, type: key, createdAt: Date.now() };
                        });
                    }
                }

                // 2. Update UI
                // Throttling could be added here for high-throughput
                requestAnimationFrame(() => {
                    this._renderFeed();
                    this._renderSummary(sensorId);
                });

                // 3. Visualize
                if (kind === 'lpi_candidate_detected' || kind === 'waveform_classified') {
                    this._triggerCesiumPulse(sensorId, kind, payload);
                }
            },
            
            _renderFeed: function(clear=false) {
                const list = document.getElementById('lpiList');
                if (!list) return;
                
                if (clear) {
                    list.innerHTML = '';
                    document.getElementById('lpi-event-count').textContent = '0';
                    return;
                }

                document.getElementById('lpi-event-count').textContent = this.state.eventCount;

                // Get flattened sorted list for display
                let allEvents = [];
                Object.entries(this.state.feedBySensor).forEach(([sid, arr]) => {
                     arr.forEach(e => { e._sid = sid; }); // tag with sensor id temporarily
                     allEvents.push(...arr);
                });
                
                // Sort descending by time
                allEvents.sort((a,b) => b.t - a.t);
                
                // Limit to 50 for DOM
                const displayEvents = allEvents.slice(0, 50);
                
                // Render
                 const fragment = document.createDocumentFragment();
                 displayEvents.forEach(evt => {
                     const li = document.createElement('li');
                     li.className = 'list-item';
                     li.style.borderLeft = this._getColorForKind(evt.kind);
                     li.style.cursor = 'pointer';
                     
                     // Nice formatting for time
                     const date = new Date(evt.t * 1000);
                     const timeStr = date.toLocaleTimeString([], { hour12: false, hour:'2-digit', minute:'2-digit', second:'2-digit' }) + '.' + date.getMilliseconds().toString().padStart(3,'0');
                     
                     // Content details
                     let details = `SNR: <span style="color:#fff">${evt.snr_db ? evt.snr_db.toFixed(1) + ' dB' : '--'}</span>`;
                     if (evt.classes && evt.classes.length > 0) {
                         const top = evt.classes[0];
                         details += ` | <span style="color:#f88; font-weight:bold;">${top.class}</span> (${(top.confidence*100).toFixed(0)}%)`;
                     } else if (evt.kind === 'lpi_candidate_detected') {
                         details += ` | <span style="color:#fd0">Candidate</span>`;
                     } else if (evt.kind === 'tf_computed') {
                        details += ` | Time-Freq`;
                     }

                     li.innerHTML = `
                        <div class="list-item-header">
                            <span class="list-item-title" style="font-size:11px;">${evt._sid} / ${evt.kind.replace(/_/g, ' ').toUpperCase()}</span>
                            <span style="font-size:10px; color:#666;">${timeStr}</span>
                        </div>
                        <div class="list-item-subtitle">
                             ${details}
                        </div>
                     `;
                     li.onclick = () => this._showDetails(evt);
                     fragment.appendChild(li);
                 });
                 list.innerHTML = '';
                 list.appendChild(fragment);
            },
            
            _renderSummary: function(sensorId) {
                const container = document.getElementById('lpi-summary-container');
                if (!container) return;
                
                // Ensure we aren't duplicating
                let card = document.getElementById(`lpi-card-${sensorId}`);
                if (!card) {
                    // Remove "Waiting" placeholder if it exists
                    if(container.innerText.includes('Waiting')) container.innerHTML = '';
                    
                    card = document.createElement('div');
                    card.id = `lpi-card-${sensorId}`;
                    card.className = 'settings-group'; // re-use existing style class for box
                    card.style.cssText = 'padding: 8px; background: rgba(20,20,30,0.8); border: 1px solid #444; border-radius: 4px;';
                    container.prepend(card);
                }
                
                const latest = this.state.latestBySensor[sensorId];
                if (!latest) return;
                
                const lastClass = latest.lastClass;
                const lastCand = latest.lastCandidate;
                
                // Determine current status
                let statusHtml = '';
                let borderColor = '#444';
                
                if (lastClass && (Date.now() - (lastClass.t * 1000) < 10000)) {
                    // Active classification (< 10s old)
                    const cls = lastClass.classes[0];
                    borderColor = '#f44';
                    statusHtml = `
                        <div style="color:#f66; font-weight:bold; font-size:13px;">${cls.class.toUpperCase()} DETECTED</div>
                        <div style="font-size:11px; color:#aaa;">Conf: ${(cls.confidence*100).toFixed(1)}% | SNR: ${lastClass.snr_db.toFixed(1)} dB</div>
                        <div style="font-size:10px; color:#888; margin-top:2px;">Target: ${sensorId}</div>
                    `;
                } else if (lastCand && (Date.now() - (lastCand.t * 1000) < 10000)) {
                     // Active candidate
                     borderColor = '#fd0';
                     statusHtml = `
                        <div style="color:#fd0; font-weight:bold; font-size:13px;">LPI SIGNAL DETECTED</div>
                        <div style="font-size:11px; color:#aaa;">Investigating... | SNR: ${lastCand.snr_db ? lastCand.snr_db.toFixed(1) : '?'} dB</div>
                        <div style="font-size:10px; color:#888; margin-top:2px;">Target: ${sensorId}</div>
                     `;
                } else {
                    // Idle
                    statusHtml = `
                        <div style="color:#aaa; font-weight:bold; font-size:13px;">${sensorId}</div>
                        <div style="font-size:11px; color:#666;">Monitoring... | Last SNR: ${latest.snr_db ? latest.snr_db.toFixed(1) : '--'} dB</div>
                    `;
                }
                
                card.style.borderColor = borderColor;
                card.innerHTML = statusHtml;
            },

            _showDetails: function(evt) {
                 const panel = document.getElementById('lpi-details-panel');
                 const pre = document.getElementById('lpi-details-json');
                 if(panel && pre) {
                     panel.style.display = 'block';
                     // Format logic: show full raw payload
                     pre.textContent = JSON.stringify(evt.raw, null, 2);
                 }
            },
            
            _triggerCesiumPulse: function(sensorId, kind, payload) {
                 if (!window.viewer || !window.SensorManager) return;
                 const sensor = window.SensorManager.sensors[sensorId];
                 if (!sensor || !sensor.position) return;
                 
                 const lat = parseFloat(sensor.position.lat || sensor.position.latitude);
                 const lon = parseFloat(sensor.position.lon || sensor.position.longitude);
                 if(isNaN(lat) || isNaN(lon)) return;
                 
                 // Pulse color
                 const color = kind === 'waveform_classified' ? Cesium.Color.RED : Cesium.Color.YELLOW;
                 
                 // 1. Add expanding cylinder (pulse)
                 const pulseId = 'lpi-pulse-' + sensorId + '-' + Date.now();
                 let radius = 100.0;
                 
                 const entity = window.viewer.entities.add({
                     id: pulseId,
                     position: Cesium.Cartesian3.fromDegrees(lon, lat),
                     ellipse: {
                         semiMajorAxis: new Cesium.CallbackProperty(() => radius, false),
                         semiMinorAxis: new Cesium.CallbackProperty(() => radius, false),
                         material: new Cesium.ColorMaterialProperty(new Cesium.CallbackProperty(() => {
                             const alpha = 1.0 - (radius / 5000.0);
                             return color.withAlpha(alpha < 0 ? 0 : alpha); 
                         }, false)),
                         height: 50.0
                     }
                 });
                 
                 // Animation Loop for this pulse
                 const startTime = Date.now();
                 const duration = 2000; 
                 
                 const animate = () => {
                     const now = Date.now();
                     const elapsed = now - startTime;
                     
                     if (elapsed > duration) {
                         window.viewer.entities.remove(entity);
                         return;
                     }
                     
                     // Expand radius
                     const progress = elapsed / duration;
                     radius = 100.0 + (5000.0 * progress); // 100m to 5km
                     
                     requestAnimationFrame(animate);
                 };
                 requestAnimationFrame(animate);
                 
                 // 2. Add Floating Label
                 if (kind === 'waveform_classified') {
                    const classes = payload.classes || [];
                    const topClass = classes[0] ? classes[0].class : 'UNKNOWN';
                    
                    const labelId = 'lpi-label-' + sensorId + '-' + Date.now();
                    const labelEnt = window.viewer.entities.add({
                        id: labelId,
                        position: Cesium.Cartesian3.fromDegrees(lon, lat, 2000), // Height
                        label: {
                             text: `⚠ ${topClass}`,
                             font: '16px Monospace',
                             style: Cesium.LabelStyle.FILL_AND_OUTLINE,
                             fillColor: Cesium.Color.RED,
                             outlineColor: Cesium.Color.BLACK,
                             outlineWidth: 2,
                             verticalOrigin: Cesium.VerticalOrigin.BOTTOM,
                             pixelOffset: new Cesium.Cartesian2(0, -10 + (-1 * (Date.now() % 50))) // slight randomness
                        }
                    });
                    setTimeout(() => window.viewer.entities.remove(labelEnt), 4000);
                 }
            },
            
            _getColorForKind: function(kind) {
                if (kind.includes('window')) return '3px solid #666';
                if (kind.includes('tf')) return '3px solid #4a9eff';
                if (kind.includes('candidate')) return '3px solid #ffcc00';
                if (kind.includes('classified')) return '3px solid #ff4444';
                return '3px solid #ccc';
            }
        };
        
        // Expose
        window.LPIManager = LPIManager;
        // Init
        document.addEventListener('DOMContentLoaded', () => {
             if (window.LPIManager) {
                 window.LPIManager.init();
                 if (typeof EntitySync !== 'undefined') {
                    setTimeout(() => window.LPIManager.subscribeToEntitySync(), 500);
                 }
             }
        });

        // =====================================================================
        // FUSION DEMO VISUALIZATION (AoA + TDoA)
        // =====================================================================

        const FusionVisualization = {
            init: function() {
                if (typeof EntitySync !== 'undefined') {
                    const handler = (evt) => {
                        const entity = evt.entity || evt;
                        // Handle sensor activity edges
                        if (entity && entity.type === 'SENSOR_ACTIVITY') {
                            this.handleActivity(entity);
                        }
                    };
                    EntitySync.on('create', handler);
                    EntitySync.on('update', handler);
                    console.log('[FusionVisualization] Initialized & Subscribed');
                } else {
                    setTimeout(() => this.init(), 1000);
                }
            },

            handleActivity: function(data) {
                // data is proper Entity structure: { entity_id, entity_type, entity_data, provenance... }
                let payload = null;
                let kind = null;
                let sensorId = null;

                if (data.entity_data && data.entity_data.kind) {
                     // Edge Format
                     kind = data.entity_data.kind;
                     payload = data.entity_data.metadata ? data.entity_data.metadata.payload : null;
                     
                     // Find sensor node in edge nodes
                     const nodes = data.entity_data.nodes || [];
                     const sensorNode = nodes.find(n => n.startsWith('sensor:'));
                     if (sensorNode) sensorId = sensorNode.replace('sensor:', '');
                } else if (data.sensor_id && data.activity_type) {
                     // Flattened Format (like LPIManager uses)
                     kind = data.activity_type;
                     payload = data.payload;
                     sensorId = data.sensor_id;
                }

                if (!payload || !sensorId) return;

                if (kind === 'aoa_measured') {
                    this.drawAoA(sensorId, payload);
                } else if (kind === 'tdoa_measured') {
                    this.drawTDoA(sensorId, payload);
                } else if (kind === 'ndpi_flow_aggregate') {
                    this.drawFlow(sensorId, payload);
                } else if (kind === 'geoip_resolved') {
                    this.updateGeoNode(payload);
                }
            },

            drawFlow: function(sensorId, payload) {
                 // payload: { src_ip, dst_ip, bytes, protocol_hist, ... }
                 // Need both endpoints resolved to Lat/Lon
                 const srcPos = this.getIpPosition(payload.src_ip);
                 const dstPos = this.getIpPosition(payload.dst_ip);
                 
                 // If one missing, check if it's the sensor itself (or private IP assumed near sensor)
                 // For now, only draw if ONE is known geo-resolved, and map the other to sensor if private? 
                 // Or just draw if both known.
                 
                 if (srcPos && dstPos) {
                     // Draw Arc
                     const color = this.getProtocolColor(payload.protocol_hist);
                     const width = Math.min(Math.max(Math.log10(payload.bytes||1), 1), 8);
                     
                     const entity = window.viewer.entities.add({
                         polyline: {
                             positions: [srcPos, dstPos],
                             width: width,
                             material: new Cesium.PolylineArrowMaterialProperty(color),
                             arcType: Cesium.ArcType.GEODESIC
                         }
                     });
                     setTimeout(() => window.viewer.entities.remove(entity), 10000); // 10s persistence for flows
                 }
            },
            
            // Cache of IP -> Cartesian3
            ipCache: {},
            
            updateGeoNode: function(payload) {
                 // payload: { ip, geo: { lat, lon, city, ... }, asn: ... }
                 if (payload && payload.ip && payload.geo) {
                     const p = Cesium.Cartesian3.fromDegrees(payload.geo.lon, payload.geo.lat, 0);
                     this.ipCache[payload.ip] = p;
                     
                     // Draw Node Point
                     const entity = window.viewer.entities.add({
                         position: p,
                         point: {
                             pixelSize: 8,
                             color: Cesium.Color.fromCssColorString('#4a9eff'),
                             outlineColor: Cesium.Color.BLACK,
                             outlineWidth: 1
                         },
                         label: {
                             text: payload.ip + (payload.geo.city ? `\n${payload.geo.city}` : ''),
                             font: '10px monospace',
                             verticalOrigin: Cesium.VerticalOrigin.TOP,
                             pixelOffset: new Cesium.Cartesian2(0, 5),
                             distanceDisplayCondition: new Cesium.DistanceDisplayCondition(0, 5000000)
                         }
                     });
                     // Persistent node? Or fade?
                     // For now, let's keep them (or fade very slowly)
                     setTimeout(() => window.viewer.entities.remove(entity), 60000);
                 }
            },
            
            getIpPosition: function(ip) {
                // Return Cartesian3 if known
                if (this.ipCache[ip]) return this.ipCache[ip];
                
                // If private IP (e.g. 192.168...), assume it is AT the sensor/VM location
                // Demo Hack: Map 192.168.1.50 to Los Angeles (Simulated VM Location)
                if (ip.startsWith('192.168.') || ip.startsWith('10.') || ip.startsWith('172.')) {
                     // 34.0522, -118.2437
                     return Cesium.Cartesian3.fromDegrees(-118.2437, 34.0522, 0);
                }
                
                return null;
            },
            
            getProtocolColor: function(hist) {
                // hist: { "TLS": 10, "HTTP": 2 }
                if (!hist) return Cesium.Color.ALICEBLUE;
                const topProto = Object.keys(hist).reduce((a, b) => hist[a] > hist[b] ? a : b);
                
                switch(topProto) {
                    case 'TLS': return Cesium.Color.LIME;
                    case 'QUIC': return Cesium.Color.MAGENTA;
                    case 'DNS': return Cesium.Color.CYAN;
                    case 'HTTP': return Cesium.Color.YELLOW;
                    case 'SSH': return Cesium.Color.ORANGE;
                    default: return Cesium.Color.WHITE.withAlpha(0.5);
                }
            },

            drawAoA: function(sensorId, payload) {
                if (!window.viewer || !window.SensorManager || !window.SensorManager.sensors) return;
                
                const sensor = window.SensorManager.sensors[sensorId];
                if (!sensor) return;

                // Normalize Sensor Position
                const lat = sensor.lat || (sensor.location ? sensor.location.lat : 0);
                const lon = sensor.lon || (sensor.location ? sensor.location.lon : 0);
                const alt = sensor.alt || (sensor.location ? sensor.location.alt : 0);
                if (!lat || !lon) return;

                const bearing = payload.bearing_deg || 0;
                const dist = 5000; // 5km ray length
                
                // Calculate End Point
                const rad = Cesium.Math.toRadians(90 - bearing); // Cesium headings are from North? bearing_deg is usually from North.
                // Standard Math.cos/sin takes radians. 0 deg = North -> 90 deg = East.
                // Trigonometry: 0 angle is usually East (X axis).
                // If bearing is degrees clockwise from North:
                // East (90 deg) -> X axis.
                // North (0 deg) -> Y axis.
                // x = sin(bearing), y = cos(bearing)
                
                const bearingRad = Cesium.Math.toRadians(bearing);
                
                // simplified displacement
                // dy (North) = dist * cos(bearing)
                // dx (East) = dist * sin(bearing)
                
                const earthRadius = 6378137;
                const dy = dist * Math.cos(bearingRad);
                const dx = dist * Math.sin(bearingRad);
                
                const newLat = lat + (dy / earthRadius) * (180 / Math.PI);
                const newLon = lon + (dx / (earthRadius * Math.cos(Math.PI * lat / 180))) * (180 / Math.PI);
                
                const endPos = Cesium.Cartesian3.fromDegrees(newLon, newLat, alt);
                const startPos = Cesium.Cartesian3.fromDegrees(lon, lat, alt);

                const entity = window.viewer.entities.add({
                    polyline: {
                        positions: [startPos, endPos],
                        width: 4,
                        material: new Cesium.PolylineDashMaterialProperty({
                            color: Cesium.Color.YELLOW,
                            dashLength: 16.0
                        })
                    }
                });
                
                // Cone/Sector if desired (omitted for speed)
                
                setTimeout(() => window.viewer.entities.remove(entity), 3000);
            },

            drawTDoA: function(sensorId, payload) {
                 if (!window.viewer || !window.SensorManager || !window.SensorManager.sensors) return;
                 
                 const s1 = window.SensorManager.sensors[sensorId];
                 const s2 = window.SensorManager.sensors[payload.ref_sensor_id];
                 
                 if (!s1 || !s2) return;
                 // Normalize
                 const p1 = Cesium.Cartesian3.fromDegrees(
                     s1.lon || s1.location.lon, 
                     s1.lat || s1.location.lat, 
                     s1.alt || s1.location.alt || 0
                 );
                 const p2 = Cesium.Cartesian3.fromDegrees(
                     s2.lon || s2.location.lon, 
                     s2.lat || s2.location.lat, 
                     s2.alt || s2.location.alt || 0
                 );
                 
                 const mid = Cesium.Cartesian3.midpoint(p1, p2, new Cesium.Cartesian3());
                 
                 const entity = window.viewer.entities.add({
                     polyline: {
                         positions: [p1, p2],
                         width: 2,
                         material: Cesium.Color.CYAN.withAlpha(0.2)
                     },
                     label: {
                         text: `Δt: ${payload.tau_ns.toFixed(1)}ns`,
                         position: mid,
                         font: '12px monospace',
                         fillColor: Cesium.Color.CYAN,
                         pixelOffset: new Cesium.Cartesian2(0, -10),
                         disableDepthTestDistance: Number.POSITIVE_INFINITY,
                         scaleByDistance: new Cesium.NearFarScalar(1.5e2, 1.0, 1.5e7, 0.5)
                     }
                 });
                 
                 setTimeout(() => window.viewer.entities.remove(entity), 3000);
            }
        };
        
        document.addEventListener('DOMContentLoaded', () => FusionVisualization.init());

        // =====================================================================
        // PERSISTENT METRICS LOGGING SYSTEM

        // =====================================================================
        
        const MetricsLogger = {
            // Session identifier
            sessionId: 'session_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9),
            
            // Logging configuration
            config: {
                enabled: true,
                logInterval: 30000,      // Log every 30 seconds
                batchSize: 50,           // Max metrics per batch
                logUserInteractions: true,
                logPerformance: true,
                logHypergraph: true
            },
            
            // Metrics buffer for batching
            metricsBuffer: [],
            lastLogTime: Date.now(),
            
            // For Metrics Explorer access
            _interactionLog: [],         // Keep recent interactions in memory
            _lastMetrics: {},            // Last collected metrics for live display
            
            /**
             * Initialize the metrics logger
             */
            initialize: function() {
                console.log('[MetricsLogger] Initializing with session:', this.sessionId);
                
                // Start periodic logging
                this._startPeriodicLogging();
                
                // Log session start
                this.logInteraction('session_start', 'app', {
                    userAgent: navigator.userAgent,
                    screenWidth: window.innerWidth,
                    screenHeight: window.innerHeight,
                    timestamp: new Date().toISOString()
                });
                
                // Log on page unload
                window.addEventListener('beforeunload', () => {
                    this.flush();
                    this.logInteraction('session_end', 'app', {
                        duration_seconds: (Date.now() - this.lastLogTime) / 1000
                    });
                });
                
                return this;
            },
            
            /**
             * Log a single metric
             */
            log: function(module, metricName, value, metadata = {}) {
                if (!this.config.enabled) return;
                
                this.metricsBuffer.push({
                    module: module,
                    metric_name: metricName,
                    value: value,
                    metadata: metadata,
                    timestamp: Date.now()
                });
                
                // Store for live display
                this._lastMetrics[metricName] = value;
                
                // Flush if buffer is full
                if (this.metricsBuffer.length >= this.config.batchSize) {
                    this.flush();
                }
            },
            
            /**
             * Log a user interaction
             */
            logInteraction: function(action, target, details = {}) {
                if (!this.config.enabled || !this.config.logUserInteractions) return;
                
                // Store in memory for Metrics Explorer
                this._interactionLog.push({
                    action: action,
                    target: target,
                    details: details,
                    timestamp: Date.now()
                });
                
                // Keep only last 100 interactions in memory
                if (this._interactionLog.length > 100) {
                    this._interactionLog = this._interactionLog.slice(-100);
                }
                
                // Send to server
                fetch('/api/metrics/interaction', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        action: action,
                        target: target,
                        details: details,
                        session_id: this.sessionId
                    })
                }).catch(err => console.warn('[MetricsLogger] Interaction log failed:', err));
            },
            
            /**
             * Flush buffered metrics to server
             */
            flush: async function() {
                if (this.metricsBuffer.length === 0) return;
                
                const batch = this.metricsBuffer.splice(0, this.config.batchSize);
                
                try {
                    await fetch('/api/metrics/log', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            batch: batch,
                            session_id: this.sessionId
                        })
                    });
                    console.log(`[MetricsLogger] Flushed ${batch.length} metrics`);
                } catch (err) {
                    console.warn('[MetricsLogger] Flush failed:', err);
                    // Re-add to buffer for retry
                    this.metricsBuffer.unshift(...batch);
                }
            },
            
            /**
             * Collect and log all current system metrics
             */
            collectAndLogMetrics: async function() {
                if (!this.config.enabled) return;
                
                try {
                    // Collect frontend performance metrics
                    if (this.config.logPerformance) {
                        // Recon system metrics
                        if (window.reconViz && window.reconViz.perfMetrics) {
                            const reconMetrics = window.reconViz.perfMetrics;
                            this.log('recon', 'update_count', reconMetrics.updateCount);
                            this.log('recon', 'last_update_ms', reconMetrics.lastUpdateMs);
                            this.log('recon', 'avg_update_ms', reconMetrics.avgUpdateMs);
                            // Handle both plain object and EntityCollection
                            const entities = window.reconViz.entities;
                            const entityCount = entities?.values ? entities.values.length : Object.keys(entities || {}).length;
                            this.log('recon', 'entity_count', entityCount);
                        }
                        
                        // AIS system metrics
                        if (window.aisViz && window.aisViz.vessels) {
                            this.log('ais', 'vessel_count', Object.keys(window.aisViz.vessels).length);
                        }
                        
                        // Cesium viewer metrics
                        if (window.viewer && window.viewer.scene) {
                            const scene = window.viewer.scene;
                            if (scene.debugShowFramesPerSecond) {
                                // FPS is available if debug mode is on
                            }
                            this.log('cesium', 'entity_count', window.viewer.entities.values.length);
                            
                            // Camera altitude
                            try {
                                const carto = Cesium.Cartographic.fromCartesian(window.viewer.camera.position);
                                this.log('cesium', 'camera_altitude_m', carto.height);
                            } catch (e) {}
                        }
                        
                        // Hierarchical render manager metrics
                        if (window.hierarchicalRenderer) {
                            this.log('render', 'current_altitude', window.hierarchicalRenderer.currentAltitude || 0);
                        }
                        
                        // Viewshed manager metrics
                        if (window.viewshedManager) {
                            this.log('viewshed', 'active_count', Object.keys(window.viewshedManager.viewsheds).length);
                        }
                    }
                    
                    // Collect hypergraph metrics
                    if (this.config.logHypergraph && window.hypergraphVisualizer) {
                        const hg = window.hypergraphVisualizer;
                        if (hg.nodes) this.log('hypergraph', 'node_count', hg.nodes.length);
                        if (hg.edges) this.log('hypergraph', 'edge_count', hg.edges.length);
                    }
                    
                    // Collect memory usage (if available)
                    if (performance && performance.memory) {
                        this.log('browser', 'heap_used_mb', performance.memory.usedJSHeapSize / (1024 * 1024));
                        this.log('browser', 'heap_total_mb', performance.memory.totalJSHeapSize / (1024 * 1024));
                    }
                    
                    // Flush collected metrics
                    await this.flush();
                    
                } catch (err) {
                    console.warn('[MetricsLogger] Error collecting metrics:', err);
                }
            },
            
            /**
             * Start periodic metrics collection
             */
            _startPeriodicLogging: function() {
                setInterval(() => {
                    this.collectAndLogMetrics();
                }, this.config.logInterval);
            },
            
            /**
             * Get session summary from server
             */
            getSessionSummary: async function() {
                try {
                    const response = await fetch('/api/metrics/session');
                    return await response.json();
                } catch (err) {
                    console.error('[MetricsLogger] Error getting session summary:', err);
                    return null;
                }
            },
            
            /**
             * Query historical metrics
             */
            queryMetrics: async function(options = {}) {
                try {
                    const params = new URLSearchParams();
                    if (options.module) params.append('module', options.module);
                    if (options.metric_name) params.append('metric_name', options.metric_name);
                    if (options.start_time) params.append('start_time', options.start_time);
                    if (options.end_time) params.append('end_time', options.end_time);
                    if (options.limit) params.append('limit', options.limit);
                    
                    const response = await fetch(`/api/metrics/query?${params}`);
                    return await response.json();
                } catch (err) {
                    console.error('[MetricsLogger] Error querying metrics:', err);
                    return null;
                }
            }
        };
        
        // Initialize and expose globally
        window.metricsLogger = MetricsLogger.initialize();
        
        // Helper function for easy logging from anywhere
        window.logMetric = function(module, name, value, meta) {
            MetricsLogger.log(module, name, value, meta);
        };
        
        // Helper function for interaction logging
        window.logInteraction = function(action, target, details) {
            MetricsLogger.logInteraction(action, target, details);
        };

        // Integration with RF SCYTHE system 
        // Function to connect Gemini API for network traffic analysis
        async function analyzeNetworkWithGemini(signalData) {
            try {
                const response = await fetch('/api/classify-signal', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        type: "classify",
                        signal: signalData
                    })
                });
                
                if (!response.ok) {
                    throw new Error(`Server responded with ${response.status}`);
                }
                
                const result = await response.json();
                if (result.success && result.classification) {
                    // Add a console message
                    addConsoleMessage(`Signal classified as ${result.classification.modulation} with ${(result.classification.confidence*100).toFixed(1)}% confidence`);
                    
                    // If it's a potential network communication
                    if (['FSK', 'PSK', 'QAM'].includes(result.classification.modulation)) {
                        // Show a notification
                        showNotification(
                            'Network Communication Detected', 
                            `Detected ${result.classification.modulation} signal with characteristics of network traffic. Potential source: ${result.classification.source_types[0] || 'Unknown'}`,
                            'info'
                        );
                        
                        // Add a sensor ping at the signal location
                        if (signalData.lat && signalData.lon) {
                            addSensorPing(
                                signalData.lat, 
                                signalData.lon, 
                                result.classification.confidence > 0.7 ? 'cyan' : 'yellow',
                                result.classification.confidence * 2, 
                                3
                            );
                        }
                    }
                    return result.classification;
                }
                return null;
            } catch (error) {
                console.error("Error analyzing network with Gemini:", error);
                return null;
            }
        }
        
        // Function to show a notification
        function showNotification(title, message, type = 'info') {
            // Get or create the notification container
            let notificationContainer = document.getElementById('notifications-container');
            
            if (!notificationContainer) {
                // Create the container on the fly if it doesn't exist
                notificationContainer = document.createElement('div');
                notificationContainer.id = 'notifications-container';
                notificationContainer.className = 'notifications';
                document.body.appendChild(notificationContainer);
                console.log('[Notification] Created missing notifications-container');
            }
            
            const notification = document.createElement('div');
            notification.className = `notification notification-${type}`;
            
            notification.innerHTML = `
                <div class="notification-header">
                    <span class="notification-title">${title}</span>
                    <button class="notification-close">×</button>
                </div>
                <div class="notification-body">
                    ${message}
                </div>
            `;
            
            // Add close button functionality
            notification.querySelector('.notification-close').addEventListener('click', () => {
                notification.classList.add('removing');
                setTimeout(() => {
                    notification.remove();
                }, 300);
            });
            
            notificationContainer.appendChild(notification);
            
            // Auto-remove after 10 seconds
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.classList.add('removing');
                    setTimeout(() => {
                        if (notification.parentNode) {
                            notification.remove();
                        }
                    }, 300);
                }
            }, 10000);
        }
        
        // Function to add a message to the console
        function addConsoleMessage(message, type = 'response') {
            const outputEl = document.getElementById('console-output');
            if (!outputEl) {
                console.warn('[Console] Output element not found');
                return;
            }
            
            const timestamp = new Date().toLocaleTimeString('en-US', { hour12: false });
            
            const messageLine = document.createElement('div');
            messageLine.className = 'console-line';
            messageLine.innerHTML = `
                <span class="console-timestamp">[${timestamp}]</span>
                <span class="console-${type}">${message}</span>
            `;
            
            outputEl.appendChild(messageLine);
            
            // Auto-scroll to bottom with a small delay to ensure DOM update
            requestAnimationFrame(() => {
                outputEl.scrollTop = outputEl.scrollHeight;
            });
            
            // Limit console history to prevent memory bloat (keep last 500 messages)
            const maxMessages = 500;
            while (outputEl.children.length > maxMessages) {
                outputEl.removeChild(outputEl.firstChild);
            }
        }
        
        // Console command handler for enhanced nmap, nDPI, and IMM-RF-NeRF integration
        function handleConsoleCommand(command) {
            const args = command.trim().split(/\s+/);
            const cmd = args[0].toLowerCase();
            
            addConsoleMessage(`> ${command}`, 'command');
            
            switch (cmd) {
                case 'nmap':
                    handleNmapCommand(args.slice(1));
                    break;
                
                case 'ndpi':
                    handleNdpiCommand(args.slice(1));
                    break;
                
                case 'imm':
                    handleImmCommand(args.slice(1));
                    break;
                
                case 'hypergraph':
                    handleHypergraphCommand(args.slice(1));
                    break;
                
                case 'rf-nerf':
                    handleRfNerfCommand(args.slice(1));
                    break;
                
                case 'protocol':
                    handleProtocolCommand(args.slice(1));
                    break;
                
                case 'reconstruct':
                    handleReconstructCommand(args.slice(1));
                    break;
                
                case 'analyze':
                    handleAnalyzeCommand(args.slice(1));
                    break;
                
                case 'dpi':
                    handleDeepPacketInspectionCommand(args.slice(1));
                    break;
                
                case 'fingerprint':
                    handleFingerprintCommand(args.slice(1));
                    break;
                
                case 'clear':
                    const outputEl = document.getElementById('console-output');
                    if (outputEl) outputEl.innerHTML = '';
                    break;
                
                case 'help':
                    showConsoleHelp();
                    break;
                
                case 'status':
                    showSystemStatus();
                    break;
                
                default:
                    addConsoleMessage(`Unknown command: ${cmd}. Type 'help' for available commands.`, 'alert');
                    break;
            }
        }
        
        // Show system status
        function showSystemStatus() {
            addConsoleMessage('=== RF SCYTHE Enhanced System Status ===', 'response');
            addConsoleMessage('', 'response');
            addConsoleMessage('CORE SYSTEMS:', 'response');
            addConsoleMessage(`  • Hypergraph Visualizer: ${hypergraphVisualizer ? 'ACTIVE' : 'INACTIVE'}`, 'response');
            addConsoleMessage(`  • Cesium Globe: ${viewer ? 'ACTIVE' : 'INACTIVE'}`, 'response');
            addConsoleMessage(`  • Network Infrastructure: ${window.networkInfra ? 'ACTIVE' : 'INACTIVE'}`, 'response');
            addConsoleMessage(`  • RF Tracking: ${window.rfTracking ? 'ACTIVE' : 'INACTIVE'}`, 'response');
            addConsoleMessage('', 'response');
            
            addConsoleMessage('AVAILABLE MODULES:', 'response');
            addConsoleMessage('  • nmap-master: Enhanced network discovery and security auditing', 'response');
            addConsoleMessage('    - Full NSE script library for service enumeration', 'response');
            addConsoleMessage('    - Advanced OS fingerprinting and version detection', 'response');
            addConsoleMessage('    - Vulnerability scanning and assessment', 'response');
            addConsoleMessage('', 'response');
            
            addConsoleMessage('  • nDPI: Deep packet inspection and protocol analysis', 'response');
            addConsoleMessage('    - Real-time protocol classification', 'response');
            addConsoleMessage('    - Application-layer traffic analysis', 'response');
            addConsoleMessage('    - Malware detection and DGA analysis', 'response');
            addConsoleMessage('', 'response');
            
            addConsoleMessage('  • IMM-RF-NeRF: Inductive Moment Matching for RF visualization', 'response');
            addConsoleMessage('    - Advanced RF signal modeling and prediction', 'response');
            addConsoleMessage('    - Neural radiance field visualization', 'response');
            addConsoleMessage('    - Cross-domain influence analysis (JWST/LHC integration)', 'response');
            addConsoleMessage('', 'response');
            
            addConsoleMessage('  • Hypergraph RF Network Reconstruction', 'response');
            addConsoleMessage('    - Network topology inference from RF signals', 'response');
            addConsoleMessage('    - Data flow reconstruction and analysis', 'response');
            addConsoleMessage('    - Combined RF-network correlation mapping', 'response');
            addConsoleMessage('', 'response');
            
            addConsoleMessage('ACTIVE DATA SOURCES:', 'response');
            addConsoleMessage(`  • RF Signal Data: ${signalPaths ? signalPaths.length : 0} active signals`, 'response');
            addConsoleMessage(`  • Network Entities: ${viewer ? viewer.entities.values.length : 0} entities tracked`, 'response');
            addConsoleMessage(`  • Scan History: ${getNmapScanHistory().length} previous scans`, 'response');
            addConsoleMessage(`  • Protocol Sessions: ${Math.floor(Math.random() * 50 + 10)} active sessions`, 'response');
            addConsoleMessage('', 'response');
            
            addConsoleMessage('ANALYSIS CAPABILITIES:', 'response');
            addConsoleMessage('  ✓ Real-time network discovery and enumeration', 'response');
            addConsoleMessage('  ✓ Deep packet inspection and protocol classification', 'response');
            addConsoleMessage('  ✓ RF signal correlation with network topology', 'response');
            addConsoleMessage('  ✓ Advanced vulnerability assessment and reporting', 'response');
            addConsoleMessage('  ✓ Machine learning-based anomaly detection', 'response');
            addConsoleMessage('  ✓ Cross-domain influence analysis and visualization', 'response');
            addConsoleMessage('', 'response');
            
            const memoryUsage = (Math.random() * 800 + 200).toFixed(1);
            const cpuUsage = (Math.random() * 30 + 10).toFixed(1);
            
            addConsoleMessage('PERFORMANCE METRICS:', 'response');
            addConsoleMessage(`  • Memory Usage: ${memoryUsage} MB`, 'info');
            addConsoleMessage(`  • CPU Usage: ${cpuUsage}%`, 'info');
            addConsoleMessage(`  • Visualization FPS: ${Math.floor(Math.random() * 20 + 40)}`, 'info');
            addConsoleMessage(`  • Network Latency: ${Math.floor(Math.random() * 50 + 10)}ms`, 'info');
            addConsoleMessage('', 'response');
            
            showNotification('System Status', 'All enhanced modules operational and ready', 'success');
        }
        
        // Handle nmap commands with enhanced capabilities
        function handleNmapCommand(args) {
            if (args.length === 0) {
                addConsoleMessage('Enhanced Nmap Commands:', 'response');
                addConsoleMessage('  nmap <target> [options]     - Network discovery and security auditing', 'response');
                addConsoleMessage('  nmap --script-scan <target> - Run NSE scripts for service enumeration', 'response');
                addConsoleMessage('  nmap --os-fingerprint <target> - Advanced OS detection and fingerprinting', 'response');
                addConsoleMessage('  nmap --vuln-scan <target>   - Vulnerability detection and assessment', 'response');
                addConsoleMessage('  nmap --rf-correlation       - Enable RF signal correlation analysis', 'response');
                addConsoleMessage('Example: nmap 192.168.1.0/24 -sS -sV --script-scan --rf-correlation', 'response');
                return;
            }
            
            const target = args[0];
            const options = {
                scriptScan: args.includes('--script-scan'),
                osFingerprint: args.includes('--os-fingerprint'),
                vulnScan: args.includes('--vuln-scan'),
                rfCorrelation: args.includes('--rf-correlation'),
                hypergraphMode: args.includes('--hypergraph')
            };
            
            // Parse standard nmap options
            for (let i = 1; i < args.length; i++) {
                const arg = args[i];
                switch (arg) {
                    case '-sS': options.scanType = 'SYN'; break;
                    case '-sT': options.scanType = 'TCP_CONNECT'; break;
                    case '-sU': options.scanType = 'UDP'; break;
                    case '-sF': options.scanType = 'FIN'; break;
                    case '-sX': options.scanType = 'XMAS'; break;
                    case '-sN': options.scanType = 'NULL'; break;
                    case '-sA': options.scanType = 'ACK'; break;
                    case '-sW': options.scanType = 'WINDOW'; break;
                    case '-sM': options.scanType = 'MAIMON'; break;
                    case '-sV': options.serviceDetection = true; break;
                    case '-O': options.osDetection = true; break;
                    case '-A': 
                        options.serviceDetection = true;
                        options.osDetection = true;
                        options.scriptScan = true;
                        options.traceroute = true;
                        break;
                    case '-f': options.fragment = true; break;
                    case '-D': options.decoy = args[i + 1]; i++; break;
                    case '-S': options.spoofSource = args[i + 1]; i++; break;
                    case '--source-port': options.sourcePort = args[i + 1]; i++; break;
                    case '-v': options.verbose = true; break;
                    case '-vv': options.verbose = 'high'; break;
                    case '-T1': case '-T2': case '-T3': case '-T4': case '-T5':
                        options.timing = arg.substring(1);
                        break;
                    case '-p': options.ports = args[i + 1]; i++; break;
                    case '--top-ports': options.topPorts = args[i + 1]; i++; break;
                    case '--exclude-ports': options.excludePorts = args[i + 1]; i++; break;
                    case '--max-hostgroup': options.maxHostgroup = args[i + 1]; i++; break;
                    case '--min-hostgroup': options.minHostgroup = args[i + 1]; i++; break;
                    case '--max-parallelism': options.maxParallelism = args[i + 1]; i++; break;
                    case '--max-rtt-timeout': options.maxRttTimeout = args[i + 1]; i++; break;
                    case '--initial-rtt-timeout': options.initialRttTimeout = args[i + 1]; i++; break;
                    case '--max-retries': options.maxRetries = args[i + 1]; i++; break;
                    case '--host-timeout': options.hostTimeout = args[i + 1]; i++; break;
                    case '--scan-delay': options.scanDelay = args[i + 1]; i++; break;
                    case '--max-scan-delay': options.maxScanDelay = args[i + 1]; i++; break;
                }
            }
            
            // Switch to hypergraph panel if hypergraph mode is enabled
            if (options.hypergraphMode) {
                showPanel('hypergraph');
            }
            
            // Set target in the UI
            const targetInput = document.getElementById('nmap-target-network');
            if (targetInput) targetInput.value = target;
            
            // Start enhanced nmap scan
            addConsoleMessage(`Starting enhanced nmap scan on ${target}...`, 'response');
            if (options.scriptScan) addConsoleMessage('  • NSE script scanning enabled', 'response');
            if (options.osFingerprint) addConsoleMessage('  • Advanced OS fingerprinting enabled', 'response');
            if (options.vulnScan) addConsoleMessage('  • Vulnerability scanning enabled', 'response');
            if (options.rfCorrelation) addConsoleMessage('  • RF signal correlation enabled', 'response');
            
            performEnhancedNmapScan(target, options);
        }
        
        // Handle nDPI deep packet inspection commands
        function handleNdpiCommand(args) {
            if (args.length === 0) {
                addConsoleMessage('nDPI Protocol Analysis Commands:', 'response');
                addConsoleMessage('  ndpi analyze <target>       - Deep packet inspection and protocol analysis', 'response');
                addConsoleMessage('  ndpi classify <pcap_file>   - Classify protocols from PCAP file', 'response');
                addConsoleMessage('  ndpi detect <interface>     - Real-time protocol detection on interface', 'response');
                addConsoleMessage('  ndpi flows <target>         - Analyze network flows and protocol statistics', 'response');
                addConsoleMessage('  ndpi apps <target>          - Identify applications and services', 'response');
                addConsoleMessage('  ndpi dga <domain>          - Domain Generation Algorithm detection', 'response');
                addConsoleMessage('  ndpi malware <target>      - Malware traffic detection and analysis', 'response');
                addConsoleMessage('Example: ndpi analyze 192.168.1.0/24 --hypergraph --rf-correlation', 'response');
                return;
            }
            
            const action = args[0].toLowerCase();
            const target = args[1];
            const options = {
                hypergraph: args.includes('--hypergraph'),
                rfCorrelation: args.includes('--rf-correlation'),
                realtime: args.includes('--realtime'),
                verbose: args.includes('-v'),
                output: args.includes('--output') ? args[args.indexOf('--output') + 1] : null
            };
            
            switch (action) {
                case 'analyze':
                    performNdpiAnalysis(target, options);
                    break;
                case 'classify':
                    performNdpiClassification(target, options);
                    break;
                case 'detect':
                    performNdpiDetection(target, options);
                    break;
                case 'flows':
                    performNdpiFlowAnalysis(target, options);
                    break;
                case 'apps':
                    performNdpiApplicationAnalysis(target, options);
                    break;
                case 'dga':
                    performNdpiDgaDetection(target, options);
                    break;
                case 'malware':
                    performNdpiMalwareDetection(target, options);
                    break;
                default:
                    addConsoleMessage(`Unknown nDPI action: ${action}`, 'alert');
                    break;
            }
        }
        
        // Handle IMM-RF-NeRF commands
        function handleImmCommand(args) {
            if (args.length === 0) {
                addConsoleMessage('IMM-RF-NeRF Integration Commands:', 'response');
                addConsoleMessage('  imm train <dataset>         - Train IMM model with RF data', 'response');
                addConsoleMessage('  imm generate <rf_features>  - Generate RF visualization data', 'response');
                addConsoleMessage('  imm visualize <config>      - Create NeRF visualization', 'response');
                addConsoleMessage('  imm load <model_path>       - Load pre-trained IMM model', 'response');
                addConsoleMessage('  imm save <model_path>       - Save current IMM model', 'response');
                addConsoleMessage('  imm encode <rf_signal>      - Encode RF signal to latent space', 'response');
                addConsoleMessage('  imm decode <latent_vector>  - Decode latent vector to RF features', 'response');
                addConsoleMessage('  imm cross-domain <sources>  - Cross-domain influence analysis', 'response');
                addConsoleMessage('Example: imm visualize --resolution 64x64x64 --rf-features current', 'response');
                return;
            }
            
            const action = args[0].toLowerCase();
            const target = args[1];
            const options = {
                resolution: args.includes('--resolution') ? args[args.indexOf('--resolution') + 1] : '32x32x32',
                epochs: args.includes('--epochs') ? parseInt(args[args.indexOf('--epochs') + 1]) : 50,
                batchSize: args.includes('--batch-size') ? parseInt(args[args.indexOf('--batch-size') + 1]) : 32,
                learningRate: args.includes('--lr') ? parseFloat(args[args.indexOf('--lr') + 1]) : 0.0001,
                rfFeatures: args.includes('--rf-features') ? args[args.indexOf('--rf-features') + 1] : 'current',
                cuda: args.includes('--cuda'),
                crossDomain: args.includes('--cross-domain'),
                lhc: args.includes('--lhc'),
                jwst: args.includes('--jwst')
            };
            
            switch (action) {
                case 'train':
                    performImmTraining(target, options);
                    break;
                case 'generate':
                    performImmGeneration(target, options);
                    break;
                case 'visualize':
                    performImmVisualization(target, options);
                    break;
                case 'load':
                    performImmModelLoad(target, options);
                    break;
                case 'save':
                    performImmModelSave(target, options);
                    break;
                case 'encode':
                    performImmEncode(target, options);
                    break;
                case 'decode':
                    performImmDecode(target, options);
                    break;
                case 'cross-domain':
                    performImmCrossDomainAnalysis(target, options);
                    break;
                default:
                    addConsoleMessage(`Unknown IMM action: ${action}`, 'alert');
                    break;
            }
        }
        
        // Handle RF-NeRF commands
        function handleRfNerfCommand(args) {
            if (args.length === 0) {
                addConsoleMessage('RF-NeRF Visualization Commands:', 'response');
                addConsoleMessage('  rf-nerf render <config>     - Render RF field visualization', 'response');
                addConsoleMessage('  rf-nerf volume <data>       - Create volumetric RF representation', 'response');
                addConsoleMessage('  rf-nerf raycast <params>    - Perform RF ray casting', 'response');
                addConsoleMessage('  rf-nerf optimize <scene>    - Optimize NeRF scene parameters', 'response');
                addConsoleMessage('  rf-nerf export <format>     - Export visualization data', 'response');
                addConsoleMessage('Example: rf-nerf render --quality high --rf-bands all', 'response');
                return;
            }
            
            const action = args[0].toLowerCase();
            const target = args[1];
            const options = {
                quality: args.includes('--quality') ? args[args.indexOf('--quality') + 1] : 'medium',
                rfBands: args.includes('--rf-bands') ? args[args.indexOf('--rf-bands') + 1] : 'current',
                resolution: args.includes('--resolution') ? args[args.indexOf('--resolution') + 1] : 512,
                samples: args.includes('--samples') ? parseInt(args[args.indexOf('--samples') + 1]) : 64,
                format: args.includes('--format') ? args[args.indexOf('--format') + 1] : 'webgl'
            };
            
            performRfNerfOperation(action, target, options);
        }
        
        // Handle protocol analysis commands
        function handleProtocolCommand(args) {
            if (args.length === 0) {
                addConsoleMessage('Protocol Analysis Commands:', 'response');
                addConsoleMessage('  protocol identify <packet>  - Identify network protocol', 'response');
                addConsoleMessage('  protocol decode <data>      - Decode protocol headers', 'response');
                addConsoleMessage('  protocol stats <interface>  - Protocol usage statistics', 'response');
                addConsoleMessage('  protocol flows <capture>    - Analyze protocol flows', 'response');
                return;
            }
            
            const action = args[0].toLowerCase();
            const target = args[1];
            
            performProtocolAnalysis(action, target, args.slice(2));
        }
        
        // Handle network reconstruction commands
        function handleReconstructCommand(args) {
            if (args.length === 0) {
                addConsoleMessage('Hypergraph Network Reconstruction Commands:', 'response');
                addConsoleMessage('  reconstruct topology <data> - Reconstruct network topology', 'response');
                addConsoleMessage('  reconstruct flows <capture> - Reconstruct data flows', 'response');
                addConsoleMessage('  reconstruct rf <signals>    - Reconstruct RF propagation paths', 'response');
                addConsoleMessage('  reconstruct combined <all>  - Combined network+RF reconstruction', 'response');
                return;
            }
            
            const type = args[0].toLowerCase();
            const source = args[1];
            
            performHypergraphReconstruction(type, source, args.slice(2));
        }
        
        // Handle analysis commands
        function handleAnalyzeCommand(args) {
            if (args.length === 0) {
                addConsoleMessage('Analysis Commands:', 'response');
                addConsoleMessage('  analyze traffic <source>    - Traffic pattern analysis', 'response');
                addConsoleMessage('  analyze anomaly <data>      - Anomaly detection', 'response');
                addConsoleMessage('  analyze correlation <sets>  - Cross-correlation analysis', 'response');
                addConsoleMessage('  analyze security <target>   - Security vulnerability analysis', 'response');
                return;
            }
            
            const type = args[0].toLowerCase();
            const target = args[1];
            
            performAdvancedAnalysis(type, target, args.slice(2));
        }
        
        // Handle deep packet inspection commands
        function handleDeepPacketInspectionCommand(args) {
            if (args.length === 0) {
                addConsoleMessage('Deep Packet Inspection Commands:', 'response');
                addConsoleMessage('  dpi scan <interface>        - Real-time DPI scanning', 'response');
                addConsoleMessage('  dpi analyze <pcap>          - Analyze PCAP file with DPI', 'response');
                addConsoleMessage('  dpi classify <packets>      - Classify packet types', 'response');
                addConsoleMessage('  dpi extract <features>      - Extract packet features', 'response');
                return;
            }
            
            const action = args[0].toLowerCase();
            const target = args[1];
            
            performDeepPacketInspection(action, target, args.slice(2));
        }
        
        // Handle fingerprinting commands
        function handleFingerprintCommand(args) {
            if (args.length === 0) {
                addConsoleMessage('Fingerprinting Commands:', 'response');
                addConsoleMessage('  fingerprint os <target>     - Operating system fingerprinting', 'response');
                addConsoleMessage('  fingerprint service <port>  - Service fingerprinting', 'response');
                addConsoleMessage('  fingerprint device <mac>    - Device fingerprinting', 'response');
                addConsoleMessage('  fingerprint rf <signal>     - RF device fingerprinting', 'response');
                return;
            }
            
            const type = args[0].toLowerCase();
            const target = args[1];
            
            performFingerprinting(type, target, args.slice(2));
        }
        
        // Handle hypergraph commands
        function handleHypergraphCommand(args) {
            if (args.length === 0) {
                addConsoleMessage('Usage: hypergraph <action> [options]', 'response');
                addConsoleMessage('Actions: status, show, hide, test, reset, generate, clear', 'response');
                return;
            }
            
            const action = args[0].toLowerCase();
            
            switch (action) {
                case 'status':
                    const overlayCheckbox = document.getElementById('showHypergraphOverlay');
                    const isVisible = overlayCheckbox ? overlayCheckbox.checked : false;
                    addConsoleMessage(`Hypergraph overlay: ${isVisible ? 'enabled' : 'disabled'}`, 'response');
                    
                    // Show current metrics
                    updateHypergraphMetrics();
                    break;
                
                case 'show':
                    const showOverlay = document.getElementById('showHypergraphOverlay');
                    if (showOverlay) {
                        showOverlay.checked = true;
                        showOverlay.dispatchEvent(new Event('change'));
                        addConsoleMessage('Hypergraph overlay enabled', 'response');
                    }
                    break;
                
                case 'hide':
                    const hideOverlay = document.getElementById('showHypergraphOverlay');
                    if (hideOverlay) {
                        hideOverlay.checked = false;
                        hideOverlay.dispatchEvent(new Event('change'));
                        addConsoleMessage('Hypergraph overlay disabled', 'response');
                    }
                    break;
                
                case 'test':
                case 'generate':
                    generateTestHypergraphData();
                    break;
                
                case 'reset':
                    resetHypergraphSession();
                    break;
                
                case 'clear':
                    if (hypergraphVisualizer) {
                        hypergraphVisualizer.clearHypergraph();
                        addConsoleMessage('Cleared hypergraph visualization', 'response');
                    }
                    break;
                
                case 'collect':
                    const collectOverlay = document.getElementById('showHypergraphOverlay');
                    if (collectOverlay) {
                        collectOverlay.checked = true;
                        collectOverlay.dispatchEvent(new Event('change'));
                        addConsoleMessage('Started hypergraph collection and visualization', 'response');
                    }
                    break;
                
                case 'stop':
                    const stopOverlay = document.getElementById('showHypergraphOverlay');
                    if (stopOverlay) {
                        stopOverlay.checked = false;
                        stopOverlay.dispatchEvent(new Event('change'));
                        addConsoleMessage('Stopped hypergraph collection', 'response');
                    }
                    break;
                
                case 'filter':
                    if (args.length >= 3) {
                        const filterType = args[1].toLowerCase();
                        const value = parseFloat(args[2]);
                        
                        if (filterType === 'cardinality') {
                            const cardFilter = document.getElementById('hypergraphCardinalityFilter');
                            if (cardFilter) {
                                cardFilter.value = Math.min(5, Math.max(1, value));
                                cardFilter.dispatchEvent(new Event('input'));
                                addConsoleMessage(`Set cardinality filter to ${cardFilter.value}`, 'response');
                            }
                        } else if (filterType === 'strength') {
                            const strFilter = document.getElementById('hypergraphStrengthFilter');
                            if (strFilter) {
                                strFilter.value = Math.min(-30, Math.max(-120, value));
                                strFilter.dispatchEvent(new Event('input'));
                                addConsoleMessage(`Set signal strength filter to ${strFilter.value} dBm`, 'response');
                            }
                        } else {
                            addConsoleMessage('Usage: hypergraph filter <cardinality|strength> <value>', 'alert');
                        }
                    } else {
                        addConsoleMessage('Usage: hypergraph filter <cardinality|strength> <value>', 'alert');
                    }
                    break;
                
                default:
                    addConsoleMessage(`Unknown hypergraph action: ${action}`, 'alert');
                    addConsoleMessage('Available actions: status, show, hide, test, reset, generate, clear, collect, stop, filter', 'response');
                    break;
            }
        }
        
        // Show console help
        function showConsoleHelp() {
            addConsoleMessage('=== RF SCYTHE Enhanced Command Console v1.3.0 ===', 'response');
            addConsoleMessage('', 'response');
            
            addConsoleMessage('NETWORK RECONNAISSANCE:', 'response');
            addConsoleMessage('  nmap <target> [options]     - Enhanced network scanning with hypergraph integration', 'response');
            addConsoleMessage('    Options: -sS, -sT, -sU, -sV, -O, -A, --script-scan, --vuln-scan', 'response');
            addConsoleMessage('             --rf-correlation, --hypergraph, -T1-T5, -p <ports>', 'response');
            addConsoleMessage('    Example: nmap 192.168.1.0/24 -sS -sV --vuln-scan --rf-correlation', 'response');
            addConsoleMessage('    Example: nmap scanme.nmap.org -A --hypergraph', 'response');
            addConsoleMessage('', 'response');
            
            addConsoleMessage('DEEP PACKET INSPECTION (nDPI):', 'response');
            addConsoleMessage('  ndpi <action> [interface] [options] - nDPI protocol analysis', 'response');
            addConsoleMessage('    Actions: analyze, status, flows, protocols', 'response');
            addConsoleMessage('    Options: --duration <sec>, --hypergraph, --realtime', 'response');
            addConsoleMessage('    Example: ndpi analyze eth1 --duration 10', 'response');
            addConsoleMessage('    Example: ndpi status', 'response');
            addConsoleMessage('', 'response');
            
            addConsoleMessage('AUTO-RECONNAISSANCE SYSTEM:', 'response');
            addConsoleMessage('  recon <action> [params]     - Automated reconnaissance and entity tracking', 'response');
            addConsoleMessage('    Actions: status, entities, alerts, search, subscribe', 'response');
            addConsoleMessage('    Example: recon status', 'response');
            addConsoleMessage('    Example: recon entities --type drone', 'response');
            addConsoleMessage('    Example: recon search --bbox 37.7,-122.5,37.8,-122.4', 'response');
            addConsoleMessage('    Example: recon alerts --active', 'response');
            addConsoleMessage('', 'response');
            
            addConsoleMessage('AIS VESSEL TRACKING:', 'response');
            addConsoleMessage('  ais <action> [params]       - AIS maritime vessel tracking', 'response');
            addConsoleMessage('    Actions: vessels, track, history, status', 'response');
            addConsoleMessage('    Example: ais vessels', 'response');
            addConsoleMessage('    Example: ais track 123456789', 'response');
            addConsoleMessage('    Example: ais history --mmsi 123456789 --hours 24', 'response');
            addConsoleMessage('', 'response');
            
            addConsoleMessage('POINTS OF INTEREST (POI):', 'response');
            addConsoleMessage('  poi <action> [params]       - Manage points of interest', 'response');
            addConsoleMessage('    Actions: list, add, remove, nearby, status', 'response');
            addConsoleMessage('    Example: poi list', 'response');
            addConsoleMessage('    Example: poi add --name "Site A" --lat 37.7 --lon -122.4 --type surveillance', 'response');
            addConsoleMessage('    Example: poi nearby --radius 1000', 'response');
            addConsoleMessage('', 'response');
            
            addConsoleMessage('ROOM/CHANNEL MANAGEMENT:', 'response');
            addConsoleMessage('  room <action> [params]      - Multi-user room management (WebSocket)', 'response');
            addConsoleMessage('    Actions: list, create, join, leave, message, publish', 'response');
            addConsoleMessage('    Types: global, mission, team, geographic, custom', 'response');
            addConsoleMessage('    Example: room list', 'response');
            addConsoleMessage('    Example: room create --name "Op Alpha" --type mission', 'response');
            addConsoleMessage('    Example: room join <room_id>', 'response');
            addConsoleMessage('    Example: room message "Intel update: Target acquired"', 'response');
            addConsoleMessage('', 'response');
            
            addConsoleMessage('OPERATOR SESSION MANAGEMENT:', 'response');
            addConsoleMessage('  operator <action> [params]  - Operator authentication & sessions', 'response');
            addConsoleMessage('    Actions: login, logout, status, active, register', 'response');
            addConsoleMessage('    Example: operator login --callsign ALPHA-1 --password ****', 'response');
            addConsoleMessage('    Example: operator active', 'response');
            addConsoleMessage('    Example: operator status', 'response');
            addConsoleMessage('', 'response');
            
            addConsoleMessage('ADVANCED RF VISUALIZATION:', 'response');
            addConsoleMessage('  imm <action> <params>       - IMM-RF-NeRF integration and visualization', 'response');
            addConsoleMessage('    Actions: train, generate, visualize, load, save, encode, decode', 'response');
            addConsoleMessage('    Example: imm visualize --resolution 64x64x64 --rf-features current', 'response');
            addConsoleMessage('', 'response');
            
            addConsoleMessage('  rf-nerf <action> <target>   - RF field NeRF rendering and optimization', 'response');
            addConsoleMessage('    Actions: render, volume, raycast, optimize, export', 'response');
            addConsoleMessage('    Example: rf-nerf render --quality high --rf-bands all', 'response');
            addConsoleMessage('', 'response');
            
            addConsoleMessage('PROTOCOL & TRAFFIC ANALYSIS:', 'response');
            addConsoleMessage('  protocol <action> <target>  - Network protocol identification and analysis', 'response');
            addConsoleMessage('  analyze <type> <target>     - Traffic, anomaly, correlation, security analysis', 'response');
            addConsoleMessage('  dpi <action> <target>       - Deep packet inspection operations', 'response');
            addConsoleMessage('', 'response');
            
            addConsoleMessage('NETWORK RECONSTRUCTION:', 'response');
            addConsoleMessage('  reconstruct <type> <source> - Hypergraph network reconstruction', 'response');
            addConsoleMessage('    Types: topology, flows, rf, combined', 'response');
            addConsoleMessage('    Example: reconstruct combined --rf-correlation --topology-analysis', 'response');
            addConsoleMessage('', 'response');
            
            addConsoleMessage('FINGERPRINTING & IDENTIFICATION:', 'response');
            addConsoleMessage('  fingerprint <type> <target> - OS, service, device, and RF fingerprinting', 'response');
            addConsoleMessage('    Types: os, service, device, rf', 'response');
            addConsoleMessage('', 'response');
            
            addConsoleMessage('HYPERGRAPH CONTROL:', 'response');
            addConsoleMessage('  hypergraph <action>         - Control hypergraph visualization', 'response');
            addConsoleMessage('    Actions: generate, clear, reset, collect, stop', 'response');
            addConsoleMessage('', 'response');
            
            addConsoleMessage('SYSTEM COMMANDS:', 'response');
            addConsoleMessage('  status                      - Show full system status and active modules', 'response');
            addConsoleMessage('  clear                       - Clear console output', 'response');
            addConsoleMessage('  help                        - Show this enhanced help message', 'response');
            addConsoleMessage('  version                     - Show server version info', 'response');
            addConsoleMessage('', 'response');
            
            addConsoleMessage('INTEGRATION FEATURES:', 'response');
            addConsoleMessage('• nmap integration with NSE scripts and vulnerability detection', 'response');
            addConsoleMessage('• nDPI v5.0 deep packet inspection with live traffic analysis', 'response');
            addConsoleMessage('• Auto-Recon system with spatial indexing and entity tracking', 'response');
            addConsoleMessage('• AIS vessel tracking with historical playback', 'response');
            addConsoleMessage('• POI management with geofencing alerts', 'response');
            addConsoleMessage('• Multi-user rooms with WebSocket real-time sync', 'response');
            addConsoleMessage('• Operator session management with SSE entity streaming', 'response');
            addConsoleMessage('• IMM-RF-NeRF for advanced RF signal visualization', 'response');
            addConsoleMessage('• Hypergraph network reconstruction from captured data', 'response');
            addConsoleMessage('• Cross-domain influence analysis (JWST, LHC integration)', 'response');
            addConsoleMessage('', 'response');
            
            addConsoleMessage('API ENDPOINTS (REST):', 'response');
            addConsoleMessage('  /api/status                 - System status', 'response');
            addConsoleMessage('  /api/nmap/*                 - Network scanning', 'response');
            addConsoleMessage('  /api/ndpi/*                 - Deep packet inspection', 'response');
            addConsoleMessage('  /api/recon/*                - Auto-reconnaissance', 'response');
            addConsoleMessage('  /api/ais/*                  - AIS vessel tracking', 'response');
            addConsoleMessage('  /api/poi/*                  - Points of interest', 'response');
            addConsoleMessage('  /api/rooms/*                - Room management', 'response');
            addConsoleMessage('  /api/operator/*             - Operator sessions', 'response');
            addConsoleMessage('  /api/rf-hypergraph/*        - Hypergraph visualization', 'response');
            addConsoleMessage('', 'response');
            addConsoleMessage('For detailed command options, run any command without parameters.', 'info');
        }
        
        // Initialize console input handling
        document.addEventListener('DOMContentLoaded', function() {
            const consoleInput = document.getElementById('console-input');
            if (consoleInput) {
                consoleInput.addEventListener('keypress', function(e) {
                    if (e.key === 'Enter') {
                        const command = this.value.trim();
                        if (command) {
                            handleConsoleCommand(command);
                            this.value = '';
                        }
                    }
                });
                
                // Add placeholder with nmap example
                consoleInput.placeholder = 'Type command... (e.g., "nmap 192.168.1.0/24 -sS")';
            }
        });
        
        // RF signal detection integration with network visualization concepts
        function detectNetworkTraffic(signal) {
            // Sample usage
            analyzeNetworkWithGemini(signal).then(classification => {
                if (classification) {
                    // Log if it's detected as network traffic
                    if (classification.confidence > 0.6 && 
                        classification.source_types.some(source => 
                            source.toLowerCase().includes('network') ||
                            source.toLowerCase().includes('wifi') ||
                            source.toLowerCase().includes('router'))) {
                        
                        addConsoleMessage(`Network traffic detected: ${classification.source_types.join(', ')}`, 'alert');
                    }
                }
            });
        }
        
        // Example of how to call this function with real signal data
        // detectNetworkTraffic({
        //    freqs: [915e6, 915.1e6, 915.2e6],
        //    amplitudes: [-60, -30, -70],
        //    lat: 37.7749,
        //    lon: -122.4194
        // });

        // Debugging initialization of the sidebar or panel
        console.log('Initializing Command Ops Visualization...');
        const sidebar = document.getElementById('command-sidebar-right');
        if (!sidebar) {
            console.error('Sidebar element not found!');
        } else {
            console.log('Sidebar element found:', sidebar);
        }
        
        // Initialize Spectrogram and Signal Classification Components from signal-classifier.html
        function initializeSpectrogram() {
            // Set up Gemini API indicator
            const geminiIndicator = document.getElementById('gemini-indicator');
            const geminiStatus = document.getElementById('gemini-status');
            
            // Simulate API connection after 2 seconds
            setTimeout(() => {
                geminiIndicator.classList.remove('status-inactive');
                geminiIndicator.classList.add('status-active');
                geminiStatus.textContent = 'ACTIVE';
                showNotification('Gemini API Connected', 'Neural signal classification is now available for enhanced RF analysis.', 'info');
            }, 2000);
            
            // Set up spectrogram control buttons
            const spectrogramContainer = document.getElementById('spectrogramContainer');
            const scanSpectrumBtn = document.getElementById('scanSpectrumBtn');
            const classifyAllBtn = document.getElementById('classifyAllBtn');
            const playBtn = document.getElementById('playBtn');
            const zoomToSelectionBtn = document.getElementById('zoomToSelectionBtn');
            const resetZoomBtn = document.getElementById('resetZoomBtn');
            const zoomInBtn = document.getElementById('zoomInBtn');
            const zoomOutBtn = document.getElementById('zoomOutBtn');
            
            // Add event listeners for spectrogram controls
            if (scanSpectrumBtn) {
                scanSpectrumBtn.addEventListener('click', () => {
                    spectrogramContainer.style.display = 'block';
                    showNotification('Spectrum Scan', 'Starting RF spectrum scan. Visualizing signal environment.', 'info');
                    
                    // Add console message
                    addConsoleMessage('Starting RF spectrum scan...', 'command');
                    setTimeout(() => {
                        addConsoleMessage('SDR tuned to 100-1000 MHz range', 'response');
                        initializeSpectrogram();
                    }, 500);
                });
            }
            
            // Setup signal card selection
            const signalCards = document.querySelectorAll('.signal-card');
            const signalDetails = document.getElementById('signalDetails');
            
            signalCards.forEach(card => {
                card.addEventListener('click', () => {
                    // Remove selected class from all cards
                    signalCards.forEach(c => c.classList.remove('selected'));
                    
                    // Add selected class to clicked card
                    card.classList.add('selected');
                    
                    // Get signal frequency from the card
                    const frequency = card.querySelector('.list-item-title').textContent;
                    const modulation = card.querySelector('.list-item-header span:nth-child(2)').textContent;
                    
                    // Update signal details panel with AI classification info
                    if (signalDetails) {
                        signalDetails.innerHTML = `
                            <div class="feature-value">
                                <span class="feature-name">Signal:</span>
                                <span>${frequency}</span>
                            </div>
                            <div class="feature-value">
                                <span class="feature-name">Modulation:</span>
                                <span>${modulation}</span>
                            </div>
                            <div class="feature-value">
                                <span class="feature-name">AI Classification:</span>
                                <span>Amateur Radio Communication</span>
                            </div>
                            <div class="feature-value">
                                <span class="feature-name">Threat Level:</span>
                                <span style="color: #55ff55;">Low</span>
                            </div>
                            <div style="margin-top: 10px;">
                                <button class="action-button" style="background-color: #3a6fc4; font-size: 11px;">Analyze with Gemini</button>
                            </div>
                        `;
                    }
                    
                    // Show the spectrogram with the centered frequency
                    spectrogramContainer.style.display = 'block';
                    // Simulate focusing the spectrogram on this frequency
                    if (document.getElementById('currentFrequency')) {
                        document.getElementById('currentFrequency').textContent = `Freq: ${frequency}`;
                    }
                });
            });
            
            // Function to initialize the spectrogram
            function initializeSpectrogram() {
                const canvas = document.getElementById('spectrogramCanvas');
                if (!canvas) return;
                
                const ctx = canvas.getContext('2d');
                
                // Resize canvas to fit container
                canvas.width = spectrogramContainer.clientWidth;
                canvas.height = spectrogramContainer.clientHeight;
                
                // Draw mock spectrogram (just a visual representation)
                const gradient = ctx.createLinearGradient(0, 0, canvas.width, 0);
                gradient.addColorStop(0, 'rgba(0, 0, 50, 0.8)');
                gradient.addColorStop(0.5, 'rgba(50, 0, 100, 0.8)');
                gradient.addColorStop(1, 'rgba(100, 0, 50, 0.8)');
                
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Draw some random signals
                for (let i = 0; i < 20; i++) {
                    const x = Math.random() * canvas.width;
                    const height = Math.random() * 40 + 5;
                    const hue = Math.random() * 180 + 180; // Blue to purple range
                    
                    ctx.fillStyle = `hsla(${hue}, 100%, 50%, 0.7)`;
                    ctx.fillRect(x, canvas.height - height, 3, height);
                }
                
                // Add a few stronger signals
                [0.2, 0.35, 0.65, 0.8].forEach(pos => {
                    const x = pos * canvas.width;
                    const height = Math.random() * 60 + 40;
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                    ctx.fillRect(x-1, canvas.height - height, 3, height);
                });
                
                // Example detection: Add a simulated signal detection
                addConsoleMessage('Found 7 signals in spectrum scan', 'response');
                addConsoleMessage('Signal detected at 145.350 MHz (FM)', 'alert');
                
                // Simulate analyzing with Gemini
                setTimeout(() => {
                    playBtn.click();
                    addConsoleMessage('Running neural classification on detected signals...', 'command');
                }, 1000);
                
                setTimeout(() => {
                    showNotification('Signal Classification Complete', 
                        'Gemini AI has classified 7 signals with 92% average confidence.', 
                        'info');
                    addConsoleMessage('Neural classification complete', 'response');
                }, 3000);
            }
            
            // Play button functionality
            if (playBtn) {
                playBtn.addEventListener('click', function() {
                    if (this.querySelector('span').textContent === '▶ Play') {
                        this.querySelector('span').textContent = '⏸ Pause';
                        this.classList.add('active');
                        addConsoleMessage('Starting real-time signal capture', 'command');
                    } else {
                        this.querySelector('span').textContent = '▶ Play';
                        this.classList.remove('active');
                        addConsoleMessage('Pausing signal capture', 'command');
                    }
                });
            }
            
            // Add close functionality for spectrogram
            const closeSpectrogram = document.createElement('button');
            closeSpectrogram.id = 'closeSpectrogram';
            closeSpectrogram.className = 'spec-control';
            closeSpectrogram.innerHTML = '<span>✕</span>';
            closeSpectrogram.style.position = 'absolute';
            closeSpectrogram.style.right = '5px';
            closeSpectrogram.style.top = '5px';
            closeSpectrogram.title = 'Close Spectrogram';
            
            if (spectrogramContainer.querySelector('#spectrogramControls')) {
                spectrogramContainer.querySelector('#spectrogramControls').appendChild(closeSpectrogram);
            }
            
            closeSpectrogram.addEventListener('click', () => {
                spectrogramContainer.style.display = 'none';
            });
        }
        
        // Function to initialize URH Tab functionality
        function initializeURHTabFunctionality() {
            console.log("Initializing URH tab functionality");
            
            try {
                // Handle URH internal tabs
                const urhTabButtons = document.querySelectorAll('.urh-tab-button');
                if (urhTabButtons.length === 0) {
                    console.warn('No URH tab buttons found in the DOM');
                }
                
                urhTabButtons.forEach(button => {
                    button.addEventListener('click', function() {
                        console.log(`URH tab clicked: ${this.getAttribute('data-urhtab')}`);
                        
                        // Remove active class from all URH tab buttons and panels
                        urhTabButtons.forEach(btn => btn.classList.remove('active'));
                        document.querySelectorAll('.urh-tab-panel').forEach(panel => panel.classList.remove('active'));
                        
                        // Add active class to clicked button
                        this.classList.add('active');
                        
                        // Show corresponding panel
                        const tabId = this.getAttribute('data-urhtab');
                        const targetPanel = document.getElementById(`urh-${tabId}-panel`);
                        
                        if (targetPanel) {
                            targetPanel.classList.add('active');
                        } else {
                            console.error(`URH panel not found: urh-${tabId}-panel`);
                        }
                    });
                });
                
                // URH connect button
                const connectBtn = document.getElementById('urh-connect-btn');
                if (connectBtn) {
                    connectBtn.addEventListener('click', function() {
                        console.log('URH connect button clicked');
                        
                        // This will be handled by the urh-integration.js script
                        // but we'll add a fallback here
                        if (typeof RF_SCYTHE === 'undefined' || 
                            typeof RF_SCYTHE.URH === 'undefined' || 
                            typeof RF_SCYTHE.URH.connect === 'undefined') {
                            
                            console.log('Using fallback URH connection handler');
                            const statusIndicator = document.getElementById('urh-status-indicator');
                            const statusText = document.getElementById('urh-status-text');
                            
                            if (statusText.textContent === 'DISCONNECTED') {
                                if (statusIndicator) statusIndicator.className = 'status-indicator status-active';
                                if (statusText) statusText.textContent = 'CONNECTED';
                                this.textContent = 'Disconnect';
                                
                                // Enable action buttons
                                document.querySelectorAll('.urh-actions button').forEach(btn => {
                                    btn.disabled = false;
                                });
                                
                                addConsoleMessage('Connected to Universal Radio Hacker', 'response');
                            } else {
                                if (statusIndicator) statusIndicator.className = 'status-indicator status-inactive';
                                if (statusText) statusText.textContent = 'DISCONNECTED';
                                this.textContent = 'Connect';
                                
                                // Disable action buttons
                                document.querySelectorAll('.urh-actions button').forEach(btn => {
                                    btn.disabled = true;
                                });
                                
                                addConsoleMessage('Disconnected from Universal Radio Hacker', 'response');
                            }
                        } else {
                            console.log('Using URH library connect function');
                        }
                    });
                } else {
                    console.warn('URH connect button not found in the DOM');
                }
                
                // NOTE: Tab button handlers removed - navigation is now handled exclusively 
                // by the dropdown menu (setupDropdownMenu called in early DOMContentLoaded)
                
                // Debug: Check if missiles panel exists
                const missilesPanel = document.getElementById('missiles-panel');
                console.log('Missiles panel found:', missilesPanel ? 'YES' : 'NO');
                if (missilesPanel) {
                    console.log('Missiles panel classes:', missilesPanel.className);
                }
                
                // NOTE: setupDropdownMenu is now called in early DOMContentLoaded
                // No need to call it here - this was causing the menu not to load
                // if URH initialization failed
                
                // NOTE: setupDropdownMenu() has been moved to early DOMContentLoaded
                // The function below is kept for reference but is no longer called
                // since menu initialization must not depend on URH loading
            } catch (error) {
                console.error('Error setting up URH tab functionality:', error);
            }
        }
        
        // ==================== METRICS EXPLORER FUNCTIONS ====================
        
        // Metrics Explorer State
        const MetricsExplorer = {
            lastFetchTime: 0,
            refreshInterval: null,
            
            // Initialize the metrics explorer
            init: function() {
                console.log('[MetricsExplorer] Initializing...');
                
                // Set up event listeners
                const refreshBtn = document.getElementById('refresh-metrics-btn');
                if (refreshBtn) {
                    refreshBtn.addEventListener('click', () => this.fetchAllMetrics());
                }
                
                const moduleFilter = document.getElementById('metrics-filter-module');
                if (moduleFilter) {
                    moduleFilter.addEventListener('change', () => this.fetchMetrics());
                }
                
                const nameFilter = document.getElementById('metrics-filter-name');
                if (nameFilter) {
                    nameFilter.addEventListener('change', () => this.fetchMetrics());
                }
                
                const limitFilter = document.getElementById('metrics-filter-limit');
                if (limitFilter) {
                    limitFilter.addEventListener('change', () => this.fetchMetrics());
                }
                
                // Initial fetch
                this.fetchAllMetrics();
                
                // Set up auto-refresh every 30 seconds
                this.refreshInterval = setInterval(() => {
                    if (document.getElementById('metrics-panel')?.classList.contains('active')) {
                        this.fetchAllMetrics();
                    }
                }, 30000);
                
                console.log('[MetricsExplorer] Initialized successfully');
            },
            
            // Fetch all metrics data
            fetchAllMetrics: async function() {
                try {
                    // Fetch session summary
                    const sessionResponse = await fetch('/api/metrics/session');
                    if (sessionResponse.ok) {
                        const sessionData = await sessionResponse.json();
                        this.updateSessionSummary(sessionData);
                    }
                    
                    // Fetch metrics
                    await this.fetchMetrics();
                    
                    // Update live stats from current session
                    this.updateLiveStats();
                    
                } catch (error) {
                    console.error('[MetricsExplorer] Error fetching metrics:', error);
                }
            },
            
            // Update session summary display
            updateSessionSummary: function(data) {
                const duration = data.session_duration_seconds || 0;
                const durationStr = duration > 3600 
                    ? `${Math.floor(duration/3600)}h ${Math.floor((duration%3600)/60)}m`
                    : duration > 60 
                        ? `${Math.floor(duration/60)}m ${Math.floor(duration%60)}s`
                        : `${Math.floor(duration)}s`;
                
                document.getElementById('session-duration').textContent = durationStr;
                
                // Calculate totals from metrics
                const metrics = data.metrics || {};
                let totalCount = 0;
                const moduleCounts = {};
                
                for (const [key, stats] of Object.entries(metrics)) {
                    const [module, metricName] = key.split('.');
                    totalCount += stats.count || 0;
                    moduleCounts[module] = (moduleCounts[module] || 0) + (stats.count || 0);
                }
                
                document.getElementById('total-metrics-count').textContent = totalCount.toLocaleString();
                
                // Update module bars
                this.updateModuleBars(moduleCounts);
                
                // Update metric name filter options
                this.updateMetricNameOptions(metrics);
            },
            
            // Update module distribution bars
            updateModuleBars: function(moduleCounts) {
                const container = document.getElementById('module-bars');
                if (!container) return;
                
                const maxCount = Math.max(...Object.values(moduleCounts), 1);
                
                const moduleColors = {
                    recon: '#4a9eff',
                    browser: '#00d4ff',
                    ais: '#ff9800',
                    render: '#4caf50',
                    viewshed: '#9c27b0'
                };
                
                container.innerHTML = Object.entries(moduleCounts)
                    .sort((a, b) => b[1] - a[1])
                    .map(([module, count]) => {
                        const pct = (count / maxCount * 100).toFixed(0);
                        const color = moduleColors[module] || '#888';
                        return `
                            <div class="module-bar">
                                <span class="module-bar-label">${module}</span>
                                <div class="module-bar-fill">
                                    <div class="module-bar-value" style="width: ${pct}%; background: ${color};"></div>
                                </div>
                                <span class="module-bar-count">${count.toLocaleString()}</span>
                            </div>
                        `;
                    }).join('');
            },
            
            // Update metric name filter dropdown
            updateMetricNameOptions: function(metrics) {
                const select = document.getElementById('metrics-filter-name');
                if (!select) return;
                
                const currentValue = select.value;
                const metricNames = new Set();
                
                for (const key of Object.keys(metrics)) {
                    const parts = key.split('.');
                    if (parts.length > 1) {
                        metricNames.add(parts.slice(1).join('.'));
                    }
                }
                
                // Keep first option (All Metrics)
                select.innerHTML = '<option value="">All Metrics</option>';
                
                Array.from(metricNames).sort().forEach(name => {
                    const option = document.createElement('option');
                    option.value = name;
                    option.textContent = name;
                    if (name === currentValue) option.selected = true;
                    select.appendChild(option);
                });
            },
            
            // Fetch filtered metrics from API
            fetchMetrics: async function() {
                try {
                    const module = document.getElementById('metrics-filter-module')?.value || '';
                    const metricName = document.getElementById('metrics-filter-name')?.value || '';
                    const limit = document.getElementById('metrics-filter-limit')?.value || '50';
                    
                    let url = `/api/metrics/query?limit=${limit}`;
                    if (module) url += `&module=${encodeURIComponent(module)}`;
                    if (metricName) url += `&metric_name=${encodeURIComponent(metricName)}`;
                    
                    const response = await fetch(url);
                    if (response.ok) {
                        const data = await response.json();
                        this.updateMetricsTable(data.metrics || data);
                        
                        // Update total count if available
                        if (data.metrics) {
                            document.getElementById('total-metrics-count').textContent = 
                                (data.total_count || data.metrics.length).toLocaleString();
                        }
                    }
                    
                    // Also fetch interactions
                    await this.fetchInteractions();
                    
                } catch (error) {
                    console.error('[MetricsExplorer] Error fetching filtered metrics:', error);
                }
            },
            
            // Update metrics table with data
            updateMetricsTable: function(metrics) {
                const tbody = document.getElementById('metrics-table-body');
                if (!tbody) return;
                
                if (!metrics || metrics.length === 0) {
                    tbody.innerHTML = '<tr><td colspan="4" style="text-align: center; color: #888;">No metrics found</td></tr>';
                    return;
                }
                
                tbody.innerHTML = metrics.map(m => {
                    const time = new Date(m.timestamp * 1000);
                    const timeStr = time.toLocaleTimeString('en-US', { hour12: false });
                    const value = typeof m.value === 'number' 
                        ? (Number.isInteger(m.value) ? m.value : m.value.toFixed(2))
                        : m.value;
                    
                    return `
                        <tr>
                            <td class="metric-time-cell">${timeStr}</td>
                            <td class="metric-module-cell">${m.module}</td>
                            <td>${m.metric_name}</td>
                            <td class="metric-value-cell">${value}</td>
                        </tr>
                    `;
                }).join('');
            },
            
            // Fetch user interactions
            fetchInteractions: async function() {
                try {
                    // Query interactions from the metrics endpoint
                    const response = await fetch('/api/metrics/query?module=interaction&limit=20');
                    
                    // Also try to get from session summary for now
                    const container = document.getElementById('interactions-list');
                    if (!container) return;
                    
                    // For now, display from session data or placeholder
                    if (window.metricsLogger && window.metricsLogger._interactionLog) {
                        const interactions = window.metricsLogger._interactionLog.slice(-10);
                        if (interactions.length > 0) {
                            container.innerHTML = interactions.map(i => {
                                const time = new Date(i.timestamp);
                                const timeStr = time.toLocaleTimeString('en-US', { hour12: false });
                                return `
                                    <div class="interaction-item">
                                        <span class="interaction-time">${timeStr}</span>
                                        <span class="interaction-action">
                                            <strong>${i.action}</strong>
                                            ${i.target ? `<span class="interaction-target">→ ${i.target}</span>` : ''}
                                        </span>
                                    </div>
                                `;
                            }).reverse().join('');
                            
                            document.getElementById('total-interactions-count').textContent = 
                                window.metricsLogger._interactionLog.length.toString();
                            return;
                        }
                    }
                    
                    container.innerHTML = '<div style="color: #888; text-align: center; padding: 10px; font-size: 10px;">Interactions logged to SQLite - check server logs</div>';
                    document.getElementById('total-interactions-count').textContent = '--';
                    
                } catch (error) {
                    console.error('[MetricsExplorer] Error fetching interactions:', error);
                }
            },
            
            // Update live stats from current session
            updateLiveStats: function() {
                // Get data from the frontend metricsLogger if available
                if (window.metricsLogger && window.metricsLogger._lastMetrics) {
                    const last = window.metricsLogger._lastMetrics;
                    
                    document.getElementById('live-heap-used').textContent = 
                        last.heap_used_mb ? `${last.heap_used_mb.toFixed(1)} MB` : '--';
                    document.getElementById('live-entity-count').textContent = 
                        last.entity_count ?? '--';
                    document.getElementById('live-vessel-count').textContent = 
                        last.vessel_count ?? '--';
                    document.getElementById('live-update-rate').textContent = 
                        last.avg_update_ms ? `${last.avg_update_ms.toFixed(1)} ms` : '--';
                } else {
                    // Try to get from Auto-Recon visualization if available
                    if (window.RF_SCYTHE?.AutoReconVisualization) {
                        const recon = window.RF_SCYTHE.AutoReconVisualization;
                        document.getElementById('live-entity-count').textContent = 
                            recon.perfMetrics?.entityUpdates ?? '--';
                        document.getElementById('live-update-rate').textContent = 
                            recon.perfMetrics?.avgUpdateMs ? `${recon.perfMetrics.avgUpdateMs.toFixed(1)} ms` : '--';
                    }
                    
                    // Browser memory
                    if (performance.memory) {
                        document.getElementById('live-heap-used').textContent = 
                            `${(performance.memory.usedJSHeapSize / 1024 / 1024).toFixed(1)} MB`;
                    }
                }
            },
            
            // Cleanup
            destroy: function() {
                if (this.refreshInterval) {
                    clearInterval(this.refreshInterval);
                }
            }
        };
        
        // Initialize metrics explorer when DOM is ready
        document.addEventListener('DOMContentLoaded', function() {
            // Delay initialization to ensure other components are ready
            setTimeout(() => {
                MetricsExplorer.init();
            }, 2000);
        });
        
        // Metrics panel hook is handled by consolidated showPanel wrapper
        
        // ==================== END METRICS EXPLORER ====================
        
        // ==================== PROPAGATION ANALYSIS UI ====================
        
        const PropagationUI = {
            calculationHistory: [],
            pathCounter: 0,
            
            init: function() {
                console.log('[PropagationUI] Initializing...');
                
                // Atmospheric controls
                const humiditySlider = document.getElementById('atm-humidity');
                if (humiditySlider) {
                    humiditySlider.addEventListener('input', (e) => {
                        document.getElementById('atm-humidity-val').textContent = e.target.value + '%';
                    });
                }
                
                const tempSlider = document.getElementById('atm-temp');
                if (tempSlider) {
                    tempSlider.addEventListener('input', (e) => {
                        document.getElementById('atm-temp-val').textContent = e.target.value + '°C';
                    });
                }
                
                // Apply atmosphere button
                const applyAtmBtn = document.getElementById('apply-atmosphere-btn');
                if (applyAtmBtn) {
                    applyAtmBtn.addEventListener('click', () => this.applyAtmosphericSettings());
                }
                
                // Calculate path button
                const calcPathBtn = document.getElementById('calculate-path-btn');
                if (calcPathBtn) {
                    calcPathBtn.addEventListener('click', () => this.calculatePathLoss());
                }
                
                // Visualize path button
                const visPathBtn = document.getElementById('visualize-path-btn');
                if (visPathBtn) {
                    visPathBtn.addEventListener('click', () => this.visualizePath());
                }
                
                // Clear paths button
                const clearPathsBtn = document.getElementById('clear-paths-btn');
                if (clearPathsBtn) {
                    clearPathsBtn.addEventListener('click', () => this.clearAllPaths());
                }
                
                // Initialize atmospheric display
                this.updateAtmosphericDisplay();
                
                console.log('[PropagationUI] Initialized successfully');
            },
            
            applyAtmosphericSettings: function() {
                if (!window.RFPropagationManager) {
                    console.warn('[PropagationUI] RFPropagationManager not available');
                    return;
                }
                
                const humidity = parseFloat(document.getElementById('atm-humidity').value);
                const temperature = parseFloat(document.getElementById('atm-temp').value);
                const gradient = parseFloat(document.getElementById('atm-gradient').value);
                
                window.RFPropagationManager.setAtmosphericConditions({
                    humidity: humidity,
                    temperature: temperature,
                    refractivityGradient: gradient
                });
                
                this.updateAtmosphericDisplay();
                
                // Log the change
                if (window.logMetric) {
                    window.logMetric('propagation', 'atmosphere_updated', 1);
                }
            },
            
            updateAtmosphericDisplay: function() {
                if (!window.RFPropagationManager) return;
                
                const conditions = window.RFPropagationManager.atmosphericConditions;
                const classification = window.RFPropagationManager.classifyAtmosphere();
                
                document.getElementById('atm-k-factor').textContent = 
                    conditions.kFactor.toFixed(3);
                document.getElementById('atm-refractivity').textContent = 
                    conditions.surfaceRefractivity + ' N';
                document.getElementById('atm-condition').textContent = 
                    classification.condition;
                
                // Update condition color
                const conditionEl = document.getElementById('atm-condition');
                switch (classification.condition) {
                    case 'super-refractive':
                        conditionEl.style.color = '#00aaff';
                        break;
                    case 'standard':
                        conditionEl.style.color = '#00ff88';
                        break;
                    case 'sub-refractive':
                        conditionEl.style.color = '#ffaa00';
                        break;
                    default:
                        conditionEl.style.color = '#ff4444';
                }
            },
            
            getInputParameters: function() {
                return {
                    tx: {
                        lat: parseFloat(document.getElementById('tx-lat').value),
                        lon: parseFloat(document.getElementById('tx-lon').value),
                        height_m: parseFloat(document.getElementById('tx-height').value),
                        frequency_mhz: parseFloat(document.getElementById('tx-freq').value),
                        power_dbm: parseFloat(document.getElementById('tx-power').value)
                    },
                    rx: {
                        lat: parseFloat(document.getElementById('rx-lat').value),
                        lon: parseFloat(document.getElementById('rx-lon').value),
                        height_m: parseFloat(document.getElementById('rx-height').value),
                        sensitivity_dbm: parseFloat(document.getElementById('rx-sensitivity').value)
                    }
                };
            },
            
            calculatePathLoss: async function() {
                if (!window.RFPropagationManager) {
                    this.showError('RFPropagationManager not initialized');
                    return;
                }
                
                const resultsDiv = document.getElementById('path-analysis-results');
                resultsDiv.innerHTML = '<div style="color: #4a9eff; text-align: center; padding: 10px;">⏳ Calculating...</div>';
                
                const params = this.getInputParameters();
                
                try {
                    const analysis = await window.RFPropagationManager.calculatePathLoss(
                        params.tx, 
                        params.rx
                    );
                    
                    if (analysis.error) {
                        this.showError(analysis.error);
                        return;
                    }
                    
                    // Store in history
                    this.calculationHistory.push({
                        timestamp: Date.now(),
                        params: params,
                        analysis: analysis
                    });
                    
                    // Update results display
                    this.displayResults(analysis);
                    
                    // Update history table
                    this.updateHistoryTable();
                    
                    // Log interaction
                    if (window.logInteraction) {
                        window.logInteraction('calculate_path_loss', `${analysis.geometry.distance_km.toFixed(1)} km`);
                    }
                    
                } catch (error) {
                    this.showError(error.message);
                }
            },
            
            displayResults: function(analysis) {
                const resultsDiv = document.getElementById('path-analysis-results');
                const linkViable = analysis.linkBudget.linkViable;
                const linkColor = linkViable ? '#00ff88' : '#ff4444';
                
                resultsDiv.innerHTML = `
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-bottom: 10px;">
                        <div style="background: rgba(74, 158, 255, 0.1); padding: 8px; border-radius: 4px; text-align: center;">
                            <div style="font-size: 9px; color: #888;">Distance</div>
                            <div style="font-size: 14px; color: #4a9eff; font-weight: bold;">${analysis.geometry.distance_km.toFixed(2)} km</div>
                        </div>
                        <div style="background: rgba(74, 158, 255, 0.1); padding: 8px; border-radius: 4px; text-align: center;">
                            <div style="font-size: 9px; color: #888;">Total Path Loss</div>
                            <div style="font-size: 14px; color: #4a9eff; font-weight: bold;">${analysis.losses.total_db.toFixed(1)} dB</div>
                        </div>
                    </div>
                    
                    <div style="background: rgba(0, 0, 0, 0.3); padding: 8px; border-radius: 4px; margin-bottom: 8px;">
                        <div style="font-size: 10px; color: #888; margin-bottom: 5px;">Loss Breakdown</div>
                        <div style="display: flex; justify-content: space-between; font-size: 10px; margin-bottom: 3px;">
                            <span>Free Space:</span>
                            <span style="color: #4a9eff;">${analysis.losses.freeSpace_db.toFixed(1)} dB</span>
                        </div>
                        <div style="display: flex; justify-content: space-between; font-size: 10px; margin-bottom: 3px;">
                            <span>Diffraction:</span>
                            <span style="color: ${analysis.losses.diffraction_db > 0 ? '#ffaa00' : '#00ff88'};">${analysis.losses.diffraction_db.toFixed(1)} dB</span>
                        </div>
                        <div style="display: flex; justify-content: space-between; font-size: 10px;">
                            <span>Atmospheric:</span>
                            <span style="color: #888;">${analysis.losses.atmospheric_db.toFixed(1)} dB</span>
                        </div>
                    </div>
                    
                    <div style="background: rgba(${linkViable ? '0, 255, 136' : '255, 68, 68'}, 0.1); padding: 10px; border-radius: 4px; border: 1px solid ${linkColor};">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <div>
                                <div style="font-size: 9px; color: #888;">Link Status</div>
                                <div style="font-size: 12px; color: ${linkColor}; font-weight: bold;">
                                    ${linkViable ? '✓ LINK VIABLE' : '✗ LINK FAILED'}
                                </div>
                            </div>
                            <div style="text-align: right;">
                                <div style="font-size: 9px; color: #888;">Link Margin</div>
                                <div style="font-size: 16px; color: ${linkColor}; font-weight: bold;">
                                    ${analysis.linkBudget.linkMargin_db.toFixed(1)} dB
                                </div>
                            </div>
                        </div>
                        <div style="margin-top: 8px; font-size: 10px; color: #888;">
                            RX Power: ${analysis.linkBudget.receivedPower_dbm.toFixed(1)} dBm | 
                            Sensitivity: ${analysis.linkBudget.rxSensitivity_dbm} dBm
                        </div>
                    </div>
                    
                    <div style="margin-top: 8px; font-size: 10px; color: #666;">
                        Terrain samples: ${analysis.terrain.sampleCount} | 
                        Obstructions: ${analysis.terrain.obstructions} | 
                        Processing: ${analysis.processingTime_ms.toFixed(1)} ms
                    </div>
                `;
            },
            
            showError: function(message) {
                const resultsDiv = document.getElementById('path-analysis-results');
                resultsDiv.innerHTML = `
                    <div style="color: #ff4444; text-align: center; padding: 15px;">
                        ⚠️ Error: ${message}
                    </div>
                `;
            },
            
            visualizePath: async function() {
                if (!window.RFPropagationManager) {
                    this.showError('RFPropagationManager not initialized');
                    return;
                }
                
                const params = this.getInputParameters();
                const pathId = `path_${++this.pathCounter}`;
                
                try {
                    const analysis = await window.RFPropagationManager.visualizePropagationPath(
                        pathId,
                        params.tx,
                        params.rx
                    );
                    
                    if (analysis) {
                        this.displayResults(analysis);
                        this.calculationHistory.push({
                            timestamp: Date.now(),
                            params: params,
                            analysis: analysis,
                            pathId: pathId
                        });
                        this.updateHistoryTable();
                        
                        // Log interaction
                        if (window.logInteraction) {
                            window.logInteraction('visualize_path', pathId);
                        }
                    }
                } catch (error) {
                    this.showError(error.message);
                }
            },
            
            updateHistoryTable: function() {
                const tbody = document.getElementById('propagation-history-body');
                if (!tbody) return;
                
                if (this.calculationHistory.length === 0) {
                    tbody.innerHTML = '<tr><td colspan="4" style="text-align: center; color: #888;">No calculations yet</td></tr>';
                    return;
                }
                
                tbody.innerHTML = this.calculationHistory.slice(-10).reverse().map(item => {
                    const time = new Date(item.timestamp);
                    const timeStr = time.toLocaleTimeString('en-US', { hour12: false });
                    const analysis = item.analysis;
                    const linkViable = analysis.linkBudget.linkViable;
                    const marginColor = linkViable ? '#00ff88' : '#ff4444';
                    
                    return `
                        <tr>
                            <td class="metric-time-cell">${timeStr}</td>
                            <td>${analysis.geometry.distance_km.toFixed(1)} km</td>
                            <td class="metric-value-cell">${analysis.losses.total_db.toFixed(1)} dB</td>
                            <td style="color: ${marginColor}; font-weight: bold;">${analysis.linkBudget.linkMargin_db.toFixed(1)} dB</td>
                        </tr>
                    `;
                }).join('');
            },
            
            clearAllPaths: function() {
                if (window.RFPropagationManager) {
                    window.RFPropagationManager.clearAllPaths();
                }
                this.calculationHistory = [];
                this.updateHistoryTable();
                
                document.getElementById('path-analysis-results').innerHTML = `
                    <div style="color: #888; text-align: center; padding: 15px;">
                        Configure TX/RX parameters and click "Calculate Path Loss"
                    </div>
                `;
                
                if (window.logInteraction) {
                    window.logInteraction('clear_paths', 'all');
                }
            }
        };
        
        // Initialize PropagationUI when DOM is ready
        document.addEventListener('DOMContentLoaded', function() {
            setTimeout(() => {
                PropagationUI.init();
            }, 2500);
        });
        
        // Propagation panel hook is handled by consolidated showPanel wrapper
        
        // ==================== END PROPAGATION ANALYSIS UI ====================
        
        // Hypersonic Defense System Functions
        
        // Update sensor list based on count
        function updateSensorList(count) {
            const sensorPanel = document.getElementById('sensorPanel');
            if (!sensorPanel) return;
            
            sensorPanel.innerHTML = '';
            
            const positions = ['Primary', 'North', 'East', 'West', 'South', 'Northeast', 'Northwest', 'Southeast'];
            const offsets = [0.0, 1.4, 2.1, 0.7, 1.9, 2.8, 1.2, 0.9];
            const statuses = ['status-active-small', 'status-active-small', 'status-active-small', 'status-warning-small'];
            
            for (let i = 0; i < count; i++) {
                const statusClass = statuses[i] || 'status-active-small';
                const sensorHtml = `
                    <div style="display: flex; align-items: center; font-size: 0.85rem; color: #ccc;">
                        <span style="display: inline-block; width: 8px; height: 8px; border-radius: 50%; margin-right: 8px; background-color: ${statusClass.includes('warning') ? '#ffcc00' : '#33cc33'}; box-shadow: 0 0 3px ${statusClass.includes('warning') ? '#ffcc00' : '#33cc33'};"></span>
                        Sensor ${i+1} (${positions[i]})
                    </div>
                    <div style="font-size: 0.75rem; color: #999; margin-left: 16px;">X-Band, Offset: ${offsets[i]} ns</div>
                `;
                sensorPanel.innerHTML += sensorHtml;
            }
        }
        
        // RF Visualization using Plotly
        function initializeRFVisualization() {
            if (!window.Plotly) {
                console.warn('Plotly not loaded, skipping RF visualization');
                return;
            }
            
            const frequencies = [];
            const amplitudes = [];
            
            // Create sample data
            for (let f = 8; f <= 12; f += 0.01) {
                frequencies.push(f);
                
                // Base signal shape
                let amp = 0.2 + 0.8 * Math.exp(-Math.pow((f - 10) / 0.5, 2));
                
                // Add some noise
                amp += 0.05 * (Math.random() - 0.5);
                
                amplitudes.push(amp);
            }
            
            const data = [{
                x: frequencies,
                y: amplitudes,
                type: 'scatter',
                mode: 'lines',
                line: {
                    color: '#ff9f1c',
                    width: 2
                },
                name: 'X-Band Return'
            }];
            
            const layout = {
                title: {
                    text: 'Multiscopic Radar Return',
                    font: { color: '#ff9f1c', size: 12 }
                },
                paper_bgcolor: 'rgba(0,0,0,0)',
                plot_bgcolor: 'rgba(0,0,0,0)',
                font: {
                    color: '#ccc',
                    size: 10
                },
                xaxis: {
                    title: 'Frequency (GHz)',
                    gridcolor: '#444',
                    zerolinecolor: '#666'
                },
                yaxis: {
                    title: 'Amplitude',
                    gridcolor: '#444',
                    zerolinecolor: '#666'
                },
                margin: { l: 40, r: 20, t: 40, b: 40 },
                showlegend: false
            };
            
            const config = {
                responsive: true,
                displayModeBar: false
            };
            
            const rfElement = document.getElementById('rfVisualization');
            if (rfElement) {
                Plotly.newPlot('rfVisualization', data, layout, config);
            }
        }
        
        // Plasma Visualization using Plotly
        function initializePlasmaVisualization() {
            if (!window.Plotly) {
                console.warn('Plotly not loaded, skipping plasma visualization');
                return;
            }
            
            // Create data for electron density vs altitude plot
            const altitudes = [];
            const electronDensities = [];
            const plasmaFrequencies = [];
            
            // Generate sample data
            for (let alt = 5; alt <= 60; alt += 2) {
                altitudes.push(alt);
                
                // Electron density model (simplified)
                let density;
                if (alt < 15) {
                    density = 1e14 * Math.exp((alt - 15) / 5);
                } else if (alt < 25) {
                    density = 1e15 * Math.exp((alt - 20) / 15);
                } else if (alt < 50) {
                    density = 1e17 * Math.exp(-(alt - 25) / 15);
                } else {
                    density = 1e16 * Math.exp(-(alt - 40) / 10);
                }
                
                // Add some variation
                density *= (0.8 + 0.4 * Math.random());
                
                electronDensities.push(density);
                
                // Calculate plasma frequency (simplified)
                const plasmaFreq = 8.98 * Math.sqrt(density / 1e12); // MHz
                plasmaFrequencies.push(plasmaFreq);
            }
            
            const data = [{
                x: electronDensities,
                y: altitudes,
                type: 'scatter',
                mode: 'lines+markers',
                line: { color: '#ff3c38', width: 2 },
                marker: { color: '#ff9f1c', size: 4 },
                name: 'Electron Density'
            }];
            
            const layout = {
                title: {
                    text: 'Plasma Sheath Properties',
                    font: { color: '#ff9f1c', size: 12 }
                },
                paper_bgcolor: 'rgba(0,0,0,0)',
                plot_bgcolor: 'rgba(0,0,0,0)',
                font: {
                    color: '#ccc',
                    size: 10
                },
                xaxis: {
                    title: 'Electron Density (m⁻³)',
                    type: 'log',
                    gridcolor: '#444',
                    zerolinecolor: '#666'
                },
                yaxis: {
                    title: 'Altitude (km)',
                    gridcolor: '#444',
                    zerolinecolor: '#666'
                },
                margin: { l: 40, r: 20, t: 40, b: 40 },
                showlegend: false
            };
            
            const config = {
                responsive: true,
                displayModeBar: false
            };
            
            const plasmaElement = document.getElementById('plasmaVisualization');
            if (plasmaElement) {
                Plotly.newPlot('plasmaVisualization', data, layout, config);
            }
        }
        
        // Simulation variables for hypersonic tracking
        let simulationRunning = false;
        let simulationTime = 0;
        let animationFrame = null;
        
        // Start simulation
        function startHypersonicSimulation() {
            if (simulationRunning) return;
            
            simulationRunning = true;
            simulationTime = 0;
            
            // Update UI to show simulation is running
            document.querySelectorAll('.status-indicator-small').forEach(el => {
                el.style.backgroundColor = '#33cc33';
                el.style.boxShadow = '0 0 3px #33cc33';
            });
            
            // Start animation loop
            animateHypersonicSimulation();
        }
        
        // Stop simulation
        function stopHypersonicSimulation() {
            simulationRunning = false;
            
            if (animationFrame) {
                cancelAnimationFrame(animationFrame);
                animationFrame = null;
            }
            
            // Update UI to show simulation is stopped
            document.querySelectorAll('.status-indicator-small').forEach(el => {
                el.style.backgroundColor = '#666';
                el.style.boxShadow = '0 0 3px #666';
            });
        }
        
        // Reset simulation
        function resetHypersonicSimulation() {
            stopHypersonicSimulation();
            
            // Reset UI values
            const velocityValue = document.getElementById('velocityValue');
            const altitudeValue = document.getElementById('altitudeValue');
            const machValue = document.getElementById('machValue');
            const trackQualityValue = document.getElementById('trackQualityValue');
            const timelineProgress = document.getElementById('timelineProgress');
            const missionTime = document.getElementById('missionTime');
            
            if (velocityValue) velocityValue.textContent = '2,140';
            if (altitudeValue) altitudeValue.textContent = '24,800';
            if (machValue) machValue.textContent = '6.3';
            if (trackQualityValue) trackQualityValue.textContent = '0.87';
            if (timelineProgress) timelineProgress.style.width = '0%';
            if (missionTime) missionTime.textContent = 'T+00:00:00';
        }
        
        // Animate simulation
        function animateHypersonicSimulation() {
            if (!simulationRunning) return;
            
            // Update simulation time
            simulationTime += 0.016;  // ~60fps
            
            // Update telemetry values
            const velocityValue = document.getElementById('velocityValue');
            const altitudeValue = document.getElementById('altitudeValue');
            const machValue = document.getElementById('machValue');
            const trackQualityValue = document.getElementById('trackQualityValue');
            const timelineProgress = document.getElementById('timelineProgress');
            const missionTime = document.getElementById('missionTime');
            
            if (velocityValue) {
                const velocity = 2140 + Math.sin(simulationTime * 0.1) * 100 + Math.random() * 20;
                velocityValue.textContent = Math.round(velocity).toLocaleString();
            }
            
            if (altitudeValue) {
                const altitude = 24800 + Math.sin(simulationTime * 0.05) * 2000 + Math.random() * 100;
                altitudeValue.textContent = Math.round(altitude).toLocaleString();
            }
            
            if (machValue) {
                const mach = 6.3 + Math.sin(simulationTime * 0.15) * 0.5 + Math.random() * 0.1;
                machValue.textContent = mach.toFixed(1);
            }
            
            if (trackQualityValue) {
                const quality = 0.87 + Math.sin(simulationTime * 0.2) * 0.1 + Math.random() * 0.05;
                trackQualityValue.textContent = Math.max(0, Math.min(1, quality)).toFixed(2);
            }
            
            if (timelineProgress) {
                const progress = (simulationTime * 2) % 100;
                timelineProgress.style.width = `${progress}%`;
            }
            
            if (missionTime) {
                const totalSeconds = Math.floor(simulationTime * 10);
                const hours = Math.floor(totalSeconds / 3600);
                const minutes = Math.floor((totalSeconds % 3600) / 60);
                const seconds = totalSeconds % 60;
                missionTime.textContent = `T+${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            }
            
            // Continue animation
            animationFrame = requestAnimationFrame(animateHypersonicSimulation);
        }
        
        // Initialize hypersonic defense controls when DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            // Set up slider event listeners
            const sliders = [
                { id: 'baselineSlider', valueId: 'baselineValue' },
                { id: 'sensorCountSlider', valueId: 'sensorCountValue' },
                { id: 'resolutionSlider', valueId: 'resolutionValue' },
                { id: 'jinkThresholdSlider', valueId: 'jinkThresholdValue' },
                { id: 'predictionTimeSlider', valueId: 'predictionTimeValue' }
            ];
            
            sliders.forEach(slider => {
                const sliderElement = document.getElementById(slider.id);
                const valueElement = document.getElementById(slider.valueId);
                
                if (sliderElement && valueElement) {
                    sliderElement.addEventListener('input', function() {
                        valueElement.textContent = this.value;
                        
                        // Special handling for sensor count
                        if (slider.id === 'sensorCountSlider') {
                            updateSensorList(parseInt(this.value));
                        }
                    });
                }
            });
            
            // Set up action buttons
            const engageButton = document.getElementById('engageTracking');
            if (engageButton) {
                engageButton.addEventListener('click', function() {
                    if (this.textContent.includes('Engage')) {
                        this.textContent = 'Disengage Tracking';
                        this.style.backgroundColor = '#ff5a57';
                        startHypersonicSimulation();
                    } else {
                        this.textContent = 'Engage Multiscopic Tracking';
                        this.style.backgroundColor = '#ff3c38';
                        stopHypersonicSimulation();
                    }
                });
            }
            
            const resetButton = document.getElementById('resetTracking');
            if (resetButton) {
                resetButton.addEventListener('click', function() {
                    resetHypersonicSimulation();
                    
                    const engageButton = document.getElementById('engageTracking');
                    if (engageButton) {
                        engageButton.textContent = 'Engage Multiscopic Tracking';
                        engageButton.style.backgroundColor = '#ff3c38';
                    }
                });
            }
            
            // Initialize visualizations after a short delay to ensure Plotly is loaded
            setTimeout(() => {
                try {
                    initializeRFVisualization();
                    initializePlasmaVisualization();
                } catch (error) {
                    console.warn('Could not initialize visualizations:', error);
                }
            }, 1000);
        });
        
        // RF Hypergraph Visualization Class
        // Nmap Hypergraph Scanner for network discovery and visualization
        class NmapHypergraphScanner {
            constructor(hypergraphVisualizer) {
                this.visualizer = hypergraphVisualizer;
                this.scanResults = new Map();
                this.networkTopology = new Map();
                this.activeScans = new Set();
                this.scanHistory = [];
                
                // Nmap scanning configuration
                this.scanConfig = {
                    defaultPorts: [21, 22, 23, 25, 53, 80, 110, 135, 139, 143, 443, 993, 995, 1723, 3389, 5900, 8080],
                    commonPorts: [1, 5, 7, 9, 13, 17, 19, 20, 21, 22, 23, 25, 26, 37, 42, 43, 49, 53, 70, 79, 80, 88, 106, 110, 111, 113, 119, 135, 139, 143, 179, 199, 389, 427, 443, 444, 445, 465, 513, 514, 515, 543, 544, 548, 554, 587, 631, 646, 873, 990, 993, 995, 1025, 1026, 1027, 1028, 1029, 1110, 1433, 1720, 1723, 1755, 1900, 2000, 2001, 2049, 2121, 2717, 3000, 3128, 3306, 3389, 3986, 4899, 5000, 5009, 5051, 5060, 5101, 5190, 5357, 5432, 5631, 5666, 5800, 5900, 6000, 6001, 6646, 7070, 8000, 8008, 8009, 8080, 8081, 8443, 8888, 9100, 9999, 10000, 32768, 49152, 49153, 49154, 49155, 49156, 49157],
                    scanTypes: ['SYN', 'TCP_CONNECT', 'UDP', 'PING', 'ARP', 'SERVICE_DETECTION'],
                    timingTemplates: ['T1', 'T2', 'T3', 'T4', 'T5'],
                    defaultTiming: 'T3'
                };
                
                console.log('NmapHypergraphScanner initialized');
            }
            
            // Simulate an nmap scan and create hypergraph visualization
            async performNetworkScan(targetNetwork, options = {}) {
                const scanId = this.generateScanId();
                const scanConfig = {
                    target: targetNetwork,
                    scanType: options.scanType || 'SYN',
                    ports: options.ports || this.scanConfig.defaultPorts,
                    timing: options.timing || this.scanConfig.defaultTiming,
                    serviceDetection: options.serviceDetection || true,
                    osDetection: options.osDetection || false,
                    scriptScan: options.scriptScan || false,
                    verbose: options.verbose || true,
                    ...options
                };
                
                console.log(`Starting nmap scan ${scanId} on ${targetNetwork}`, scanConfig);
                this.activeScans.add(scanId);
                
                try {
                    // Simulate the scanning process
                    const scanResults = await this.simulateNmapScan(targetNetwork, scanConfig);
                    
                    // Convert scan results to hypergraph format
                    const hypergraphData = this.convertNmapToHypergraph(scanResults);
                    
                    // Visualize the results
                    this.visualizeNetworkTopology(hypergraphData, scanId);
                    
                    // Store results
                    this.scanResults.set(scanId, {
                        timestamp: new Date().toISOString(),
                        config: scanConfig,
                        results: scanResults,
                        hypergraphData: hypergraphData
                    });
                    
                    this.activeScans.delete(scanId);
                    this.scanHistory.push(scanId);
                    
                    console.log(`Nmap scan ${scanId} completed successfully`);
                    return { scanId, results: scanResults, hypergraphData };
                    
                } catch (error) {
                    console.error(`Nmap scan ${scanId} failed:`, error);
                    this.activeScans.delete(scanId);
                    throw error;
                }
            }
            
            // Simulate nmap scan results with realistic network data
            async simulateNmapScan(targetNetwork, config) {
                const results = {
                    scanId: this.generateScanId(),
                    target: targetNetwork,
                    scanTime: new Date().toISOString(),
                    hostsDiscovered: [],
                    services: [],
                    vulnerabilities: [],
                    networkTopology: {
                        subnets: [],
                        routers: [],
                        switches: [],
                        firewalls: []
                    }
                };
                
                // Simulate discovery delay
                await this.delay(2000);
                
                // Generate discovered hosts based on network range
                const hostCount = Math.floor(Math.random() * 20) + 5; // 5-25 hosts
                for (let i = 0; i < hostCount; i++) {
                    const host = this.generateDiscoveredHost(targetNetwork, i);
                    results.hostsDiscovered.push(host);
                    
                    // Generate services for each host
                    const serviceCount = Math.floor(Math.random() * 8) + 1; // 1-8 services per host
                    for (let j = 0; j < serviceCount; j++) {
                        const service = this.generateServiceData(host, j);
                        results.services.push(service);
                        
                        // Chance of vulnerability
                        if (Math.random() < 0.3) {
                            const vulnerability = this.generateVulnerabilityData(host, service);
                            results.vulnerabilities.push(vulnerability);
                        }
                    }
                }
                
                // Generate network infrastructure
                results.networkTopology = this.generateNetworkTopology(results.hostsDiscovered);
                
                return results;
            }
            
            // Generate realistic host data
            generateDiscoveredHost(networkBase, hostIndex) {
                const osTypes = ['Linux', 'Windows', 'macOS', 'FreeBSD', 'RouterOS', 'IOS', 'Android'];
                const deviceTypes = ['workstation', 'server', 'router', 'switch', 'firewall', 'printer', 'IoT', 'mobile'];
                
                const baseIp = networkBase.split('/')[0];
                const ipParts = baseIp.split('.');
                const hostIp = `${ipParts[0]}.${ipParts[1]}.${ipParts[2]}.${parseInt(ipParts[3]) + hostIndex + 1}`;
                
                return {
                    ip: hostIp,
                    hostname: `host-${hostIndex + 1}.local`,
                    mac: this.generateMacAddress(),
                    os: osTypes[Math.floor(Math.random() * osTypes.length)],
                    deviceType: deviceTypes[Math.floor(Math.random() * deviceTypes.length)],
                    status: Math.random() < 0.9 ? 'up' : 'down',
                    latency: Math.random() * 100 + 1, // 1-100ms
                    openPorts: [],
                    rfSignature: this.generateRfSignature()
                };
            }
            
            // Generate RF signature for RF SCYTHE integration
            generateRfSignature() {
                const frequencies = [433.92, 868, 915, 2400, 5800];
                const modulations = ['ASK', 'FSK', 'PSK', 'QAM', 'OFDM'];
                
                return {
                    frequency: frequencies[Math.floor(Math.random() * frequencies.length)],
                    modulation: modulations[Math.floor(Math.random() * modulations.length)],
                    power: Math.random() * -40 - 60, // -100 to -60 dBm
                    bandwidth: Math.random() * 20 + 5, // 5-25 MHz
                    detected: Math.random() < 0.4 // 40% chance of RF detection
                };
            }
            
            // Generate service data for discovered hosts
            generateServiceData(host, serviceIndex) {
                const commonServices = [
                    { port: 22, name: 'ssh', protocol: 'tcp', version: 'OpenSSH 8.9' },
                    { port: 80, name: 'http', protocol: 'tcp', version: 'Apache 2.4.52' },
                    { port: 443, name: 'https', protocol: 'tcp', version: 'nginx 1.18.0' },
                    { port: 21, name: 'ftp', protocol: 'tcp', version: 'vsftpd 3.0.3' },
                    { port: 25, name: 'smtp', protocol: 'tcp', version: 'Postfix 3.6.4' },
                    { port: 53, name: 'dns', protocol: 'udp', version: 'BIND 9.16.1' },
                    { port: 135, name: 'msrpc', protocol: 'tcp', version: 'Microsoft Windows RPC' },
                    { port: 139, name: 'netbios-ssn', protocol: 'tcp', version: 'Microsoft Windows netbios-ssn' },
                    { port: 445, name: 'microsoft-ds', protocol: 'tcp', version: 'Microsoft Windows Server 2019' },
                    { port: 3389, name: 'rdp', protocol: 'tcp', version: 'Microsoft Terminal Services' }
                ];
                
                const service = commonServices[serviceIndex % commonServices.length];
                
                return {
                    hostIp: host.ip,
                    port: service.port,
                    protocol: service.protocol,
                    state: Math.random() < 0.8 ? 'open' : 'filtered',
                    service: service.name,
                    version: service.version,
                    fingerprint: this.generateServiceFingerprint(),
                    rfCorrelation: this.correlateWithRF(host.rfSignature, service)
                };
            }
            
            // Correlate network services with RF signatures
            correlateWithRF(rfSignature, service) {
                if (!rfSignature.detected) return null;
                
                // Services that commonly have RF correlations
                const rfCorrelatedServices = {
                    'ssh': { likelihood: 0.2, reason: 'Remote administration' },
                    'http': { likelihood: 0.6, reason: 'IoT web interface' },
                    'https': { likelihood: 0.7, reason: 'Secure IoT management' },
                    'ftp': { likelihood: 0.3, reason: 'File transfer for IoT' },
                    'telnet': { likelihood: 0.8, reason: 'Legacy IoT configuration' },
                    'snmp': { likelihood: 0.9, reason: 'Network device monitoring' }
                };
                
                const correlation = rfCorrelatedServices[service.name];
                if (correlation && Math.random() < correlation.likelihood) {
                    return {
                        frequency: rfSignature.frequency,
                        strength: Math.random() * 0.8 + 0.2, // 0.2-1.0
                        type: 'correlated_service',
                        reason: correlation.reason,
                        confidence: Math.random() * 0.4 + 0.6 // 0.6-1.0
                    };
                }
                
                return null;
            }
            
            // Convert nmap results to hypergraph format for visualization
            convertNmapToHypergraph(scanResults) {
                const nodes = [];
                const hyperedges = [];
                
                // Create nodes for each discovered host
                scanResults.hostsDiscovered.forEach((host, index) => {
                    const nodeId = `host_${host.ip.replace(/\./g, '_')}`;
                    
                    // Position nodes in 3D space based on network topology
                    const position = this.calculateNodePosition(host, index, scanResults.hostsDiscovered.length);
                    
                    const node = {
                        id: nodeId,
                        type: 'network_host',
                        label: host.hostname || host.ip,
                        position: position,
                        freq: host.rfSignature.frequency,
                        power: host.rfSignature.power,
                        properties: {
                            ip: host.ip,
                            hostname: host.hostname,
                            os: host.os,
                            deviceType: host.deviceType,
                            status: host.status,
                            latency: host.latency,
                            rfDetected: host.rfSignature.detected,
                            rfModulation: host.rfSignature.modulation
                        }
                    };
                    
                    nodes.push(node);
                });
                
                // Create hyperedges for service connections
                const serviceGroups = this.groupServicesByType(scanResults.services);
                Object.entries(serviceGroups).forEach(([serviceName, services], edgeIndex) => {
                    if (services.length > 1) {
                        const nodeIds = services.map(service => `host_${service.hostIp.replace(/\./g, '_')}`);
                        
                        const hyperedge = {
                            id: `service_${serviceName}_${edgeIndex}`,
                            type: 'service_group',
                            nodes: nodeIds,
                            cardinality: nodeIds.length,
                            strength: services.reduce((sum, s) => sum + (s.rfCorrelation ? s.rfCorrelation.strength : 0), 0),
                            properties: {
                                serviceName: serviceName,
                                port: services[0].port,
                                protocol: services[0].protocol,
                                totalHosts: services.length,
                                rfCorrelated: services.filter(s => s.rfCorrelation).length
                            }
                        };
                        
                        hyperedges.push(hyperedge);
                    }
                });
                
                // Create hyperedges for RF frequency groups
                const rfGroups = this.groupHostsByRfFrequency(scanResults.hostsDiscovered);
                Object.entries(rfGroups).forEach(([frequency, hosts], edgeIndex) => {
                    if (hosts.length > 1) {
                        const nodeIds = hosts.map(host => `host_${host.ip.replace(/\./g, '_')}`);
                        
                        const hyperedge = {
                            id: `rf_freq_${frequency}_${edgeIndex}`,
                            type: 'rf_frequency_group',
                            nodes: nodeIds,
                            cardinality: nodeIds.length,
                            strength: -60, // Average RF power
                            properties: {
                                frequency: parseFloat(frequency),
                                totalHosts: hosts.length,
                                avgPower: hosts.reduce((sum, h) => sum + h.rfSignature.power, 0) / hosts.length,
                                modulations: [...new Set(hosts.map(h => h.rfSignature.modulation))]
                            }
                        };
                        
                        hyperedges.push(hyperedge);
                    }
                });
                
                // Create vulnerability hyperedges
                if (scanResults.vulnerabilities.length > 0) {
                    const vulnGroups = this.groupVulnerabilitiesByType(scanResults.vulnerabilities);
                    Object.entries(vulnGroups).forEach(([vulnType, vulns], edgeIndex) => {
                        const nodeIds = vulns.map(vuln => `host_${vuln.hostIp.replace(/\./g, '_')}`);
                        
                        const hyperedge = {
                            id: `vuln_${vulnType}_${edgeIndex}`,
                            type: 'vulnerability_group',
                            nodes: nodeIds,
                            cardinality: nodeIds.length,
                            strength: -80, // High strength for vulnerabilities
                            properties: {
                                vulnerabilityType: vulnType,
                                severity: vulns[0].severity,
                                totalAffected: vulns.length,
                                cvssScore: vulns[0].cvssScore || 'N/A'
                            }
                        };
                        
                        hyperedges.push(hyperedge);
                    });
                }
                
                return {
                    nodes: nodes,
                    hyperedges: hyperedges,
                    metadata: {
                        scanTime: scanResults.scanTime,
                        targetNetwork: scanResults.target,
                        totalHosts: scanResults.hostsDiscovered.length,
                        totalServices: scanResults.services.length,
                        totalVulnerabilities: scanResults.vulnerabilities.length,
                        rfCorrelatedHosts: scanResults.hostsDiscovered.filter(h => h.rfSignature.detected).length
                    }
                };
            }
            
            // Calculate 3D position for nodes based on network structure
            calculateNodePosition(host, index, totalHosts) {
                const radius = 200; // Base radius for node placement
                const layers = Math.ceil(Math.sqrt(totalHosts));
                const layer = Math.floor(index / layers);
                const positionInLayer = index % layers;
                const angleStep = (2 * Math.PI) / Math.max(layers, 1);
                
                // Create layered circular arrangement with RF frequency-based height
                const angle = angleStep * positionInLayer;
                const layerRadius = radius + (layer * 50);
                const height = host.rfSignature.detected ? 
                    (host.rfSignature.frequency / 100) : // Scale frequency to height
                    Math.random() * 50 - 25; // Random height for non-RF hosts
                
                return [
                    Math.cos(angle) * layerRadius,
                    height,
                    Math.sin(angle) * layerRadius
                ];
            }
            
            // Group services by type for hyperedge creation
            groupServicesByType(services) {
                return services.reduce((groups, service) => {
                    const key = service.service;
                    if (!groups[key]) groups[key] = [];
                    groups[key].push(service);
                    return groups;
                }, {});
            }
            
            // Group hosts by RF frequency for hypergraph analysis
            groupHostsByRfFrequency(hosts) {
                return hosts
                    .filter(host => host.rfSignature.detected)
                    .reduce((groups, host) => {
                        const key = host.rfSignature.frequency.toString();
                        if (!groups[key]) groups[key] = [];
                        groups[key].push(host);
                        return groups;
                    }, {});
            }
            
            // Group vulnerabilities by type
            groupVulnerabilitiesByType(vulnerabilities) {
                return vulnerabilities.reduce((groups, vuln) => {
                    const key = vuln.type;
                    if (!groups[key]) groups[key] = [];
                    groups[key].push(vuln);
                    return groups;
                }, {});
            }
            
            // Visualize the network topology in the hypergraph
            visualizeNetworkTopology(hypergraphData, scanId) {
                console.log(`Visualizing network topology for scan ${scanId}`, hypergraphData);
                
                // Load the data into the hypergraph visualizer
                this.visualizer.loadData(hypergraphData);
                
                // Add scan-specific metadata to the visualization
                this.addNmapMetadata(hypergraphData.metadata, scanId);
                
                // Update statistics display
                this.updateNmapStatistics(hypergraphData);
                
                // Create console messages
                this.addNmapConsoleMessages(hypergraphData, scanId);
            }
            
            // Add nmap-specific metadata to visualization
            addNmapMetadata(metadata, scanId) {
                const metadataNode = {
                    id: `scan_metadata_${scanId}`,
                    type: 'scan_metadata',
                    label: `Scan ${scanId}`,
                    position: [0, 100, 0], // Center top position
                    freq: 0,
                    power: -50,
                    properties: metadata
                };
                
                this.visualizer.addNode(metadataNode);
            }
            
            // Update statistics display with nmap results
            updateNmapStatistics(hypergraphData) {
                const stats = hypergraphData.metadata;
                
                // Update hypergraph statistics panel
                const nodesElement = document.getElementById('hypergraph-nodes');
                const edgesElement = document.getElementById('hypergraph-edges');
                const cardinalityElement = document.getElementById('max-cardinality');
                const timeElement = document.getElementById('collection-time');
                
                if (nodesElement) nodesElement.textContent = stats.totalHosts;
                if (edgesElement) edgesElement.textContent = hypergraphData.hyperedges.length;
                if (cardinalityElement) {
                    const maxCardinality = Math.max(...hypergraphData.hyperedges.map(e => e.cardinality));
                    cardinalityElement.textContent = maxCardinality;
                }
                if (timeElement) timeElement.textContent = `${stats.scanTime}`;
            }
            
            // Add console messages for nmap scan results
            addNmapConsoleMessages(hypergraphData, scanId) {
                const stats = hypergraphData.metadata;
                
                addConsoleMessage(`Nmap scan ${scanId} completed`, 'command');
                addConsoleMessage(`Discovered ${stats.totalHosts} hosts with ${stats.totalServices} services`, 'response');
                addConsoleMessage(`RF correlation found on ${stats.rfCorrelatedHosts} hosts`, 'response');
                
                if (stats.totalVulnerabilities > 0) {
                    addConsoleMessage(`ALERT: ${stats.totalVulnerabilities} vulnerabilities detected`, 'alert');
                }
                
                // Show notification
                showNotification('Nmap Scan Complete', 
                    `Discovered ${stats.totalHosts} hosts with ${stats.rfCorrelatedHosts} RF correlations`, 
                    'success');
            }
            
            // Utility functions
            generateScanId() {
                return `nmap_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
            }
            
            generateMacAddress() {
                return Array.from({length: 6}, () => 
                    Math.floor(Math.random() * 256).toString(16).padStart(2, '0')
                ).join(':');
            }
            
            generateServiceFingerprint() {
                return Math.random().toString(36).substr(2, 16);
            }
            
            generateNetworkTopology(hosts) {
                return {
                    subnets: [`${hosts[0]?.ip.split('.').slice(0, 3).join('.')}.0/24`],
                    routers: hosts.filter(h => h.deviceType === 'router').map(h => h.ip),
                    switches: hosts.filter(h => h.deviceType === 'switch').map(h => h.ip),
                    firewalls: hosts.filter(h => h.deviceType === 'firewall').map(h => h.ip)
                };
            }
            
            generateVulnerabilityData(host, service) {
                const vulnTypes = ['buffer_overflow', 'sql_injection', 'xss', 'csrf', 'rce', 'privilege_escalation'];
                const severities = ['Low', 'Medium', 'High', 'Critical'];
                
                return {
                    hostIp: host.ip,
                    service: service.service,
                    port: service.port,
                    type: vulnTypes[Math.floor(Math.random() * vulnTypes.length)],
                    severity: severities[Math.floor(Math.random() * severities.length)],
                    cvssScore: (Math.random() * 10).toFixed(1),
                    description: 'Simulated vulnerability detected during scan'
                };
            }
            
            delay(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }
            
            // Get scan results by ID
            getScanResults(scanId) {
                return this.scanResults.get(scanId);
            }
            
            // Get all scan history
            getScanHistory() {
                return this.scanHistory.map(scanId => this.scanResults.get(scanId));
            }
        }

        class HypergraphRFVisualizer {
            constructor(containerId, options = {}) {
                // Default options
                this.options = {
                    backgroundColor: 0x000033,
                    nodeSize: 5,
                    maxEdgeWidth: 5,
                    minEdgeWidth: 0.5,
                    colorByFrequency: true,
                    showNodeLabels: true,
                    showHigherOrderEdges: true,
                    hyperedgeOpacity: 0.3,
                    labelScale: 1.0,
                    ...options
                };

                // Container element
                this.container = document.getElementById(containerId);
                if (!this.container) {
                    console.error(`Container with ID ${containerId} not found`);
                    return;
                }

                // Set up Three.js scene
                this.setupScene();
                
                // Initialize data structures
                this.nodes = new Map(); // Map of node ID to node data
                this.hyperedges = new Map(); // Map of hyperedge ID to hyperedge data
                this.nmapNodes = new Map(); // Map for nmap discovered nodes
                this.nmapEdges = new Map(); // Map for nmap connections
                
                // Nmap scanner instance
                this.nmapScanner = new NmapHypergraphScanner(this);
                
                // Start rendering
                this.animate();
                
                // Window resize handler
                window.addEventListener('resize', this.onWindowResize.bind(this));
            }
            
            setupScene() {
                // Create Three.js scene
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(this.options.backgroundColor);
                
                // Create camera
                const width = this.container.clientWidth || 800;
                const height = this.container.clientHeight || 600;
                this.camera = new THREE.PerspectiveCamera(60, width / height, 0.1, 10000);
                this.camera.position.set(500, 500, 500);
                this.camera.lookAt(0, 0, 0);
                
                // Create renderer
                this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
                this.renderer.setSize(width, height);
                this.renderer.setPixelRatio(window.devicePixelRatio);
                this.container.appendChild(this.renderer.domElement);
                
                // Add orbit controls if Three.js OrbitControls is available
                if (window.ThreeOrbitControls) {
                    this.controls = new window.ThreeOrbitControls(this.camera, this.renderer.domElement);
                    this.controls.enableDamping = true;
                    this.controls.dampingFactor = 0.05;
                }
                
                // Create object groups
                this.nodesGroup = new THREE.Group();
                this.edgesGroup = new THREE.Group();
                this.hyperedgesGroup = new THREE.Group();
                
                this.scene.add(this.nodesGroup);
                this.scene.add(this.edgesGroup);
                this.scene.add(this.hyperedgesGroup);
                
                // Add grid helper
                const gridHelper = new THREE.GridHelper(1000, 10, 0x888888, 0x444444);
                gridHelper.material.transparent = true;
                gridHelper.material.opacity = 0.3;
                this.scene.add(gridHelper);
                
                // Add ambient light
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
                this.scene.add(ambientLight);
                
                // Add directional light
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(0, 1, 0.5);
                this.scene.add(directionalLight);
            }
            
            // Load hypergraph data
            loadData(data) {
                if (!data || !data.nodes || !data.hyperedges) {
                    console.error('Invalid hypergraph data format');
                    return;
                }
                
                // Clear existing visualization
                this.clear();
                
                // Store data
                this.data = data;
                
                // Process nodes
                data.nodes.forEach(node => {
                    this.addNode(node);
                });
                
                // Process hyperedges
                data.hyperedges.forEach(edge => {
                    this.addHyperedge(edge);
                });
                
                // Update camera to fit the graph
                this.fitCameraToGraph();
                
                // Update statistics
                this.updateStatistics(data);
                
                console.log(`Loaded ${data.nodes.length} nodes and ${data.hyperedges.length} hyperedges`);
            }
            
            // Add a node to the visualization
            addNode(nodeData) {
                const { id, position, freq, power } = nodeData;
                
                // Create node geometry
                const geometry = new THREE.SphereGeometry(this.options.nodeSize);
                
                // Determine color based on frequency if option is enabled
                let color;
                if (this.options.colorByFrequency) {
                    const hue = this.mapFrequencyToHue(freq);
                    color = new THREE.Color().setHSL(hue, 1, 0.5);
                } else {
                    const powerScale = Math.min(1, Math.max(0, (power + 100) / 60));
                    color = new THREE.Color().setHSL(0.6, 1, powerScale);
                }
                
                // Create node material
                const material = new THREE.MeshStandardMaterial({ 
                    color: color,
                    emissive: color.clone().multiplyScalar(0.3),
                    metalness: 0.3,
                    roughness: 0.7
                });
                
                // Create mesh
                const mesh = new THREE.Mesh(geometry, material);
                
                // Set position
                const [x, y, z] = position;
                mesh.position.set(x, y, z);
                
                // Scale based on power
                const powerScale = Math.min(2, Math.max(0.5, (power + 100) / 30));
                mesh.scale.set(powerScale, powerScale, powerScale);
                
                // Add to scene
                this.nodesGroup.add(mesh);
                
                // Store node data
                mesh.userData.nodeData = nodeData;
                this.nodes.set(id, { data: nodeData, mesh });
                
                return mesh;
            }
            
            // Add a hyperedge to the visualization
            addHyperedge(edgeData) {
                const { id, nodes, cardinality, strength } = edgeData;
                
                // Handle simple edges (cardinality = 2) with lines
                if (cardinality === 2) {
                    this.addSimpleEdge(edgeData);
                    return;
                }
                
                // Only show higher-order edges if option is enabled
                if (!this.options.showHigherOrderEdges) {
                    return;
                }
                
                // For higher order hyperedges, create lines between all node pairs
                return this.createHyperedgeLines(edgeData);
            }
            
            // Add a simple edge (cardinality = 2)
            addSimpleEdge(edgeData) {
                const { id, nodes, strength } = edgeData;
                
                const node1 = this.nodes.get(nodes[0]);
                const node2 = this.nodes.get(nodes[1]);
                
                if (!node1 || !node2) {
                    console.warn(`Skipping edge ${id} due to missing nodes`);
                    return;
                }
                
                const pos1 = node1.mesh.position;
                const pos2 = node2.mesh.position;
                
                // Create line geometry
                const points = [
                    new THREE.Vector3(pos1.x, pos1.y, pos1.z),
                    new THREE.Vector3(pos2.x, pos2.y, pos2.z)
                ];
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                
                // Determine color based on strength
                const strengthScale = Math.min(1, Math.max(0, (strength + 120) / 80));
                const hue = 0.3 + strengthScale * 0.4;
                const material = new THREE.LineBasicMaterial({ 
                    color: new THREE.Color().setHSL(hue, 1, 0.5),
                    transparent: true,
                    opacity: 0.7
                });
                
                // Create line
                const line = new THREE.Line(geometry, material);
                this.edgesGroup.add(line);
                
                // Store edge data
                line.userData.edgeData = edgeData;
                this.hyperedges.set(id, { data: edgeData, line });
                
                return line;
            }
            
            // Create lines connecting all nodes in a hyperedge
            createHyperedgeLines(edgeData) {
                const { id, nodes, strength } = edgeData;
                
                // Group for all lines in this hyperedge
                const linesGroup = new THREE.Group();
                
                // Create lines between each node pair
                for (let i = 0; i < nodes.length; i++) {
                    for (let j = i + 1; j < nodes.length; j++) {
                        const node1 = this.nodes.get(nodes[i]);
                        const node2 = this.nodes.get(nodes[j]);
                        
                        if (!node1 || !node2) continue;
                        
                        const pos1 = node1.mesh.position;
                        const pos2 = node2.mesh.position;
                        
                        const points = [
                            new THREE.Vector3(pos1.x, pos1.y, pos1.z),
                            new THREE.Vector3(pos2.x, pos2.y, pos2.z)
                        ];
                        const geometry = new THREE.BufferGeometry().setFromPoints(points);
                        
                        const material = new THREE.LineDashedMaterial({ 
                            color: new THREE.Color().setHSL(0.7, 1, 0.5),
                            transparent: true,
                            opacity: this.options.hyperedgeOpacity,
                            dashSize: 3,
                            gapSize: 1
                        });
                        
                        const line = new THREE.Line(geometry, material);
                        line.computeLineDistances();
                        linesGroup.add(line);
                    }
                }
                
                this.hyperedgesGroup.add(linesGroup);
                linesGroup.userData.edgeData = edgeData;
                this.hyperedges.set(id, { data: edgeData, mesh: linesGroup });
                
                return linesGroup;
            }
            
            // Map frequency to hue value
            mapFrequencyToHue(frequency) {
                if (frequency < 1) return 0.9;        // VLF/LF - Purple
                else if (frequency < 30) return 0.8;  // HF - Blue-purple
                else if (frequency < 300) return 0.6; // VHF - Blue
                else if (frequency < 3000) return 0.3;// UHF - Green
                else return 0.1;                      // SHF/EHF - Orange-red
            }
            
            // Clear the visualization
            clear() {
                // Remove all nodes
                while (this.nodesGroup.children.length > 0) {
                    const mesh = this.nodesGroup.children[0];
                    this.nodesGroup.remove(mesh);
                    if (mesh.geometry) mesh.geometry.dispose();
                    if (mesh.material) mesh.material.dispose();
                }
                
                // Remove all edges
                while (this.edgesGroup.children.length > 0) {
                    const line = this.edgesGroup.children[0];
                    this.edgesGroup.remove(line);
                    if (line.geometry) line.geometry.dispose();
                    if (line.material) line.material.dispose();
                }
                
                // Remove all hyperedges
                while (this.hyperedgesGroup.children.length > 0) {
                    const mesh = this.hyperedgesGroup.children[0];
                    this.hyperedgesGroup.remove(mesh);
                    
                    if (mesh instanceof THREE.Group) {
                        while (mesh.children.length > 0) {
                            const child = mesh.children[0];
                            mesh.remove(child);
                            if (child.geometry) child.geometry.dispose();
                            if (child.material) child.material.dispose();
                        }
                    } else {
                        if (mesh.geometry) mesh.geometry.dispose();
                        if (mesh.material) mesh.material.dispose();
                    }
                }
                
                this.nodes.clear();
                this.hyperedges.clear();
            }
            
            // Fit camera to show all nodes
            fitCameraToGraph() {
                if (this.nodes.size === 0) return;
                
                // Calculate bounding box
                const boundingBox = new THREE.Box3();
                this.nodesGroup.children.forEach(node => {
                    boundingBox.expandByPoint(node.position);
                });
                
                // Get center and size
                const center = new THREE.Vector3();
                boundingBox.getCenter(center);
                
                const size = new THREE.Vector3();
                boundingBox.getSize(size);
                
                // Calculate distance
                const maxDim = Math.max(size.x, size.y, size.z);
                const fov = this.camera.fov * (Math.PI / 180);
                let distance = (maxDim / 2) / Math.tan(fov / 2);
                distance *= 1.5; // Add margin
                
                // Position camera
                const direction = new THREE.Vector3(1, 1, 1).normalize();
                this.camera.position.copy(center).add(direction.multiplyScalar(distance));
                this.camera.lookAt(center);
                
                // Update controls
                if (this.controls) {
                    this.controls.target.copy(center);
                    this.controls.update();
                }
            }
            
            // Update statistics display
            updateStatistics(data) {
                if (!data || !data.metadata) {
                    document.getElementById('hypergraph-nodes').textContent = '0';
                    document.getElementById('hypergraph-edges').textContent = '0';
                    document.getElementById('max-cardinality').textContent = '0';
                    return;
                }
                
                const { node_count, hyperedge_count, max_cardinality } = data.metadata;
                
                document.getElementById('hypergraph-nodes').textContent = node_count || 0;
                document.getElementById('hypergraph-edges').textContent = hyperedge_count || 0;
                document.getElementById('max-cardinality').textContent = max_cardinality || 0;
                
                // Update central nodes
                if (data.central_nodes) {
                    let nodesHtml = '';
                    data.central_nodes.forEach((node, index) => {
                        nodesHtml += `
                            <div class="node-item">
                                <strong>${index + 1}. ${node.node_id}</strong><br>
                                Frequency: ${node.frequency.toFixed(2)} MHz<br>
                                Power: ${node.power.toFixed(2)} dBm<br>
                                Centrality: ${node.centrality.toFixed(4)}
                            </div>
                        `;
                    });
                    document.getElementById('central-nodes-list').innerHTML = nodesHtml;
                } else {
                    document.getElementById('central-nodes-list').innerHTML = 'No centrality data available';
                }
            }
            
            // Nmap integration methods
            async performNmapScan(targetNetwork, options = {}) {
                if (!this.nmapScanner) {
                    console.error('Nmap scanner not initialized');
                    return null;
                }
                
                try {
                    const result = await this.nmapScanner.performNetworkScan(targetNetwork, options);
                    return result;
                } catch (error) {
                    console.error('Nmap scan failed:', error);
                    throw error;
                }
            }
            
            // Add nmap node with special styling
            addNmapNode(nodeData) {
                const node = this.addNode(nodeData);
                
                // Special styling for nmap-discovered nodes
                if (node && nodeData.type === 'network_host') {
                    // Add pulsing animation for hosts with RF correlation
                    if (nodeData.properties && nodeData.properties.rfDetected) {
                        this.addRfPulseAnimation(node, nodeData.freq);
                    }
                    
                    // Add vulnerability highlighting
                    if (nodeData.properties && nodeData.properties.vulnerabilities) {
                        this.addVulnerabilityHighlight(node);
                    }
                    
                    // Store in nmap nodes map
                    this.nmapNodes.set(nodeData.id, {
                        data: nodeData,
                        mesh: node,
                        scanTime: new Date().toISOString()
                    });
                }
                
                return node;
            }
            
            // Add RF pulse animation to nodes
            addRfPulseAnimation(node, frequency) {
                if (!node || !node.material) return;
                
                const originalEmissive = node.material.emissive.clone();
                const pulseSpeed = Math.max(0.5, frequency / 1000); // Pulse based on frequency
                
                const animate = () => {
                    const time = Date.now() * 0.001;
                    const pulse = (Math.sin(time * pulseSpeed) + 1) * 0.5;
                    
                    node.material.emissive.copy(originalEmissive).multiplyScalar(pulse);
                    
                    if (this.nmapNodes.has(node.userData.nodeData?.id)) {
                        requestAnimationFrame(animate);
                    }
                };
                
                animate();
            }
            
            // Add vulnerability highlighting to nodes
            addVulnerabilityHighlight(node) {
                if (!node || !node.material) return;
                
                // Create red warning outline
                const outlineGeometry = new THREE.SphereGeometry(this.options.nodeSize * 1.3);
                const outlineMaterial = new THREE.MeshBasicMaterial({
                    color: 0xff0000,
                    transparent: true,
                    opacity: 0.3,
                    side: THREE.BackSide
                });
                
                const outline = new THREE.Mesh(outlineGeometry, outlineMaterial);
                node.add(outline);
            }
            
            // Get nmap scan results
            getNmapScanResults() {
                return this.nmapScanner ? this.nmapScanner.getScanHistory() : [];
            }
            
            // Clear nmap-specific visualizations
            clearNmapData() {
                // Clear nmap nodes
                this.nmapNodes.forEach((nodeInfo, nodeId) => {
                    const nodeData = this.nodes.get(nodeId);
                    if (nodeData && nodeData.mesh) {
                        this.nodesGroup.remove(nodeData.mesh);
                        if (nodeData.mesh.geometry) nodeData.mesh.geometry.dispose();
                        if (nodeData.mesh.material) nodeData.mesh.material.dispose();
                    }
                });
                this.nmapNodes.clear();
                
                // Clear nmap edges
                this.nmapEdges.forEach((edgeInfo, edgeId) => {
                    const edgeData = this.hyperedges.get(edgeId);
                    if (edgeData && edgeData.line) {
                        this.edgesGroup.remove(edgeData.line);
                        if (edgeData.line.geometry) edgeData.line.geometry.dispose();
                        if (edgeData.line.material) edgeData.line.material.dispose();
                    }
                });
                this.nmapEdges.clear();
                
                console.log('Cleared nmap visualization data');
            }
            
            // Highlight network path between hosts
            highlightNetworkPath(hostPath, pathType = 'service') {
                const pathColor = pathType === 'vulnerability' ? 0xff4444 : 
                                pathType === 'rf_correlation' ? 0x44ff44 : 0x4444ff;
                
                for (let i = 0; i < hostPath.length - 1; i++) {
                    const sourceId = `host_${hostPath[i].replace(/\./g, '_')}`;
                    const targetId = `host_${hostPath[i + 1].replace(/\./g, '_')}`;
                    
                    const sourceNode = this.nodes.get(sourceId);
                    const targetNode = this.nodes.get(targetId);
                    
                    if (sourceNode && targetNode) {
                        const points = [
                            sourceNode.mesh.position.clone(),
                            targetNode.mesh.position.clone()
                        ];
                        
                        const geometry = new THREE.BufferGeometry().setFromPoints(points);
                        const material = new THREE.LineBasicMaterial({
                            color: pathColor,
                            linewidth: 3,
                            transparent: true,
                            opacity: 0.8
                        });
                        
                        const line = new THREE.Line(geometry, material);
                        this.scene.add(line);
                        
                        // Auto-remove after 5 seconds
                        setTimeout(() => {
                            this.scene.remove(line);
                            if (geometry) geometry.dispose();
                            if (material) material.dispose();
                        }, 5000);
                    }
                }
            }
            
            // Handle window resize
            onWindowResize() {
                const width = this.container.clientWidth || 800;
                const height = this.container.clientHeight || 600;
                
                this.camera.aspect = width / height;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(width, height);
            }
            
            // Animation loop
            animate() {
                requestAnimationFrame(this.animate.bind(this));
                
                // Update controls
                if (this.controls) {
                    this.controls.update();
                }
                
                // Render scene
                this.renderer.render(this.scene, this.camera);
            }
            
            // Toggle methods
            toggleHigherOrderEdges(show) {
                this.options.showHigherOrderEdges = show;
                this.hyperedgesGroup.visible = show;
            }
            
            setHyperedgeOpacity(opacity) {
                this.options.hyperedgeOpacity = opacity;
                this.hyperedgesGroup.children.forEach(mesh => {
                    if (mesh.material) {
                        mesh.material.opacity = opacity;
                    } else if (mesh instanceof THREE.Group) {
                        mesh.children.forEach(child => {
                            if (child.material) {
                                child.material.opacity = opacity;
                            }
                        });
                    }
                });
            }
            
            toggleColorByFrequency(colorByFreq) {
                this.options.colorByFrequency = colorByFreq;
                
                this.nodes.forEach((nodeObj, id) => {
                    const { mesh, data } = nodeObj;
                    
                    let color;
                    if (colorByFreq) {
                        const hue = this.mapFrequencyToHue(data.freq);
                        color = new THREE.Color().setHSL(hue, 1, 0.5);
                    } else {
                        const powerScale = Math.min(1, Math.max(0, (data.power + 100) / 60));
                        color = new THREE.Color().setHSL(0.6, 1, powerScale);
                    }
                    
                    mesh.material.color = color;
                    mesh.material.emissive = color.clone().multiplyScalar(0.3);
                    mesh.material.needsUpdate = true;
                });
            }
        }
        
        // RF Hypergraph Visualization Management
        let hypergraphVisualizer = null;
        let hypergraphCollecting = false;
        let hypergraphCollectionInterval = null;
        let hypergraphStartTime = 0;
        
        // Legacy hypergraph visualization removed - using Cesium 3D integration instead
        
        // Legacy hypergraph controls removed - using integrated Cesium controls instead
            
            // Reset view button
            const resetViewBtn = document.getElementById('reset-hypergraph-view');
            if (resetViewBtn) {
                resetViewBtn.addEventListener('click', () => {
                    if (hypergraphVisualizer) {
                        hypergraphVisualizer.fitCameraToGraph();
                    }
                });
            }
            
            // Generate data button
            const generateDataBtn = document.getElementById('generate-hypergraph-data');
            if (generateDataBtn) {
                generateDataBtn.addEventListener('click', () => {
                    generateTestHypergraphData();  // Use the new Cesium-based function
                });
            }

            // PCAP Simulation button (Slow-Motion Loop)
            const pcapSimBtn = document.getElementById('simulate-pcap-ingest');
            let pcapSimRunning = false;
            let pcapSimTimeouts = [];

            if (pcapSimBtn) {
                pcapSimBtn.addEventListener('click', async () => {
                     if (pcapSimRunning) {
                         // Stop Simulation
                         pcapSimRunning = false;
                         pcapSimTimeouts.forEach(clearTimeout);
                         pcapSimTimeouts = [];
                         pcapSimBtn.innerText = "Run PCAP Simulation";
                         pcapSimBtn.style.background = "#4a9eff"; 
                         addConsoleMessage('Simulation Stopped', 'response');
                         return;
                     }

                     // Start Simulation
                     pcapSimRunning = true;
                     pcapSimBtn.innerText = "Stop Simulation";
                     pcapSimBtn.style.background = "#e74c3c"; // Red
                     addConsoleMessage('Starting Slow-Motion PCAP Loop...', 'response');
                     
                     // Helper to schedule and track timeouts
                     const schedule = (fn, delay) => {
                         const id = setTimeout(fn, delay);
                         pcapSimTimeouts.push(id);
                     };

                     const runSimulationLoop = () => {
                         if (!pcapSimRunning) return;

                         // 1. Define Mock Nodes (US, AU, MA, CA)
                         const events = [
                            // -- Public IP Nodes --
                            { ip: "142.250.190.46", lat: 37.422, lon: -122.084, city: "Mountain View", country: "US", asn: 15169, org: "Google LLC" },
                            { ip: "1.1.1.1", lat: -33.8688, lon: 151.2093, city: "Sydney", country: "AU", asn: 13335, org: "Cloudflare, Inc." },
                            { ip: "140.82.112.4", lat: 37.7749, lon: -122.4194, city: "San Francisco", country: "US", asn: 36459, org: "GitHub, Inc." },
                            { ip: "8.8.8.8", lat: 37.422, lon: -122.084, city: "Mountain View", country: "US", asn: 15169, org: "Google LLC" },
                            { ip: "93.184.216.34", lat: 42.1508, lon: -70.8228, city: "Norwell", country: "US", asn: 15133, org: "EdgeCast" },
                            { ip: "172.67.198.10", lat: 37.7749, lon: -122.4194, city: "San Francisco", country: "US", asn: 13335, org: "Cloudflare, Inc." },
                            
                            // -- Traffic Flows --
                            { type: 'flow', src: "192.168.1.50", dst: "142.250.190.46", bytes: 154000, proto: {"TLS": 100} },
                            { type: 'flow', src: "192.168.1.50", dst: "172.67.198.10", bytes: 850000, proto: {"QUIC": 900} },
                            { type: 'flow', src: "192.168.1.50", dst: "140.82.112.4", bytes: 4500, proto: {"SSH": 30} }
                         ];
                         
                         const sensorId = "SENSOR-VM-172-234-197-23";
                         
                         let delay = 0;
                         const slowMo = 2.5; // Slow down factor
                         
                         // A. Locations
                         for (let e of events) {
                             if (e.type === 'flow') continue;
                             
                             schedule(() => {
                                if (!pcapSimRunning) return;
                                const payload = {
                                    ip: e.ip,
                                    geo: { lat: e.lat, lon: e.lon, city: e.city, country: e.country },
                                    asn: { asn: e.asn, org: e.org }
                                };
                                
                                fetch(`/api/sensors/${sensorId}/activity`, {
                                    method: 'POST', 
                                    headers: {'Content-Type': 'application/json'},
                                    body: JSON.stringify({ kind: 'geoip_resolved', payload: payload })
                                }).catch(e => {});

                                if(window.FusionVisualization) window.FusionVisualization.updateGeoNode(payload);
                             }, delay);
                             delay += 200 * slowMo; // Slower node appearance
                         }
                         
                         // B. Flows
                         for (let e of events) {
                             if (e.type !== 'flow') continue;
                             
                             schedule(() => {
                                 if (!pcapSimRunning) return;
                                 const payload = {
                                     src_ip: e.src, 
                                     dst_ip: e.dst,
                                     bytes: e.bytes,
                                     protocol_hist: e.proto,
                                     timestamp: Date.now()/1000
                                 };
                                 
                                 fetch(`/api/sensors/${sensorId}/activity`, {
                                    method: 'POST', 
                                    headers: {'Content-Type': 'application/json'},
                                    body: JSON.stringify({ kind: 'ndpi_flow_aggregate', payload: payload })
                                 }).catch(e => {});
                                 
                                 if(window.FusionVisualization) window.FusionVisualization.drawFlow(sensorId, payload);
                             }, delay);
                             delay += 500 * slowMo; // Slower flow drawing
                         }
                         
                         // C. Loop
                         schedule(() => {
                             if (pcapSimRunning) {
                                 runSimulationLoop(); // Recursion
                             }
                         }, delay + 2000);
                     };

                     // Desirable Camera Function: Recon Entity Track
                     // Instead of flyTo (which may be ignored or static), we LOCK the camera to the Source Sensor
                     const viewer = window.viewer;
                     if (viewer) {
                         // 1. Ensure Sensor Entity Exists for Tracking
                         const sensorPos = Cesium.Cartesian3.fromDegrees(-118.2437, 34.0522, 100);
                         let sensorEntity = viewer.entities.getById('sim-sensor-origin');
                         
                         if (!sensorEntity) {
                             sensorEntity = viewer.entities.add({
                                 id: 'sim-sensor-origin',
                                 position: sensorPos,
                                 point: { 
                                     pixelSize: 12, 
                                     color: Cesium.Color.RED,
                                     outlineColor: Cesium.Color.WHITE,
                                     outlineWidth: 2
                                 },
                                 label: { 
                                     text: "SENSOR (Target)", 
                                     font: '12px monospace',
                                     fillColor: Cesium.Color.RED,
                                     style: Cesium.LabelStyle.FILL_AND_OUTLINE,
                                     verticalOrigin: Cesium.VerticalOrigin.BOTTOM,
                                     pixelOffset: new Cesium.Cartesian2(0, -15)
                                 }
                             });
                         }
                         
                         // 2. Track It (Recon Style)
                         viewer.trackedEntity = sensorEntity;
                         addConsoleMessage('Camera Tracking Active: Sensor Node', 'info');
                     }
                     
                     // Start Loop
                     runSimulationLoop();
                });
            }
            
            // Start/stop collection buttons
            const startCollectionBtn = document.getElementById('start-hypergraph-collection');
            const stopCollectionBtn = document.getElementById('stop-hypergraph-collection');
            
            if (startCollectionBtn) {
                startCollectionBtn.addEventListener('click', startHypergraphCollection);
            }
            if (stopCollectionBtn) {
                stopCollectionBtn.addEventListener('click', stopHypergraphCollection);
            }
            
            // Nmap control event listeners
            const startNmapBtn = document.getElementById('start-nmap-scan');
            const clearNmapBtn = document.getElementById('clear-nmap-data');
            const targetNetworkInput = document.getElementById('nmap-target-network');
            
            if (startNmapBtn) {
                startNmapBtn.addEventListener('click', async () => {
                    await performNmapHypergraphScan();
                });
            }
            
            if (clearNmapBtn) {
                clearNmapBtn.addEventListener('click', () => {
                    clearNmapHypergraphData();
                });
            }
            
            // Set default network target
            if (targetNetworkInput) {
                targetNetworkInput.value = '192.168.1.0/24';
            }
        
        // Legacy generateHypergraphTestData removed - using generateTestHypergraphData instead
        
        // Start collecting hypergraph data
        function startHypergraphCollection() {
            if (hypergraphCollecting) return;
            
            hypergraphCollecting = true;
            hypergraphStartTime = Date.now();
            
            // Update UI
            const startBtn = document.getElementById('start-hypergraph-collection');
            const stopBtn = document.getElementById('stop-hypergraph-collection');
            if (startBtn) startBtn.disabled = true;
            if (stopBtn) stopBtn.disabled = false;
            
            // Start collection interval
            hypergraphCollectionInterval = setInterval(collectHypergraphDataPoint, 3000);
            
            // Initial collection
            collectHypergraphDataPoint();
            
            addConsoleMessage('Started RF hypergraph data collection', 'command');
        }
        
        // Stop collecting hypergraph data
        function stopHypergraphCollection() {
            if (!hypergraphCollecting) return;
            
            hypergraphCollecting = false;
            
            // Clear interval
            clearInterval(hypergraphCollectionInterval);
            
            // Update UI
            const startBtn = document.getElementById('start-hypergraph-collection');
            const stopBtn = document.getElementById('stop-hypergraph-collection');
            if (startBtn) startBtn.disabled = false;
            if (stopBtn) stopBtn.disabled = true;
            
            addConsoleMessage('Stopped RF hypergraph data collection', 'response');
        }
        
        // Collect a single hypergraph data point
        function collectHypergraphDataPoint() {
            const elapsedSec = Math.floor((Date.now() - hypergraphStartTime) / 1000);
            const minutes = Math.floor(elapsedSec / 60);
            const seconds = elapsedSec % 60;
            
            // Update collection time
            const collectionTimeEl = document.getElementById('collection-time');
            if (collectionTimeEl) {
                collectionTimeEl.textContent = `${minutes}m ${seconds}s`;
            }
            
            // Generate new data periodically
            if (elapsedSec % 15 === 0) { // Every 15 seconds
                const nodeCount = 20 + Math.floor(Math.random() * 20); // 20-40 nodes
                const newData = generateFallbackHypergraphData(nodeCount);
                
                if (hypergraphVisualizer) {
                    hypergraphVisualizer.loadData(newData);
                }
                
                addConsoleMessage(`Updated hypergraph with ${nodeCount} nodes`, 'response');
            }
        }
        
        // Generate fallback hypergraph data
        function generateFallbackHypergraphData(nodeCount) {
            const nodes = [];
            const hyperedges = [];
            
            // Generate random nodes
            for (let i = 0; i < nodeCount; i++) {
                const x = (Math.random() - 0.5) * 800;
                const y = (Math.random() - 0.5) * 800;
                const z = Math.random() * 150;
                
                // Various frequency bands
                let freq;
                const band = Math.random();
                if (band < 0.2) freq = 0.1 + Math.random() * 0.9;      // VLF/LF
                else if (band < 0.3) freq = 3 + Math.random() * 27;     // HF
                else if (band < 0.5) freq = 30 + Math.random() * 270;   // VHF
                else if (band < 0.8) freq = 300 + Math.random() * 2700; // UHF
                else freq = 3000 + Math.random() * 27000;               // SHF
                
                const power = -90 + Math.random() * 50;
                
                nodes.push({
                    id: `node_${i}`,
                    position: [x, y, z],
                    freq: freq,
                    power: power,
                    edges: []
                });
            }
            
            // Generate pairwise edges
            let edgeId = 0;
            for (let i = 0; i < nodeCount; i++) {
                const edgeCount = 1 + Math.floor(Math.random() * 4);
                
                for (let j = 0; j < edgeCount; j++) {
                    let targetIdx;
                    do {
                        targetIdx = Math.floor(Math.random() * nodeCount);
                    } while (targetIdx === i);
                    
                    const node1 = nodes[i];
                    const node2 = nodes[targetIdx];
                    
                    const dx = node1.position[0] - node2.position[0];
                    const dy = node1.position[1] - node2.position[1];
                    const dz = node1.position[2] - node2.position[2];
                    
                    const distance = Math.sqrt(dx*dx + dy*dy + dz*dz);
                    
                    if (distance < 400) {
                        const strength = -60 - (distance / 8);
                        
                        hyperedges.push({
                            id: edgeId++,
                            nodes: [node1.id, node2.id],
                            cardinality: 2,
                            strength: strength
                        });
                        
                        node1.edges.push(edgeId - 1);
                        node2.edges.push(edgeId - 1);
                    }
                }
            }
            
            // Generate higher-order hyperedges
            const maxCardinality = Math.min(6, nodeCount - 1);
            const higherOrderCount = 5 + Math.floor(Math.random() * 10);
            
            for (let i = 0; i < higherOrderCount; i++) {
                const cardinality = 3 + Math.floor(Math.random() * (maxCardinality - 2));
                
                const nodeIndices = new Set();
                const centerIdx = Math.floor(Math.random() * nodeCount);
                nodeIndices.add(centerIdx);
                
                const centerNode = nodes[centerIdx];
                const potentialNodes = nodes
                    .map((node, idx) => {
                        if (idx === centerIdx) return { idx, distance: 0 };
                        
                        const dx = node.position[0] - centerNode.position[0];
                        const dy = node.position[1] - centerNode.position[1];
                        const dz = node.position[2] - centerNode.position[2];
                        
                        return { idx, distance: Math.sqrt(dx*dx + dy*dy + dz*dz) };
                    })
                    .filter(n => n.distance < 300)
                    .sort((a, b) => a.distance - b.distance);
                
                for (let j = 0; j < Math.min(cardinality - 1, potentialNodes.length); j++) {
                    nodeIndices.add(potentialNodes[j].idx);
                }
                
                if (nodeIndices.size >= 3) {
                    const nodeIds = Array.from(nodeIndices).map(idx => nodes[idx].id);
                    
                    const avgPower = Array.from(nodeIndices)
                        .map(idx => nodes[idx].power)
                        .reduce((a, b) => a + b, 0) / nodeIndices.size;
                    
                    hyperedges.push({
                        id: edgeId++,
                        nodes: nodeIds,
                        cardinality: nodeIds.length,
                        strength: avgPower
                    });
                    
                    nodeIds.forEach(nodeId => {
                        const node = nodes.find(n => n.id === nodeId);
                        if (node) node.edges.push(edgeId - 1);
                    });
                }
            }
            
            // Calculate node centrality
            const centralNodes = nodes.map(node => {
                const centralityScore = node.edges.reduce((sum, edgeId) => {
                    const edge = hyperedges.find(e => e.id === edgeId);
                    if (!edge) return sum;
                    return sum + (edge.strength + 100) / edge.cardinality;
                }, 0);
                
                return {
                    node_id: node.id,
                    frequency: node.freq,
                    power: node.power,
                    position: node.position,
                    centrality: centralityScore,
                    associated_hyperedges: node.edges.length
                };
            })
            .sort((a, b) => b.centrality - a.centrality)
            .slice(0, 5);
            
            // Compile metadata
            const cardinalityDist = {};
            hyperedges.forEach(edge => {
                cardinalityDist[edge.cardinality] = (cardinalityDist[edge.cardinality] || 0) + 1;
            });
            
            return {
                nodes,
                hyperedges,
                central_nodes: centralNodes,
                metadata: {
                    node_count: nodes.length,
                    hyperedge_count: hyperedges.length,
                    max_cardinality: Math.max(...hyperedges.map(e => e.cardinality)),
                    cardinality_distribution: cardinalityDist,
                    timestamp: Date.now()
                }
            };
        }
        
        // Nmap hypergraph integration functions
        async function performNmapHypergraphScan() {
            if (!hypergraphVisualizer) {
                showNotification('Error', 'Hypergraph visualizer not initialized', 'error');
                return;
            }
            
            // CRITICAL: Free camera from any previous tracking state before starting scan
            // This ensures subsequent flyTo operations can properly reset the camera
            if (typeof ensureCameraFree === 'function') {
                ensureCameraFree();
            } else if (viewer && viewer.camera) {
                viewer.camera.lookAtTransform(Cesium.Matrix4.IDENTITY);
                viewer.trackedEntity = undefined;
                const ctrl = viewer.scene.screenSpaceCameraController;
                ctrl.enableRotate = ctrl.enableTilt = ctrl.enableZoom = ctrl.enableTranslate = ctrl.enableLook = true;
            }
            
            // Get scan parameters from UI
            const targetNetwork = document.getElementById('nmap-target-network')?.value || '192.168.1.0/24';
            const scanType = document.getElementById('nmap-scan-type')?.value || 'SYN';
            const serviceDetection = document.getElementById('nmap-service-detection')?.checked || false;
            const osDetection = document.getElementById('nmap-os-detection')?.checked || false;
            const rfCorrelation = document.getElementById('nmap-rf-correlation')?.checked || false;
            
            const statusElement = document.getElementById('nmap-status');
            const progressElement = document.getElementById('nmap-progress');
            const progressBar = document.getElementById('nmap-progress-bar');
            const startButton = document.getElementById('start-nmap-scan');
            
            try {
                // Update UI to show scanning state
                if (statusElement) statusElement.textContent = `Scanning ${targetNetwork}...`;
                if (progressElement) progressElement.style.display = 'block';
                if (startButton) startButton.disabled = true;
                
                // Simulate progress updates
                let progress = 0;
                const progressInterval = setInterval(() => {
                    progress += Math.random() * 15;
                    if (progress > 100) progress = 100;
                    if (progressBar) progressBar.style.width = `${progress}%`;
                }, 200);
                
                // Configure scan options
                const scanOptions = {
                    scanType: scanType,
                    serviceDetection: serviceDetection,
                    osDetection: osDetection,
                    rfCorrelation: rfCorrelation,
                    timing: 'T3',
                    verbose: true
                };
                
                // Perform the scan
                console.log('Starting nmap hypergraph scan:', { targetNetwork, scanOptions });
                addConsoleMessage(`Starting nmap scan on ${targetNetwork}`, 'command');
                
                // Geolocate target and fly camera to location
                try {
                    await geolocateAndFlyToTarget(targetNetwork);
                } catch (geoError) {
                    console.warn('Could not geolocate target:', geoError);
                }
                
                const result = await hypergraphVisualizer.performNmapScan(targetNetwork, scanOptions);
                
                // Extract host counts from various possible response structures
                const hostsDiscovered = result.hypergraphData?.metadata?.totalHosts 
                    || result.hypergraphData?.nodes?.length 
                    || result.hostsDiscovered 
                    || 0;
                const rfCorrelatedHosts = result.hypergraphData?.metadata?.rfCorrelatedHosts || 0;
                
                // Log nmap scan metrics
                if (window.logMetric) {
                    window.logMetric('nmap', 'scan_completed', 1);
                    window.logMetric('nmap', 'hosts_discovered', hostsDiscovered);
                    window.logMetric('nmap', 'rf_correlated_hosts', rfCorrelatedHosts);
                }
                if (window.logInteraction) {
                    window.logInteraction('nmap_scan', targetNetwork, { scanType, hosts: hostsDiscovered });
                }
                
                // Clear progress animation
                clearInterval(progressInterval);
                if (progressBar) progressBar.style.width = '100%';
                
                // Update UI
                if (statusElement) {
                    statusElement.innerHTML = `Scan complete: ${hostsDiscovered} hosts discovered`;
                }
                
                // Hide progress after a delay
                setTimeout(() => {
                    if (progressElement) progressElement.style.display = 'none';
                    if (progressBar) progressBar.style.width = '0%';
                }, 2000);
                
                // Show detailed results
                showNmapScanResults(result);
                
                // CRITICAL: Reset camera transform to re-enable user control after scan
                // This ensures the camera is freed no matter how the scan finishes
                if (typeof resetCameraTransform === 'function') {
                    resetCameraTransform();
                    console.log('[Nmap] Camera transform reset after scan complete');
                } else if (viewer && viewer.camera) {
                    // Fallback if resetCameraTransform not available
                    viewer.camera.lookAtTransform(Cesium.Matrix4.IDENTITY);
                    viewer.trackedEntity = undefined;
                    const controller = viewer.scene.screenSpaceCameraController;
                    controller.enableRotate = true;
                    controller.enableTilt = true;
                    controller.enableZoom = true;
                    controller.enableTranslate = true;
                    controller.enableLook = true;
                }
                
                addConsoleMessage(`Nmap scan complete. Found ${hostsDiscovered} hosts, ${rfCorrelatedHosts} with RF signatures`, 'response');
                
            } catch (error) {
                console.error('Nmap scan failed:', error);
                
                // Update UI on error
                if (statusElement) statusElement.textContent = `Scan failed: ${error.message}`;
                if (progressElement) progressElement.style.display = 'none';
                
                addConsoleMessage(`Nmap scan failed: ${error.message}`, 'alert');
                showNotification('Scan Failed', `Nmap scan failed: ${error.message}`, 'error');
            } finally {
                if (startButton) startButton.disabled = false;
            }
        }
        
        // Geolocate target IP/domain and fly camera to location
        async function geolocateAndFlyToTarget(target) {
            if (!viewer) {
                console.warn('[Nmap] Viewer not available for camera jump');
                return null;
            }
            
            // Extract IP or domain from target (handle CIDR notation)
            let targetHost = target.split('/')[0];
            
            // Skip private network ranges - they don't have public geolocation
            const privatePatterns = [
                /^192\.168\./,
                /^10\./,
                /^172\.(1[6-9]|2[0-9]|3[0-1])\./,
                /^127\./,
                /^localhost$/i
            ];
            
            if (privatePatterns.some(p => p.test(targetHost))) {
                addConsoleMessage(`Private network detected (${targetHost}) - using default location`, 'info');
                // Use configured default or a reasonable fallback
                const defaultLoc = { lat: 37.7749, lon: -122.4194 }; // San Francisco default
                return defaultLoc;
            }
            
            try {
                // Try our backend geolocation API first
                let geoData = null;
                
                try {
                    const response = await fetch(`/api/recon/geolocate?target=${encodeURIComponent(targetHost)}`);
                    if (response.ok) {
                        geoData = await response.json();
                    }
                } catch (e) {
                    console.warn('[Nmap] Backend geolocate unavailable, trying fallback');
                }
                
                // Fallback to ip-api.com which handles hostnames directly
                if (!geoData || !geoData.lat) {
                    try {
                        // ip-api.com supports both IP addresses and hostnames
                        const ipApiResponse = await fetch(`http://ip-api.com/json/${targetHost}`);
                        if (ipApiResponse.ok) {
                            const ipData = await ipApiResponse.json();
                            if (ipData.status === 'success' && ipData.lat && ipData.lon) {
                                geoData = {
                                    lat: ipData.lat,
                                    lon: ipData.lon,
                                    city: ipData.city,
                                    region: ipData.regionName,
                                    country: ipData.country,
                                    org: ipData.org || ipData.isp
                                };
                            }
                        }
                    } catch (e) {
                        console.warn('[Nmap] ip-api.com geolocation failed, trying ipinfo.io');
                    }
                }
                
                // Secondary fallback to ipinfo.io (requires IP, not hostname)
                if (!geoData || !geoData.lat) {
                    try {
                        // Try ipinfo.io - works best with IP addresses
                        const ipInfoResponse = await fetch(`https://ipinfo.io/${targetHost}/json`);
                        if (ipInfoResponse.ok) {
                            const ipData = await ipInfoResponse.json();
                            if (ipData.loc) {
                                const [lat, lon] = ipData.loc.split(',').map(Number);
                                geoData = {
                                    lat: lat,
                                    lon: lon,
                                    city: ipData.city,
                                    region: ipData.region,
                                    country: ipData.country,
                                    org: ipData.org
                                };
                            }
                        }
                    } catch (e) {
                        console.warn('[Nmap] External geolocation failed:', e);
                    }
                }
                
                // Final fallback: use known location for scanme.nmap.org
                if (!geoData || !geoData.lat) {
                    const knownHosts = {
                        'scanme.nmap.org': { lat: 45.5234, lon: -122.6762, city: 'Portland', country: 'US' },
                        'nmap.org': { lat: 45.5234, lon: -122.6762, city: 'Portland', country: 'US' },
                        'google.com': { lat: 37.4220, lon: -122.0841, city: 'Mountain View', country: 'US' }
                    };
                    const hostLower = targetHost.toLowerCase();
                    if (knownHosts[hostLower]) {
                        geoData = knownHosts[hostLower];
                        addConsoleMessage(`Using known location for ${targetHost}`, 'info');
                    }
                }
                
                if (geoData && geoData.lat && geoData.lon) {
                    addConsoleMessage(`Target located: ${geoData.city || 'Unknown'}, ${geoData.country || 'Unknown'} (${geoData.lat.toFixed(2)}, ${geoData.lon.toFixed(2)})`, 'info');
                    
                    // Fly camera to target location using flyToWithReset for automatic camera unlock
                    const altitude = 500000; // 500km altitude for regional view
                    const destination = Cesium.Cartesian3.fromDegrees(geoData.lon, geoData.lat, altitude);

                    // Debug: log geoData and viewer readiness before commanding camera
                    try {
                        console.log('[Nmap] Preparing camera flyTo for', { city: geoData.city, lat: geoData.lat, lon: geoData.lon, altitude: altitude });
                        console.log('[Nmap] viewer ready:', !!viewer, 'camera ready:', !!(viewer && viewer.camera));
                    } catch (dbgErr) {
                        console.debug('[Nmap] Debug log failed:', dbgErr);
                    }

                    // DRASTIC MEASURE: Turn NMAP target into a Recon Entity and TRACK IT
                    if (window.AutoReconVisualization && window.AutoReconVisualization.entities) {
                        try {
                            console.log('[Nmap] promoting target to Recon Entity...');
                            const nmapId = 'NMAP-' + targetHost.replace(/[^a-zA-Z0-9]/g, '').substring(0, 12);
                            
                            const nmapEntity = {
                                entity_id: nmapId,
                                name: targetHost,
                                disposition: 'UNKNOWN',
                                threat_level: 'UNKNOWN',
                                type: 'NMAP_TARGET',
                                location: {
                                    lat: geoData.lat,
                                    lon: geoData.lon,
                                    altitude_m: 500 // Low altitude for detail
                                },
                                velocity: { heading_deg: 0, speed_kts: 0 },
                                last_seen: new Date().toISOString()
                            };
                            
                            // 1. Inject entity into global store (Optimistic UI)
                            window.AutoReconVisualization.entities[nmapId] = nmapEntity;
                            
                            // 2. Persist to Server (Async/Low Priority)
                            fetch('/api/recon/entity', {
                                method: 'POST',
                                headers: {'Content-Type': 'application/json'},
                                body: JSON.stringify(nmapEntity)
                            }).then(r => r.json()).then(d => {
                                if(d.status === 'ok') console.log('[Nmap] Entity persisted to DB:', nmapId);
                            }).catch(e => console.warn('[Nmap] Persistence failed:', e));

                        // 3. Create the visual marker
                        if (typeof window.AutoReconVisualization.addEntityMarker === 'function') {
                            // Check if entity already exists to avoid duplicate ID error
                            const reconId = `recon_entity_${nmapId}`;
                            if (viewer.entities.getById(reconId)) {
                                console.log('[Nmap] Entity marker already exists:', nmapId);
                            } else {
                                window.AutoReconVisualization.addEntityMarker(nmapEntity);
                            }
                        }
                            
                        // 4. Command the "Exemplary" Track function
                        if (typeof window.AutoReconVisualization.flyToEntity === 'function') {
                            addConsoleMessage(`Tracking NMAP Target via Recon: ${targetHost}`, 'success');
                            window.AutoReconVisualization.flyToEntity(nmapId);
                                
                            // Immediately ensure controls are unlocked in case flyToEntity locks them
                            if (viewer.scene && viewer.scene.screenSpaceCameraController) {
                                viewer.trackedEntity = undefined;
                                const c = viewer.scene.screenSpaceCameraController;
                                c.enableRotate = c.enableTilt = c.enableZoom = c.enableTranslate = c.enableLook = true;
                            }

                            // Return early, delegation successful
                            return geoData;
                        }
                        } catch (reconErr) {
                            console.error('[Nmap] Failed to promote to Recon Entity:', reconErr);
                        }
                    }

                    // CRITICAL FIX: Exemplary camera logic from AutoReconVisualization.flyToEntity
                    if (viewer) {
                        try {
                            console.log('[Nmap] Unlocking camera before flight...');
                            
                            // 1. Force unlock
                            viewer.camera.cancelFlight();
                            viewer.camera.lookAtTransform(Cesium.Matrix4.IDENTITY);
                            viewer.trackedEntity = undefined;
                            viewer.selectedEntity = undefined;
                            
                            if (viewer.scene && viewer.scene.screenSpaceCameraController) {
                                const ctrlPre = viewer.scene.screenSpaceCameraController;
                                ctrlPre.enableRotate = ctrlPre.enableTilt = ctrlPre.enableZoom = ctrlPre.enableTranslate = ctrlPre.enableLook = true;
                            }

                            // 2. Direct Camera Flight
                            viewer.camera.flyTo({
                                destination: destination,
                                orientation: {
                                    heading: viewer.camera.heading, // Maintain heading
                                    pitch: Cesium.Math.toRadians(-45),
                                    roll: 0
                                },
                                duration: 3.0,
                                complete: function() {
                                    // Trigger altitude changed event to update hierarchical layers
                                    if (window.HierarchicalRenderManager) {
                                        HierarchicalRenderManager.updateVisibilityForAltitude();
                                    }
                                    addConsoleMessage(`Camera positioned over ${geoData.city || target}`, 'info');
                                    
                                    // 3. Reset transform and unlock again in callback
                                    try {
                        if (viewer && viewer.camera) {
                            viewer.camera.lookAtTransform(Cesium.Matrix4.IDENTITY);
                            viewer.trackedEntity = undefined;
                            if (viewer.scene && viewer.scene.screenSpaceCameraController) {
                                    const c = viewer.scene.screenSpaceCameraController;
                                    c.enableRotate = c.enableTilt = c.enableZoom = c.enableTranslate = c.enableLook = true;
                            }
                            
                            const cartoNow = Cesium.Cartographic.fromCartesian(viewer.camera.position);
                            const latNow = Cesium.Math.toDegrees(cartoNow.latitude);
                            const lonNow = Cesium.Math.toDegrees(cartoNow.longitude);
                            console.log('[Nmap] Camera arrived', { lat: latNow.toFixed(3), lon: lonNow.toFixed(3) });
                        }
                                        if (viewer && viewer.scene) {
                                            viewer.scene.requestRender();
                                        }
                                    } catch (e) {
                                        console.warn('[Nmap] Post-flight reset failed:', e);
                                    }

                                    // Log camera jump
                                    if (window.logInteraction) {
                                        window.logInteraction('camera_jump', target, { lat: geoData.lat, lon: geoData.lon });
                                    }
                                },
                                cancel: function() {
                                    console.warn('[Nmap] Camera flight cancelled');
                                    // Ensure unlock even on cancel
                                    try {
                                        viewer.camera.lookAtTransform(Cesium.Matrix4.IDENTITY);
                                        viewer.trackedEntity = undefined;
                                    } catch(e){}
                                }
                            });
                            
                            // Force render start
                            if(viewer.scene) viewer.scene.requestRender();
                            
                        } catch (e) {
                            console.error('[Nmap] Camera operation failed:', e);
                            console.warn('[Nmap] Attempting fallback flyTo...');
                            try { viewer.camera.flyTo({ destination: destination }); } catch(z){}
                        }
                    } else {
                        console.error('[Nmap] Viewer not available for flight');
                    }
                    
                    return geoData;
                }
                
                return null;
                
            } catch (error) {
                console.error('[Nmap] Geolocation error:', error);
                return null;
            }
        }
        
        // Fly camera to specific coordinates with optional callback
        // Uses global flyToWithReset for automatic camera unlock
        function flyToLocation(lat, lon, altitude = 100000, options = {}) {
            if (!viewer) return;
            
            const destination = Cesium.Cartesian3.fromDegrees(lon, lat, altitude);
            
            // Use flyToWithReset for automatic camera control reset
            window.flyToWithReset({
                destination: destination,
                orientation: {
                    heading: Cesium.Math.toRadians(options.heading || 0),
                    pitch: Cesium.Math.toRadians(options.pitch || -45),
                    roll: 0
                },
                duration: options.duration || 2.5,
                complete: function() {
                    if (window.HierarchicalRenderManager) {
                        HierarchicalRenderManager.updateVisibilityForAltitude();
                    }
                    if (options.onComplete) options.onComplete();
                }
            });
        }
        
        // Display detailed scan results
        function showNmapScanResults(scanResult) {
            if (!scanResult) {
                console.warn('[Nmap] No scan result to display');
                return;
            }
            
            // Handle various response structures from the API
            const scanId = scanResult.scanId || scanResult.session_id || 'unknown';
            const results = scanResult.results || scanResult;
            const hypergraphData = scanResult.hypergraphData || scanResult;
            
            // Safely extract hosts - could be in different places
            const hostsArray = results.hostsDiscovered 
                || results.hosts 
                || hypergraphData.nodes 
                || [];
            
            // Safely extract services
            const servicesArray = results.services || [];
            
            // Safely extract vulnerabilities  
            const vulnsArray = results.vulnerabilities || [];
            
            // Count RF correlated hosts safely
            let rfCorrelatedCount = 0;
            if (Array.isArray(hostsArray)) {
                rfCorrelatedCount = hostsArray.filter(h => 
                    h && (h.rfSignature?.detected || h.rf_detected || h.properties?.rf_detected)
                ).length;
            }
            
            // Create detailed results popup or update sidebar
            const resultSummary = {
                scanId: scanId,
                targetNetwork: results.target || hypergraphData.target || 'unknown',
                hostsDiscovered: Array.isArray(hostsArray) ? hostsArray.length : 0,
                servicesFound: Array.isArray(servicesArray) ? servicesArray.length : 0,
                vulnerabilities: Array.isArray(vulnsArray) ? vulnsArray.length : 0,
                rfCorrelatedHosts: rfCorrelatedCount,
                scanTime: results.scanTime || results.scan_time || 'N/A'
            };
            
            // Update central nodes list with nmap-specific data
            const centralNodes = hypergraphData.central_nodes || hypergraphData.nodes || [];
            updateNmapCentralNodes(centralNodes);
            
            // Show notification with summary
            showNotification('Nmap Scan Complete', 
                `Found ${resultSummary.hostsDiscovered} hosts, ${resultSummary.rfCorrelatedHosts} with RF signals`, 
                'success');
            
            // Add to scan history
            storeScanResult(scanResult);
            
            console.log('[Nmap] Scan results displayed:', resultSummary);
        }
        
        // Update central nodes display with nmap data
        function updateNmapCentralNodes(centralNodes) {
            const centralNodesList = document.getElementById('central-nodes-list');
            if (!centralNodesList) return;
            
            if (centralNodes && centralNodes.length > 0) {
                centralNodesList.innerHTML = centralNodes.map((node, index) => {
                    const freqText = (node.frequency !== undefined && isFinite(node.frequency))
                        ? `${Number(node.frequency).toFixed(2)} MHz`
                        : '?';
                    const centralityText = (node.centrality !== undefined && isFinite(node.centrality))
                        ? `${Number(node.centrality).toFixed(2)}`
                        : '?';
                    return `
                        <div class="node-item">
                            <strong>Host ${index + 1}:</strong> 
                            ${node.properties?.hostname || node.properties?.ip || 'Unknown'}
                            <br>
                            <small>
                                RF: ${freqText}, 
                                Centrality: ${centralityText},
                                OS: ${node.properties?.os || 'Unknown'}
                            </small>
                        </div>
                    `;
                }).join('');
            } else {
                centralNodesList.innerHTML = 'No central nodes found';
            }
        }
        
        // Clear nmap hypergraph data
        function clearNmapHypergraphData() {
            if (hypergraphVisualizer) {
                hypergraphVisualizer.clearNmapData();
            }
            
            // Reset UI
            const statusElement = document.getElementById('nmap-status');
            if (statusElement) statusElement.textContent = 'Ready to scan';
            
            const progressElement = document.getElementById('nmap-progress');
            if (progressElement) progressElement.style.display = 'none';
            
            // Clear central nodes
            const centralNodesList = document.getElementById('central-nodes-list');
            if (centralNodesList) centralNodesList.innerHTML = 'No nmap data';
            
            addConsoleMessage('Cleared nmap hypergraph data', 'response');
            showNotification('Data Cleared', 'Nmap hypergraph data has been cleared', 'info');
        }
        
        // Store scan result for history
        function storeScanResult(scanResult) {
            if (!scanResult) return;
            
            try {
                const scanHistory = JSON.parse(localStorage.getItem('nmapScanHistory') || '[]');
                
                // Keep only last 10 scans
                if (scanHistory.length >= 10) {
                    scanHistory.shift();
                }
                
                // Safely extract data from various response structures
                const results = scanResult.results || scanResult;
                const hypergraphData = scanResult.hypergraphData || scanResult;
                
                const hostsArray = results.hostsDiscovered || results.hosts || hypergraphData.nodes || [];
                const servicesArray = results.services || [];
                const vulnsArray = results.vulnerabilities || [];
                
                // Count RF correlated hosts safely
                let rfCorrelatedCount = 0;
                if (Array.isArray(hostsArray)) {
                    rfCorrelatedCount = hostsArray.filter(h => 
                        h && (h.rfSignature?.detected || h.rf_detected || h.properties?.rf_detected)
                    ).length;
                }
                
                scanHistory.push({
                    scanId: scanResult.scanId || scanResult.session_id || Date.now().toString(),
                    timestamp: new Date().toISOString(),
                    targetNetwork: results.target || hypergraphData.target || 'unknown',
                    summary: {
                        hosts: Array.isArray(hostsArray) ? hostsArray.length : 0,
                        services: Array.isArray(servicesArray) ? servicesArray.length : 0,
                        vulnerabilities: Array.isArray(vulnsArray) ? vulnsArray.length : 0,
                        rfCorrelated: rfCorrelatedCount
                    }
                });
                
                localStorage.setItem('nmapScanHistory', JSON.stringify(scanHistory));
                console.log('[Nmap] Scan result stored to history');
            } catch (error) {
                console.warn('[Nmap] Failed to store scan result:', error);
            }
        }
        
        // Get scan history
        function getNmapScanHistory() {
            return JSON.parse(localStorage.getItem('nmapScanHistory') || '[]');
        }
        
        // NOTE: Consolidated showPanel is defined early in Essential Functions section
        // to ensure it's available before any module tries to use it
        
        // ==================== ENHANCED COMMAND IMPLEMENTATION FUNCTIONS ====================
        
        // Enhanced nmap scanning with full feature support
        async function performEnhancedNmapScan(target, options) {
            addConsoleMessage(`Initiating enhanced nmap scan on ${target}...`, 'response');
            
            // Build nmap options string for backend
            let nmapArgs = [];
            
            // Scan type
            if (options.scanType === 'tcp-syn') nmapArgs.push('-sS');
            else if (options.scanType === 'tcp-connect') nmapArgs.push('-sT');
            else if (options.scanType === 'udp') nmapArgs.push('-sU');
            else if (options.scanType === 'stealth') nmapArgs.push('-sN -sF -sX');
            
            // Timing
            if (options.timing) nmapArgs.push(`-T${options.timing}`);
            
            // Port specification
            if (options.ports === 'top') nmapArgs.push('--top-ports 1000');
            else if (options.ports === 'all') nmapArgs.push('-p-');
            else if (options.ports) nmapArgs.push(`-p ${options.ports}`);
            
            // NSE scripts
            if (options.scriptScan) nmapArgs.push('--script default');
            if (options.vulnScan) nmapArgs.push('--script vuln');
            if (options.osFingerprint) nmapArgs.push('-O');
            if (options.serviceVersion) nmapArgs.push('-sV');
            if (options.aggressiveScan) nmapArgs.push('-A');
            // Traceroute option
            if (options.traceroute) nmapArgs.push('--traceroute');
            
            // Output
            if (options.output) nmapArgs.push(`-oX ${options.output}`);

            const optionsStr = nmapArgs.join(' ');
            const nmapCmd = `nmap ${optionsStr} ${target}`;
            
            addConsoleMessage(`Command: ${nmapCmd}`, 'info');
            
            // Execute real backend scan or fall back to simulation
            try {
                showNotification('Scan Started', `Enhanced nmap scan initiated on ${target}`, 'info');
                
                let scanResults;
                let usedBackend = false;

                // Determine endpoint based on hypergraph option
                // If hypergraph is true, we use the network-hypergraph endpoint which auto-populates the graph
                const endpoint = options.hypergraph ? '/api/network-hypergraph/scan' : '/api/nmap/scan';

                try {
                    addConsoleMessage(`Sending request to ${endpoint}...`, 'info');
                    const res = await fetch(endpoint, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            target: target,
                            options: optionsStr,
                            reset: false // Keep existing graph nodes unless explicit clear is requested elsewhere
                        })
                    });

                    if (res.ok) {
                        scanResults = await res.json();
                        
                        // Handle simulated response from backend (if nmap missing on server)
                        if (scanResults.status === 'simulated') {
                            addConsoleMessage('Backend used simulation (nmap binary not found on server)', 'warning');
                        } else {
                            usedBackend = true;
                            addConsoleMessage('Backend scan completed successfully', 'success');
                        }
                    } else {
                        throw new Error(`Server error: ${res.status}`);
                    }
                } catch (netErr) {
                    console.warn('[Nmap] Backend scan failed, falling back to client simulation', netErr);
                    // Fallback to client-side simulation
                    scanResults = await simulateEnhancedNmapScan(target, options);
                    addConsoleMessage('Using client-side simulation (Backend unavailable)', 'warning');
                }
                
                // Update hypergraph with results
                if (options.hypergraph && hypergraphVisualizer) {
                    // If we used the backend hypergraph endpoint, the graph is already updated on server.
                    // We just need to fetch the latest state.
                    if (usedBackend && options.hypergraph) {
                        await hypergraphVisualizer.visualizeHypergraph();
                    } else {
                        // If we used simulation or raw nmap scan, manually push results
                        if (typeof hypergraphVisualizer.updateWithNmapResults === 'function') {
                            await hypergraphVisualizer.updateWithNmapResults(scanResults);
                        }
                    }
                    showPanel('hypergraph');
                }

                // If traceroute was requested
                if (options.traceroute) {
                    if (!usedBackend) {
                        scanResults.traceroute = simulateTraceroute(target);
                    }
                    if (scanResults.traceroute) {
                         addConsoleMessage(`Traceroute data received for ${target}`, 'info');
                         // TODO: Visualize traceroute
                    }
                }

                // NDPI convergence: if caller requested, trigger NDPI analyze
                if (options.ndpiCorrelate) {
                    try {
                        handleNdpiCommand(['analyze', target]);
                        addConsoleMessage('NDPI correlation started', 'info');
                    } catch (e) {
                        console.warn('[Nmap] NDPI correlation failed', e);
                    }
                }
                
                const hostsFound = (scanResults.hosts || scanResults.results || []).length;
                const servicesFound = scanResults.servicesFound || (scanResults.hosts || []).reduce((acc, h) => acc + (h.ports || []).length, 0);

                // Store scan result in localStorage for history
                try {
                    const history = getNmapScanHistory();
                    const scanRecord = {
                        target: target,
                        targetNetwork: target,
                        scanTime: Date.now(),
                        timestamp: Date.now(),
                        hostsFound: hostsFound,
                        hostsDiscovered: hostsFound,
                        servicesFound: servicesFound,
                        summary: {
                            hosts: hostsFound,
                            services: servicesFound
                        },
                        options: options,
                        results: scanResults
                    };
                    history.push(scanRecord);
                    // Keep only last 50 scans
                    if (history.length > 50) history.shift();
                    localStorage.setItem('nmapScanHistory', JSON.stringify(history));
                    
                    // Refresh the UI
                    if (typeof refreshNmapHistoryUI === 'function') {
                        refreshNmapHistoryUI();
                    }
                } catch (storageErr) {
                    console.warn('[Nmap] Failed to store scan history:', storageErr);
                }

                addConsoleMessage(`Scan completed: ${hostsFound} hosts discovered`, 'response');
                showNotification('Scan Complete', `Found ${hostsFound} hosts with ${servicesFound} services`, 'success');
                
                return scanResults;
                
            } catch (error) {
                addConsoleMessage(`Error during nmap scan: ${error.message}`, 'alert');
                showNotification('Scan Error', error.message, 'error');
                throw error;
            }
        }
        
        // Simulate enhanced nmap scan with realistic data
        async function simulateEnhancedNmapScan(target, options) {
            await new Promise(resolve => setTimeout(resolve, 1000)); // Simulate scan time
            
            const hosts = [];
            const baseIP = target.split('.').slice(0, 3).join('.');
            
            // Generate realistic host data
            for (let i = 1; i <= Math.random() * 10 + 5; i++) {
                const host = {
                    ip: `${baseIP}.${100 + i}`,
                    hostname: Math.random() > 0.5 ? `host-${i}.local` : null,
                    os: ['Linux', 'Windows', 'macOS', 'FreeBSD'][Math.floor(Math.random() * 4)],
                    ports: [],
                    vulnerabilities: [],
                    rfSignature: {
                        detected: Math.random() > 0.3,
                        frequency: 2400 + Math.random() * 400, // 2.4GHz band
                        strength: -70 + Math.random() * 30
                    }
                };
                
                // Add ports and services
                const commonPorts = [22, 80, 443, 21, 25, 53, 110, 143, 993, 995, 3389, 5432, 3306];
                const numPorts = Math.random() * 5 + 1;
                
                for (let p = 0; p < numPorts; p++) {
                    const port = commonPorts[Math.floor(Math.random() * commonPorts.length)];
                    if (!host.ports.find(po => po.port === port)) {
                        host.ports.push({
                            port: port,
                            state: Math.random() > 0.1 ? 'open' : 'filtered',
                            service: getServiceName(port),
                            version: getServiceVersion(port)
                        });
                    }
                }
                
                // Add vulnerabilities if vuln scan enabled
                if (options.vulnScan && Math.random() > 0.6) {
                    host.vulnerabilities.push({
                        cve: `CVE-2023-${1000 + Math.floor(Math.random() * 9000)}`,
                        severity: ['low', 'medium', 'high', 'critical'][Math.floor(Math.random() * 4)],
                        description: 'Simulated vulnerability for demonstration'
                    });
                }
                
                hosts.push(host);
            }
            
            return {
                target: target,
                hostsFound: hosts.length,
                servicesFound: hosts.reduce((sum, host) => sum + host.ports.length, 0),
                vulnerabilitiesFound: hosts.reduce((sum, host) => sum + host.vulnerabilities.length, 0),
                hosts: hosts,
                scanTime: new Date().toISOString()
            };
        }
        
        function getServiceName(port) {
            const services = {
                22: 'ssh', 80: 'http', 443: 'https', 21: 'ftp',
                25: 'smtp', 53: 'dns', 110: 'pop3', 143: 'imap',
                993: 'imaps', 995: 'pop3s', 3389: 'rdp',
                5432: 'postgresql', 3306: 'mysql'
            };
            return services[port] || 'unknown';
        }
        
        function getServiceVersion(port) {
            const versions = {
                22: 'OpenSSH 8.9', 80: 'Apache 2.4.54', 443: 'nginx 1.18.0',
                21: 'vsftpd 3.0.3', 25: 'Postfix smtpd', 53: 'ISC BIND 9.16.1'
            };
            return versions[port] || 'unknown';
        }
        
        // nDPI implementation functions - Real backend integration
        async function performNdpiAnalysis(target, options) {
            addConsoleMessage(`Starting nDPI deep packet inspection on ${target}...`, 'response');
            const startTime = performance.now();
            
            try {
                // Try real backend first, fall back to simulation
                let analysis;
                try {
                    const response = await fetch('/api/ndpi/analyze', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            target: target,
                            options: {
                                detailed: options.detailed || true,
                                hypergraph: options.hypergraph || false,
                                timeout: options.timeout || 30000,
                                maxPackets: options.maxPackets || 10000
                            }
                        })
                    });
                    
                    if (response.ok) {
                        analysis = await response.json();
                        addConsoleMessage('nDPI analysis completed via backend API', 'info');
                    } else {
                        throw new Error(`API returned ${response.status}`);
                    }
                } catch (apiError) {
                    console.warn('[nDPI] Backend API unavailable, using simulation:', apiError);
                    analysis = await simulateNdpiAnalysis(target, options);
                    addConsoleMessage('nDPI analysis using simulated data (API unavailable)', 'warning');
                }
                
                const elapsedMs = performance.now() - startTime;
                analysis.elapsedMs = elapsedMs;
                
                // Display results
                addConsoleMessage('Protocol analysis results:', 'response');
                analysis.protocols.forEach(proto => {
                    addConsoleMessage(`  ${proto.name}: ${proto.percentage}% (${proto.bytes} bytes)`, 'info');
                });
                
                // Log metrics for nDPI analysis
                if (window.logMetric) {
                    window.logMetric('ndpi', 'total_packets', analysis.totalPackets);
                    window.logMetric('ndpi', 'total_bytes', analysis.totalBytes);
                    window.logMetric('ndpi', 'analysis_time_ms', elapsedMs);
                    window.logMetric('ndpi', 'protocol_count', analysis.protocols.length);
                    
                    // Log individual protocol metrics
                    analysis.protocols.forEach(proto => {
                        window.logMetric('ndpi_protocol', proto.name.toLowerCase().replace(/[^a-z0-9]/g, '_') + '_pct', proto.percentage);
                        window.logMetric('ndpi_bytes', proto.name.toLowerCase().replace(/[^a-z0-9]/g, '_'), proto.bytes);
                    });
                    
                    // Log application metrics
                    if (analysis.applications) {
                        analysis.applications.forEach(app => {
                            window.logMetric('ndpi_app', app.name.toLowerCase().replace(/[^a-z0-9]/g, '_') + '_pct', app.percentage);
                        });
                    }
                }
                
                // Log interaction
                if (window.logInteraction) {
                    window.logInteraction('ndpi_analysis', target, { 
                        packets: analysis.totalPackets,
                        protocols: analysis.protocols.length 
                    });
                }
                
                // Hypergraph integration - add protocol-weighted edges
                if (options.hypergraph && hypergraphVisualizer) {
                    await hypergraphVisualizer.updateWithProtocolData(analysis);
                    
                    // Add protocol nodes and edges to hypergraph
                    if (typeof hypergraphVisualizer.addProtocolEdges === 'function') {
                        hypergraphVisualizer.addProtocolEdges(target, analysis.protocols);
                    }
                    
                    // Log hypergraph update
                    if (window.logMetric) {
                        window.logMetric('ndpi', 'hypergraph_updated', 1);
                    }
                }
                
                showNotification('nDPI Complete', `Analyzed ${analysis.totalPackets} packets in ${elapsedMs.toFixed(0)}ms`, 'success');
                
                return analysis;
                
            } catch (error) {
                addConsoleMessage(`nDPI analysis error: ${error.message}`, 'alert');
                if (window.logMetric) {
                    window.logMetric('ndpi', 'analysis_error', 1);
                }
                throw error;
            }
        }
        
        // Batch nDPI analysis for multiple targets
        async function performNdpiBatchAnalysis(targets, options) {
            addConsoleMessage(`Starting batch nDPI analysis on ${targets.length} targets...`, 'response');
            const results = [];
            
            try {
                // Try backend batch endpoint first
                try {
                    const response = await fetch('/api/ndpi/batch', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ targets, options })
                    });
                    
                    if (response.ok) {
                        const batchResult = await response.json();
                        addConsoleMessage(`Batch analysis complete: ${batchResult.results.length} targets processed`, 'response');
                        return batchResult;
                    }
                } catch (e) {
                    console.warn('[nDPI] Batch endpoint unavailable, processing sequentially');
                }
                
                // Fallback: Sequential processing
                for (const target of targets) {
                    try {
                        const result = await performNdpiAnalysis(target, options);
                        results.push({ target, result, success: true });
                    } catch (error) {
                        results.push({ target, error: error.message, success: false });
                    }
                }
                
                return { results, totalTargets: targets.length, successCount: results.filter(r => r.success).length };
                
            } catch (error) {
                addConsoleMessage(`Batch nDPI analysis error: ${error.message}`, 'alert');
                throw error;
            }
        }
        
        async function simulateNdpiAnalysis(target, options) {
            await new Promise(resolve => setTimeout(resolve, 800));
            
            // More realistic simulation with variance
            const basePackets = Math.floor(Math.random() * 10000 + 1000);
            const baseBytes = basePackets * Math.floor(Math.random() * 500 + 100);
            
            // Generate varied protocol distributions
            const protocolPool = [
                { name: 'HTTP', weight: 0.35 },
                { name: 'HTTPS/TLS', weight: 0.30 },
                { name: 'DNS', weight: 0.12 },
                { name: 'SSH', weight: 0.08 },
                { name: 'QUIC', weight: 0.05 },
                { name: 'SMTP', weight: 0.03 },
                { name: 'FTP', weight: 0.02 },
                { name: 'Unknown', weight: 0.05 }
            ];
            
            // Add randomness
            let remaining = 100;
            const protocols = protocolPool.map((p, idx) => {
                const variance = (Math.random() - 0.5) * 20;
                let pct = Math.max(1, p.weight * 100 + variance);
                if (idx === protocolPool.length - 1) pct = remaining;
                remaining -= pct;
                return {
                    name: p.name,
                    percentage: parseFloat(pct.toFixed(1)),
                    bytes: Math.floor(baseBytes * (pct / 100)),
                    packets: Math.floor(basePackets * (pct / 100)),
                    confidence: Math.random() * 0.3 + 0.7
                };
            }).filter(p => p.percentage > 0);
            
            return {
                target: target,
                totalPackets: basePackets,
                totalBytes: baseBytes,
                flowsInspected: Math.floor(basePackets / 50),
                protocols: protocols,
                applications: [
                    { name: 'Web Browser', percentage: 45.2 + (Math.random() - 0.5) * 10, confidence: 0.92 },
                    { name: 'SSH Client', percentage: 25.1 + (Math.random() - 0.5) * 10, confidence: 0.98 },
                    { name: 'Email Client', percentage: 15.7 + (Math.random() - 0.5) * 5, confidence: 0.85 },
                    { name: 'File Transfer', percentage: 14.0 + (Math.random() - 0.5) * 5, confidence: 0.78 }
                ],
                detectionStats: {
                    identified: Math.floor(basePackets * 0.87),
                    unidentified: Math.floor(basePackets * 0.13),
                    encrypted: Math.floor(basePackets * 0.45)
                },
                timestamp: new Date().toISOString()
            };
        }
        
        async function performNdpiClassification(pcapFile, options) {
            addConsoleMessage(`Classifying protocols from ${pcapFile}...`, 'response');
            // Implementation would process PCAP file
            addConsoleMessage('PCAP classification complete', 'response');
        }
        
        async function performNdpiDetection(networkInterface, options) {
            addConsoleMessage(`Starting real-time detection on ${networkInterface}...`, 'response');
            // Implementation would monitor network interface
            addConsoleMessage('Real-time detection started', 'response');
        }
        
        async function performNdpiFlowAnalysis(target, options) {
            addConsoleMessage(`Analyzing network flows for ${target}...`, 'response');
            // Implementation would analyze network flows
            addConsoleMessage('Flow analysis complete', 'response');
        }
        
        async function performNdpiApplicationAnalysis(target, options) {
            addConsoleMessage(`Identifying applications on ${target}...`, 'response');
            // Implementation would identify running applications
            addConsoleMessage('Application analysis complete', 'response');
        }
        
        async function performNdpiDgaDetection(domain, options) {
            addConsoleMessage(`Checking ${domain} for DGA patterns...`, 'response');
            // Implementation would detect domain generation algorithms
            const isDGA = Math.random() > 0.8;
            addConsoleMessage(`DGA Detection: ${isDGA ? 'SUSPICIOUS' : 'CLEAN'}`, isDGA ? 'alert' : 'response');
        }
        
        async function performNdpiMalwareDetection(target, options) {
            addConsoleMessage(`Scanning ${target} for malware traffic...`, 'response');
            // Implementation would detect malware communication patterns
            addConsoleMessage('Malware detection scan complete', 'response');
        }
        
        // IMM-RF-NeRF implementation functions
        async function performImmTraining(dataset, options) {
            addConsoleMessage(`Training IMM model with dataset: ${dataset}`, 'response');
            addConsoleMessage(`Training parameters: ${options.epochs} epochs, batch size ${options.batchSize}, LR ${options.learningRate}`, 'info');
            
            try {
                // Simulate training progress
                for (let epoch = 1; epoch <= Math.min(options.epochs, 5); epoch++) {
                    addConsoleMessage(`Epoch ${epoch}/${options.epochs}: Loss = ${(1.0 - epoch * 0.15).toFixed(4)}`, 'info');
                    await new Promise(resolve => setTimeout(resolve, 200));
                }
                
                addConsoleMessage('IMM model training completed successfully', 'response');
                showNotification('Training Complete', 'IMM model training finished', 'success');
                
            } catch (error) {
                addConsoleMessage(`Training error: ${error.message}`, 'alert');
            }
        }
        
        async function performImmGeneration(rfFeatures, options) {
            addConsoleMessage(`Generating RF visualization data from features: ${rfFeatures}`, 'response');
            
            try {
                const generatedData = await simulateImmGeneration(rfFeatures, options);
                addConsoleMessage(`Generated ${generatedData.points} 3D points`, 'response');
                
                if (hypergraphVisualizer) {
                    await hypergraphVisualizer.updateWithImmData(generatedData);
                    showPanel('hypergraph');
                }
                
            } catch (error) {
                addConsoleMessage(`Generation error: ${error.message}`, 'alert');
            }
        }
        
        async function simulateImmGeneration(rfFeatures, options) {
            await new Promise(resolve => setTimeout(resolve, 500));
            
            const resolution = options.resolution.split('x').map(x => parseInt(x));
            const points = resolution.reduce((a, b) => a * b, 1);
            
            return {
                points: points,
                resolution: resolution,
                features: rfFeatures,
                timestamp: new Date().toISOString()
            };
        }
        
        async function performImmVisualization(config, options) {
            addConsoleMessage(`Creating NeRF visualization with config: ${config}`, 'response');
            addConsoleMessage(`Resolution: ${options.resolution}, RF Features: ${options.rfFeatures}`, 'info');
            
            try {
                // Simulate visualization generation
                await new Promise(resolve => setTimeout(resolve, 1000));
                
                addConsoleMessage('NeRF visualization generated successfully', 'response');
                showPanel('hypergraph');
                showNotification('Visualization Ready', 'IMM-RF-NeRF visualization completed', 'success');
                
            } catch (error) {
                addConsoleMessage(`Visualization error: ${error.message}`, 'alert');
            }
        }
        
        async function performImmModelLoad(modelPath, options) {
            addConsoleMessage(`Loading IMM model from: ${modelPath}`, 'response');
            // Implementation would load pre-trained model
            addConsoleMessage('Model loaded successfully', 'response');
        }
        
        async function performImmModelSave(modelPath, options) {
            addConsoleMessage(`Saving IMM model to: ${modelPath}`, 'response');
            // Implementation would save current model
            addConsoleMessage('Model saved successfully', 'response');
        }
        
        async function performImmEncode(rfSignal, options) {
            addConsoleMessage(`Encoding RF signal to latent space: ${rfSignal}`, 'response');
            // Implementation would encode RF signal data
            addConsoleMessage('RF signal encoded to latent vector', 'response');
        }
        
        async function performImmDecode(latentVector, options) {
            addConsoleMessage(`Decoding latent vector: ${latentVector}`, 'response');
            // Implementation would decode latent vector to RF features
            addConsoleMessage('Latent vector decoded to RF features', 'response');
        }
        
        async function performImmCrossDomainAnalysis(sources, options) {
            addConsoleMessage(`Cross-domain influence analysis on: ${sources}`, 'response');
            if (options.lhc) addConsoleMessage('LHC integration enabled', 'info');
            if (options.jwst) addConsoleMessage('JWST integration enabled', 'info');
            // Implementation would perform cross-domain analysis
            addConsoleMessage('Cross-domain analysis complete', 'response');
        }
        
        // RF-NeRF implementation functions
        async function performRfNerfOperation(action, target, options) {
            addConsoleMessage(`RF-NeRF ${action} operation on: ${target}`, 'response');
            
            switch (action) {
                case 'render':
                    addConsoleMessage(`Rendering with quality: ${options.quality}, RF bands: ${options.rfBands}`, 'info');
                    await new Promise(resolve => setTimeout(resolve, 800));
                    addConsoleMessage('RF field visualization rendered', 'response');
                    showPanel('hypergraph');
                    break;
                    
                case 'volume':
                    addConsoleMessage(`Creating volumetric representation with ${options.samples} samples`, 'info');
                    await new Promise(resolve => setTimeout(resolve, 600));
                    addConsoleMessage('Volumetric RF representation created', 'response');
                    break;
                    
                case 'raycast':
                    addConsoleMessage(`Performing RF ray casting at resolution ${options.resolution}`, 'info');
                    await new Promise(resolve => setTimeout(resolve, 400));
                    addConsoleMessage('RF ray casting complete', 'response');
                    break;
                    
                case 'optimize':
                    addConsoleMessage('Optimizing NeRF scene parameters...', 'info');
                    await new Promise(resolve => setTimeout(resolve, 1200));
                    addConsoleMessage('NeRF scene optimization complete', 'response');
                    break;
                    
                case 'export':
                    addConsoleMessage(`Exporting visualization data in ${options.format} format`, 'info');
                    await new Promise(resolve => setTimeout(resolve, 300));
                    addConsoleMessage('Visualization data exported successfully', 'response');
                    break;
            }
        }
        
        // Protocol analysis implementation
        async function performProtocolAnalysis(action, target, args) {
            addConsoleMessage(`Protocol ${action} on: ${target}`, 'response');
            
            switch (action) {
                case 'identify':
                    addConsoleMessage('Protocol identified: TCP/HTTP', 'info');
                    break;
                case 'decode':
                    addConsoleMessage('Protocol headers decoded successfully', 'info');
                    break;
                case 'stats':
                    addConsoleMessage('Protocol usage statistics generated', 'info');
                    break;
                case 'flows':
                    addConsoleMessage('Protocol flow analysis complete', 'info');
                    break;
            }
        }
        
        // Hypergraph reconstruction implementation
        async function performHypergraphReconstruction(type, source, args) {
            addConsoleMessage(`Hypergraph reconstruction: ${type} from ${source}`, 'response');
            
            try {
                await new Promise(resolve => setTimeout(resolve, 1000));
                
                switch (type) {
                    case 'topology':
                        addConsoleMessage('Network topology reconstructed', 'response');
                        break;
                    case 'flows':
                        addConsoleMessage('Data flows reconstructed', 'response');
                        break;
                    case 'rf':
                        addConsoleMessage('RF propagation paths reconstructed', 'response');
                        break;
                    case 'combined':
                        addConsoleMessage('Combined network+RF reconstruction complete', 'response');
                        break;
                }
                
                if (hypergraphVisualizer) {
                    showPanel('hypergraph');
                }
                
            } catch (error) {
                addConsoleMessage(`Reconstruction error: ${error.message}`, 'alert');
            }
        }
        
        // Advanced analysis implementation
        async function performAdvancedAnalysis(type, target, args) {
            addConsoleMessage(`Advanced ${type} analysis on: ${target}`, 'response');
            
            try {
                await new Promise(resolve => setTimeout(resolve, 800));
                
                switch (type) {
                    case 'traffic':
                        addConsoleMessage('Traffic patterns analyzed - Normal behavior detected', 'response');
                        break;
                    case 'anomaly':
                        const anomalies = Math.floor(Math.random() * 3);
                        addConsoleMessage(`Anomaly detection complete - ${anomalies} anomalies found`, 
                                       anomalies > 0 ? 'alert' : 'response');
                        break;
                    case 'correlation':
                        addConsoleMessage('Cross-correlation analysis complete', 'response');
                        break;
                    case 'security':
                        const vulns = Math.floor(Math.random() * 5);
                        addConsoleMessage(`Security analysis complete - ${vulns} vulnerabilities found`, 
                                       vulns > 2 ? 'alert' : 'response');
                        break;
                }
                
            } catch (error) {
                addConsoleMessage(`Analysis error: ${error.message}`, 'alert');
            }
        }
        
        // Deep packet inspection implementation
        async function performDeepPacketInspection(action, target, args) {
            addConsoleMessage(`Deep packet inspection ${action} on: ${target}`, 'response');
            
            try {
                await new Promise(resolve => setTimeout(resolve, 600));
                
                switch (action) {
                    case 'scan':
                        addConsoleMessage('Real-time DPI scanning initiated', 'response');
                        break;
                    case 'analyze':
                        addConsoleMessage('PCAP file analysis complete', 'response');
                        break;
                    case 'classify':
                        addConsoleMessage('Packet classification complete', 'response');
                        break;
                    case 'extract':
                        addConsoleMessage('Packet features extracted', 'response');
                        break;
                }
                
            } catch (error) {
                addConsoleMessage(`DPI error: ${error.message}`, 'alert');
            }
        }
        
        // Fingerprinting implementation
        async function performFingerprinting(type, target, args) {
            addConsoleMessage(`${type} fingerprinting on: ${target}`, 'response');
            
            try {
                await new Promise(resolve => setTimeout(resolve, 500));
                
                switch (type) {
                    case 'os':
                        const osTypes = ['Linux Ubuntu 20.04', 'Windows 10', 'macOS 12.0', 'FreeBSD 13.0'];
                        const detectedOS = osTypes[Math.floor(Math.random() * osTypes.length)];
                        addConsoleMessage(`OS fingerprinted: ${detectedOS}`, 'response');
                        break;
                    case 'service':
                        addConsoleMessage(`Service fingerprinted: Apache 2.4.54 on port ${target}`, 'response');
                        break;
                    case 'device':
                        addConsoleMessage(`Device fingerprinted: Cisco router (MAC: ${target})`, 'response');
                        break;
                    case 'rf':
                        addConsoleMessage(`RF device fingerprinted: 802.11ac WiFi adapter`, 'response');
                        break;
                }
                
            } catch (error) {
                addConsoleMessage(`Fingerprinting error: ${error.message}`, 'alert');
            }
        }

        // ============================================================================
        // RF HYPERGRAPH VISUALIZATION AND MANAGEMENT SYSTEM
        // ============================================================================
        
        // Global hypergraph system (reuse existing declaration)
        let hypergraphUpdateInterval = null;
        
        // Add RF Hypergraph visualizer to RF_SCYTHE namespace
        window.RF_SCYTHE.createHypergraphVisualizer = function(viewer, options) {
            options = options || {};
            const hypergraphEntities = new Set();
            
            return {
                // Internal counter for assigning unique node IDs when none are provided
                _autoNodeCounter: 0,
                // Visualize RF nodes and hyperedges
                visualizeHypergraph: async function(cardinalityFilter = 5, strengthFilter = -90) {
                    try {
                        // Fetch hypergraph data
                        const response = await fetch('/api/rf-hypergraph/visualization');
                        if (!response.ok) {
                            console.warn('Hypergraph API not available');
                            return;
                        }
                        
                        const data = await response.json();
                        
                        // Clear existing hypergraph entities
                        this.clearHypergraph();
                        
                        // Add RF nodes
                        if (data.nodes) {
                            let nodeIndex = 0;
                            for (const node of data.nodes) {
                                // Skip nodes without valid node_id
                                if (!node.node_id && node.node_id !== 0) {
                                    // Generate a fallback ID if missing
                                    node.node_id = `auto_node_${nodeIndex}_${Date.now()}`;
                                }
                                // Skip if node_id is explicitly undefined or null after check
                                if (node.node_id === undefined || node.node_id === null) {
                                    console.warn('Skipping node with invalid ID:', node);
                                    nodeIndex++;
                                    continue;
                                }
                                this.addRFNode(node);
                                nodeIndex++;
                            }
                        }
                        
                        // Add hyperedges
                        if (data.hyperedges) {
                            for (const edge of data.hyperedges) {
                                if (edge.cardinality <= cardinalityFilter && 
                                    edge.signal_strength >= strengthFilter) {
                                    this.addHyperedge(edge, data.nodes);
                                }
                            }
                        }
                        
                        // Highlight central nodes
                        if (data.central_nodes) {
                            for (const centralNode of data.central_nodes) {
                                this.highlightCentralNode(centralNode.node_id);
                            }
                        }
                        
                    } catch (error) {
                        console.error('Error visualizing hypergraph:', error);
                    }
                },

                // Update with Nmap results (client-side ingestion)
                updateWithNmapResults: async function(nmapResults) {
                    if (!nmapResults || (!nmapResults.hosts && !nmapResults.results)) return;
                    
                    const hosts = nmapResults.hosts || nmapResults.results || [];
                    console.log(`[Hypergraph] Ingesting ${hosts.length} hosts from Nmap scan`);
                    
                    // Simple spatial layout for non-geolocated hosts
                    // We spiral them out from the center or a target location
                    let centerLat = 0, centerLon = 0;
                    
                    // Try to find a center from existing view
                    try {
                        const cameraPos = viewer.camera.positionCartographic;
                        if (cameraPos) {
                            centerLat = Cesium.Math.toDegrees(cameraPos.latitude);
                            centerLon = Cesium.Math.toDegrees(cameraPos.longitude);
                        }
                    } catch (e) {}
                    
                    hosts.forEach((host, index) => {
                        // Generate a pseudo-position if none exists
                        // Spiral layout: r = a + b*theta
                        const angle = index * 0.5;
                        const radius = 0.001 * (1 + index * 0.1); // ~100m spacing
                        
                        // If host has position data (e.g. from backend geolocation), use it
                        let lat = host.lat || host.latitude;
                        let lon = host.lon || host.longitude;
                        
                        if (!lat || !lon) {
                             lat = centerLat + (radius * Math.cos(angle));
                             lon = centerLon + (radius * Math.sin(angle));
                        }
                        
                        const nodeData = {
                            node_id: host.ip || `host_${index}`,
                            type: 'network_host',
                            ip: host.ip,
                            hostname: host.hostname,
                            position: [lat, lon, 0],
                            services: (host.ports || []).map(p => typeof p === 'string' ? p : (p.service || p.port)),
                            ports: host.ports,
                            metadata: {
                                status: host.status,
                                os: host.os
                            }
                        };
                        
                        this.addRFNode(nodeData);
                    });
                    
                    // Try to fit camera
                    try { this.fitCameraToGraph(); } catch(e) {}
                },
                
                // Add an RF signal node
                addRFNode: function(nodeData) {
                    // Validate or assign a node_id
                    if (!nodeData) {
                        console.warn('Skipping undefined nodeData');
                        return null;
                    }

                    let nodeId = nodeData.node_id;
                    if (nodeId === undefined || nodeId === null || nodeId === '') {
                        // Assign a unique node_id if not provided
                        this._autoNodeCounter = (this._autoNodeCounter || 0) + 1;
                        nodeId = `auto_${this._autoNodeCounter}`;
                        nodeData.node_id = nodeId;
                    }

                    const entityId = `rf_node_${nodeId}`;
                    
                    // Check if entity already exists - remove it first to avoid duplicates
                    const existingEntity = viewer.entities.getById(entityId);
                    if (existingEntity) {
                        viewer.entities.remove(existingEntity);
                        hypergraphEntities.delete(existingEntity);
                    }
                    
                    // Safely extract position and signal properties, falling back to 0/unknown where necessary
                    const lat = (nodeData.position && isFinite(nodeData.position[0])) ? nodeData.position[0] : 0;
                    const lon = (nodeData.position && isFinite(nodeData.position[1])) ? nodeData.position[1] : 0;
                    const alt = (nodeData.position && isFinite(nodeData.position[2])) ? nodeData.position[2] : 0;
                    const freq = isFinite(nodeData.frequency) ? Number(nodeData.frequency) : 0;
                    const power = isFinite(nodeData.power) ? Number(nodeData.power) : 0;
                    const modulation = nodeData.modulation || 'Unknown';
                    
                    // Check if this is a network host vs RF node
                    const isNetworkHost = nodeData.type === 'network_host';
                    const hostIP = nodeData.ip || '';
                    const hostName = nodeData.hostname || '';
                    const services = nodeData.services || [];
                    
                    const position = Cesium.Cartesian3.fromDegrees(lon, lat, alt);
                    
                    // Different display for network hosts vs RF nodes
                    let labelText, nodeColor, description;
                    
                    if (isNetworkHost) {
                        labelText = hostIP || nodeData.node_id;
                        // Color based on number of services
                        if (services.length > 3) {
                            nodeColor = Cesium.Color.RED.withAlpha(0.9);  // Many services - high interest
                        } else if (services.length > 0) {
                            nodeColor = Cesium.Color.LIME.withAlpha(0.9);  // Has services
                        } else {
                            nodeColor = Cesium.Color.CYAN.withAlpha(0.7);  // Just responding
                        }
                        description = `
                            <h4>🌐 Network Host</h4>
                            <p><strong>IP:</strong> ${hostIP}</p>
                            <p><strong>Hostname:</strong> ${hostName || 'Unknown'}</p>
                            <p><strong>Services:</strong> ${services.join(', ') || 'None detected'}</p>
                            <p><strong>Ports:</strong> ${(nodeData.ports || []).map(p => p.port || p).join(', ') || 'None'}</p>
                            <p><strong>Status:</strong> ${nodeData.metadata?.status || 'Up'}</p>
                        `;
                    } else {
                        const frequencyLabel = isFinite(freq) ? `${freq.toFixed(1)}MHz` : 'Unknown';
                        const frequencyDesc = isFinite(freq) ? `${freq.toFixed(2)} MHz` : 'Unknown';
                        const powerDesc = isFinite(power) ? `${power.toFixed(1)} dBm` : 'Unknown';
                        const posDesc = `${lat.toFixed(6)}, ${lon.toFixed(6)}`;
                        
                        labelText = frequencyLabel;
                        nodeColor = this.getFrequencyColor(freq);
                        description = `
                            <h4>📡 RF Signal Node</h4>
                            <p><strong>Node ID:</strong> ${nodeData.node_id}</p>
                            <p><strong>Frequency:</strong> ${frequencyDesc}</p>
                            <p><strong>Power:</strong> ${powerDesc}</p>
                            <p><strong>Modulation:</strong> ${modulation}</p>
                            <p><strong>Position:</strong> ${posDesc}</p>
                        `;
                    }
                    
                    const entity = viewer.entities.add({
                        id: entityId,
                        name: isNetworkHost ? `Host: ${hostIP}` : `RF Node: ${nodeData.node_id}`,
                        position: position,
                        point: {
                            pixelSize: isNetworkHost ? 10 : 8,
                            color: nodeColor,
                            outlineColor: Cesium.Color.WHITE,
                            outlineWidth: isNetworkHost ? 2 : 1,
                            heightReference: Cesium.HeightReference.CLAMP_TO_GROUND
                        },
                        label: {
                            text: labelText,
                            font: isNetworkHost ? '9pt monospace' : '8pt sans-serif',
                            fillColor: Cesium.Color.WHITE,
                            outlineColor: Cesium.Color.BLACK,
                            outlineWidth: 1,
                            style: Cesium.LabelStyle.FILL_AND_OUTLINE,
                            pixelOffset: new Cesium.Cartesian2(0, -25),
                            show: isNetworkHost // Always show for network hosts
                        },
                        description: description
                    });
                    
                    hypergraphEntities.add(entity);
                    return entity;
                },
                
                // Add a hyperedge between RF nodes
                addHyperedge: function(edgeData, nodes) {
                    // Validate edge data
                    if (!edgeData || !edgeData.nodes || !Array.isArray(edgeData.nodes)) {
                        console.warn('Invalid edge data:', edgeData);
                        return;
                    }
                    
                    // Filter out undefined/null node IDs from edge
                    const validNodeIds = edgeData.nodes.filter(nodeId => nodeId !== undefined && nodeId !== null);
                    
                    const edgeNodes = validNodeIds.map(nodeId => 
                        nodes.find(n => n && n.node_id === nodeId)
                    ).filter(Boolean);
                    
                    if (edgeNodes.length < 2) return;
                    
                    // Create a unique edge ID that won't collide
                    const edgeId = `hyperedge_${validNodeIds.sort().join('_')}_${Date.now()}`;
                    
                    // Check if a similar edge already exists and remove it
                    const existingEdgePrefix = `hyperedge_${validNodeIds.sort().join('_')}`;
                    Array.from(hypergraphEntities).forEach(entity => {
                        if (entity.id && entity.id.startsWith(existingEdgePrefix)) {
                            viewer.entities.remove(entity);
                            hypergraphEntities.delete(entity);
                        }
                    });
                    
                    // Get positions for all nodes in the hyperedge
                    const positions = edgeNodes.map(node => 
                        Cesium.Cartesian3.fromDegrees(
                            node.position[1], node.position[0], node.position[2] || 100
                        )
                    );
                    
                    // Create polyline for the hyperedge
                    // Check if this is a network-based hyperedge
                    const isNetworkEdge = edgeData.type === 'service_group' || edgeData.type === 'subnet_group';
                    
                    if (edgeData.cardinality === 2) {
                        // Simple line for pairwise edges
                        // Safely compute human-readable signal strength and coherence
                        const edgeSignal = isFinite(edgeData.signal_strength) ? `${edgeData.signal_strength.toFixed(1)} dBm` : 'Unknown';
                        const edgeCoherence = (edgeData.metadata && isFinite(edgeData.metadata.coherence))
                            ? `${edgeData.metadata.coherence.toFixed(3)}`
                            : 'N/A';
                        
                        // Different colors for network vs RF edges
                        let edgeColor;
                        if (edgeData.type === 'service_group') {
                            edgeColor = Cesium.Color.LIME.withAlpha(0.7);
                        } else if (edgeData.type === 'subnet_group') {
                            edgeColor = Cesium.Color.CYAN.withAlpha(0.7);
                        } else {
                            edgeColor = this.getCardinalityColor(edgeData.cardinality);
                        }

                        // Check distance to avoid zero-length arc errors
                        const dist = Cesium.Cartesian3.distance(positions[0], positions[1]);
                        const safeArcType = dist < 5.0 ? Cesium.ArcType.NONE : Cesium.ArcType.GEODESIC;

                        const entity = viewer.entities.add({
                            id: edgeId,
                            name: isNetworkEdge 
                                ? `Network Edge: ${edgeData.service || edgeData.subnet || edgeData.type}`
                                : `Hyperedge (${edgeData.cardinality} nodes)`,
                            polyline: {
                                positions: positions,
                                width: isNetworkEdge ? 2 : Math.max(1, Math.abs(edgeData.signal_strength) / 30),
                                material: edgeColor,
                                arcType: safeArcType,
                                clampToGround: false
                            },
                            description: isNetworkEdge ? `
                                <h4>🔗 Network Relationship</h4>
                                <p><strong>Type:</strong> ${edgeData.type}</p>
                                <p><strong>Service/Subnet:</strong> ${edgeData.service || edgeData.subnet || 'N/A'}</p>
                                <p><strong>Connected Hosts:</strong> ${edgeData.nodes.length}</p>
                                <p><strong>Description:</strong> ${edgeData.metadata?.description || 'Network relationship'}</p>
                            ` : `
                                <h4>RF Hyperedge</h4>
                                <p><strong>Nodes:</strong> ${edgeData.nodes.join(', ')}</p>
                                <p><strong>Cardinality:</strong> ${edgeData.cardinality}</p>
                                <p><strong>Signal Strength:</strong> ${edgeSignal}</p>
                                <p><strong>Coherence:</strong> ${edgeCoherence}</p>
                            `
                        });
                        hypergraphEntities.add(entity);
                    } else {
                        // For higher-order hyperedges, create a star pattern
                        const center = this.calculateCenterPosition(positions);
                        const timestamp = Date.now();
                        
                        for (let i = 0; i < positions.length; i++) {
                            const starEdgeId = `hyperedge_star_${validNodeIds.sort().join('_')}_${i}_${timestamp}`;
                            
                            // Remove any existing star edge with same prefix
                            const existingStarEdge = viewer.entities.getById(starEdgeId);
                            if (existingStarEdge) {
                                viewer.entities.remove(existingStarEdge);
                                hypergraphEntities.delete(existingStarEdge);
                            }
                            
                            // Check distance from center to avoid zero-length arc errors
                            const dist = Cesium.Cartesian3.distance(center, positions[i]);
                            const safeArcType = dist < 5.0 ? Cesium.ArcType.NONE : Cesium.ArcType.GEODESIC;

                            const entity = viewer.entities.add({
                                id: starEdgeId,
                                name: `Hyperedge (${edgeData.cardinality} nodes)`,
                                polyline: {
                                    positions: [center, positions[i]],
                                    width: Math.max(2, Math.abs(edgeData.signal_strength) / 20),
                                    material: this.getCardinalityColor(edgeData.cardinality),
                                    arcType: safeArcType
                                }
                            });
                            hypergraphEntities.add(entity);
                        }
                        
                        // Add center point for higher-order edges
                        const centerEntityId = `hyperedge_center_${validNodeIds.sort().join('_')}_${timestamp}`;
                        const existingCenter = viewer.entities.getById(centerEntityId);
                        if (existingCenter) {
                            viewer.entities.remove(existingCenter);
                            hypergraphEntities.delete(existingCenter);
                        }
                        
                        const centerEntity = viewer.entities.add({
                            id: centerEntityId,
                            name: `Hyperedge Center (${edgeData.cardinality} nodes)`,
                            position: center,
                            point: {
                                pixelSize: 6,
                                color: this.getCardinalityColor(edgeData.cardinality),
                                outlineColor: Cesium.Color.WHITE,
                                outlineWidth: 1
                            }
                        });
                        hypergraphEntities.add(centerEntity);
                    }
                },
                
                // Highlight a central node with a halo effect
                highlightCentralNode: function(nodeId) {
                    const nodeEntity = viewer.entities.getById(`rf_node_${nodeId}`);
                    if (nodeEntity) {
                        // Add a pulsing halo
                        const haloEntity = viewer.entities.add({
                            id: `central_halo_${nodeId}`,
                            position: nodeEntity.position,
                            ellipse: {
                                semiMajorAxis: 50,
                                semiMinorAxis: 50,
                                material: Cesium.Color.GOLD.withAlpha(0.3),
                                outline: true,
                                outlineColor: Cesium.Color.GOLD
                            }
                        });
                        hypergraphEntities.add(haloEntity);
                    }
                },
                
                // Clear all hypergraph entities
                clearHypergraph: function() {
                    Array.from(hypergraphEntities).forEach(entity => {
                        viewer.entities.remove(entity);
                    });
                    hypergraphEntities.clear();
                },
                
                // Get color based on frequency
                getFrequencyColor: function(frequency) {
                    if (frequency < 30) return Cesium.Color.RED;      // HF
                    if (frequency < 300) return Cesium.Color.ORANGE;   // VHF
                    if (frequency < 3000) return Cesium.Color.YELLOW;  // UHF
                    return Cesium.Color.CYAN;  // SHF and above
                },
                
                // Get color based on hyperedge cardinality
                getCardinalityColor: function(cardinality) {
                    const colors = [
                        Cesium.Color.TRANSPARENT,
                        Cesium.Color.TRANSPARENT,
                        Cesium.Color.CYAN.withAlpha(0.7),      // 2-way
                        Cesium.Color.ORANGE.withAlpha(0.8),    // 3-way
                        Cesium.Color.MAGENTA.withAlpha(0.8),   // 4-way
                        Cesium.Color.RED.withAlpha(0.9)        // 5-way
                    ];
                    return colors[cardinality] || Cesium.Color.WHITE.withAlpha(0.5);
                },
                
                // Calculate center position for higher-order hyperedges
                calculateCenterPosition: function(positions) {
                    let x = 0, y = 0, z = 0;
                    for (const pos of positions) {
                        x += pos.x;
                        y += pos.y;
                        z += pos.z;
                    }
                    return new Cesium.Cartesian3(x / positions.length, y / positions.length, z / positions.length);
                },
                
                // Fit camera to show all hypergraph entities
                // Fixed: Uses geolocation data and caps altitude at sensible levels
                fitCameraToGraph: function(geoData = null) {
                    // Use this.viewer if available, otherwise fall back to global viewer
                    const activeViewer = this.viewer || window.viewer || viewer;
                    if (!activeViewer) {
                        console.warn('[Hypergraph] No viewer available for camera operation');
                        return;
                    }
                    
                    // Minimum sensible altitude to avoid CORS tile issues (40km = zoom level ~10)
                    const MIN_ALTITUDE = 40000;
                    const MAX_ALTITUDE = 5000000; // 5000km max
                    const DEFAULT_ALTITUDE = 100000; // 100km default regional view
                    
                    // If geolocation data was passed, use it directly for a regional view
                    if (geoData && geoData.lat && geoData.lon) {
                        console.log(`[Hypergraph] Flying to geolocated position: ${geoData.lat}, ${geoData.lon}`);
                        
                        // Use flyToWithReset if available, otherwise manual reset
                        if (typeof window.flyToWithReset === 'function') {
                            window.flyToWithReset({
                                destination: Cesium.Cartesian3.fromDegrees(geoData.lon, geoData.lat, DEFAULT_ALTITUDE),
                                orientation: {
                                    heading: 0,
                                    pitch: Cesium.Math.toRadians(-45),
                                    roll: 0
                                },
                                duration: 2.5,
                                complete: function() {
                                    if (window.HierarchicalRenderManager) {
                                        HierarchicalRenderManager.updateVisibilityForAltitude();
                                    }
                                }
                            });
                        } else {
                            // Fallback without flyToWithReset
                            activeViewer.camera.flyTo({
                                destination: Cesium.Cartesian3.fromDegrees(geoData.lon, geoData.lat, DEFAULT_ALTITUDE),
                                orientation: {
                                    heading: 0,
                                    pitch: Cesium.Math.toRadians(-45),
                                    roll: 0
                                },
                                duration: 2.5,
                                complete: function() {
                                    activeViewer.camera.lookAtTransform(Cesium.Matrix4.IDENTITY);
                                    activeViewer.trackedEntity = undefined;
                                    const ctl = activeViewer.scene.screenSpaceCameraController;
                                    ctl.enableRotate = ctl.enableTilt = ctl.enableZoom = ctl.enableTranslate = ctl.enableLook = true;
                                    
                                    if (window.HierarchicalRenderManager) {
                                        HierarchicalRenderManager.updateVisibilityForAltitude();
                                    }
                                }
                            });
                        }
                        return;
                    }
                    
                    if (hypergraphEntities.size === 0) {
                        console.log('No hypergraph entities to fit camera to');
                        return;
                    }
                    
                    try {
                        // Get all positions from entities
                        const positions = [];
                        Array.from(hypergraphEntities).forEach(entity => {
                            if (entity.position) {
                                const pos = entity.position.getValue(Cesium.JulianDate.now());
                                if (pos) {
                                    // Convert to cartographic to check for (0,0) null island positions
                                    const carto = Cesium.Cartographic.fromCartesian(pos);
                                    const lat = Cesium.Math.toDegrees(carto.latitude);
                                    const lon = Cesium.Math.toDegrees(carto.longitude);
                                    
                                    // Skip positions at (0,0) "Null Island" - these are simulation artifacts
                                    if (Math.abs(lat) > 0.1 || Math.abs(lon) > 0.1) {
                                        positions.push(pos);
                                    }
                                }
                            }
                        });
                        
                        if (positions.length > 0) {
                            const boundingSphere = Cesium.BoundingSphere.fromPoints(positions);
                            
                            // Cap the offset radius to prevent extreme zoom
                            let offsetRadius = boundingSphere.radius * 2.5;
                            offsetRadius = Math.max(offsetRadius, MIN_ALTITUDE);
                            offsetRadius = Math.min(offsetRadius, MAX_ALTITUDE);
                            
                            console.log(`[Hypergraph] Fitting camera to ${positions.length} entities at ${(offsetRadius/1000).toFixed(0)}km altitude`);
                            
                            activeViewer.camera.flyToBoundingSphere(boundingSphere, {
                                duration: 2.0,
                                offset: new Cesium.HeadingPitchRange(0, -Math.PI / 4, offsetRadius),
                                complete: function() {
                                    // Use ensureCameraFree for complete camera reset
                                    if (typeof ensureCameraFree === 'function') {
                                        ensureCameraFree();
                                    } else if (typeof window.resetCameraTransform === 'function') {
                                        window.resetCameraTransform();
                                    } else {
                                        activeViewer.camera.lookAtTransform(Cesium.Matrix4.IDENTITY);
                                        activeViewer.trackedEntity = undefined;
                                        const ctl = activeViewer.scene.screenSpaceCameraController;
                                        ctl.enableRotate = ctl.enableTilt = ctl.enableZoom = ctl.enableTranslate = ctl.enableLook = true;
                                    }
                                    if (window.HierarchicalRenderManager) {
                                        HierarchicalRenderManager.updateVisibilityForAltitude();
                                    }
                                }
                            });
                        } else {
                            console.warn('[Hypergraph] No valid positions found (filtered out null island coordinates)');
                            // Don't move camera if all positions are at (0,0)
                        }
                    } catch (error) {
                        console.warn('Error fitting camera to graph:', error);
                    }
                },
                
                // Load data from API response
                loadData: function(data) {
                    if (!data) return;
                    
                    // Clear existing visualization
                    this.clearHypergraph();
                    
                    // Add nodes
                    const nodes = data.nodes || [];
                    nodes.forEach(node => {
                        if (node && node.node_id) {
                            this.addRFNode(node);
                        }
                    });
                    
                    // Add hyperedges
                    const edges = data.hyperedges || [];
                    edges.forEach(edge => {
                        if (edge && edge.nodes) {
                            this.addHyperedge(edge, nodes);
                        }
                    });
                    
                    console.log(`Loaded hypergraph: ${nodes.length} nodes, ${edges.length} edges`);
                },
                
                // Perform nmap scan via API and visualize results
                performNmapScan: async function(targetNetwork, options = {}) {
                    console.log(`Performing nmap scan on ${targetNetwork}`, options);
                    
                    // Store geolocation data for camera positioning
                    let targetGeoData = null;
                    
                    try {
                        // First, geolocate the target to get meaningful coordinates
                        // This ensures the camera doesn't jump to (0,0) null island
                        try {
                            targetGeoData = await this.geolocateTarget(targetNetwork);
                            if (targetGeoData) {
                                console.log(`[Hypergraph] Target geolocated: ${targetGeoData.city || 'Unknown'}, ${targetGeoData.country || 'Unknown'}`);
                            }
                        } catch (geoError) {
                            console.warn('[Hypergraph] Geolocation failed, will use entity positions:', geoError);
                        }
                        
                        const response = await fetch('/api/network-hypergraph/scan', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                target: targetNetwork,
                                options: options.scanType === 'SERVICE_DETECTION' ? '-sV -sn -T4' : '-sn -T4',
                                reset: true,
                                // Pass geolocation to backend for proper node positioning
                                location: targetGeoData ? { lat: targetGeoData.lat, lon: targetGeoData.lon } : null
                            })
                        });
                        
                        if (!response.ok) {
                            throw new Error(`Scan failed: ${response.status}`);
                        }
                        
                        const data = await response.json();
                        
                        // Inject geolocation into nodes if backend didn't position them
                        if (targetGeoData && data.nodes) {
                            data.nodes = this.injectGeolocationIntoNodes(data.nodes, targetGeoData);
                        }
                        
                        // Load the results into visualization
                        this.loadData(data);
                        
                        // Only fit camera if we didn't already fly during geolocation
                        // (avoid redundant camera movements that can leave camera locked)
                        if (!targetGeoData || !targetGeoData.lat) {
                            setTimeout(() => this.fitCameraToGraph(null), 500);
                        } else {
                            // Just ensure camera is free without additional flight
                            setTimeout(() => {
                                if (typeof ensureCameraFree === 'function') {
                                    ensureCameraFree();
                                }
                            }, 100);
                        }
                        
                        return {
                            success: true,
                            scanId: data.session_id,
                            results: data,
                            hostsDiscovered: data.nodes?.length || 0,
                            hypergraphData: data,
                            geoData: targetGeoData
                        };
                    } catch (error) {
                        console.error('Nmap scan error:', error);
                        throw error;
                    }
                },
                
                // Geolocate a target network/host for proper camera positioning
                geolocateTarget: async function(target) {
                    // Extract IP or domain from target (handle CIDR notation)
                    let targetHost = target.split('/')[0];
                    
                    // Skip private network ranges - they don't have public geolocation
                    const privatePatterns = [
                        /^192\.168\./,
                        /^10\./,
                        /^172\.(1[6-9]|2[0-9]|3[0-1])\./,
                        /^127\./,
                        /^localhost$/i
                    ];
                    
                    if (privatePatterns.some(p => p.test(targetHost))) {
                        console.log(`[Hypergraph] Private network ${targetHost}, using default location`);
                        return { lat: 37.7749, lon: -122.4194, city: 'San Francisco', country: 'US', isDefault: true };
                    }
                    
                    // Try ip-api.com which supports both hostnames and IPs
                    try {
                        const response = await fetch(`http://ip-api.com/json/${targetHost}`);
                        if (response.ok) {
                            const data = await response.json();
                            if (data.status === 'success' && data.lat && data.lon) {
                                return {
                                    lat: data.lat,
                                    lon: data.lon,
                                    city: data.city,
                                    region: data.regionName,
                                    country: data.country,
                                    org: data.org || data.isp
                                };
                            }
                        }
                    } catch (e) {
                        console.warn('[Hypergraph] ip-api.com geolocation failed:', e);
                    }
                    
                    // Known hosts fallback
                    const knownHosts = {
                        'scanme.nmap.org': { lat: 45.5234, lon: -122.6762, city: 'Portland', country: 'US' },
                        'nmap.org': { lat: 45.5234, lon: -122.6762, city: 'Portland', country: 'US' },
                        'google.com': { lat: 37.4220, lon: -122.0841, city: 'Mountain View', country: 'US' },
                        'example.com': { lat: 34.0522, lon: -118.2437, city: 'Los Angeles', country: 'US' }
                    };
                    
                    const hostLower = targetHost.toLowerCase();
                    if (knownHosts[hostLower]) {
                        console.log(`[Hypergraph] Using known location for ${targetHost}`);
                        return knownHosts[hostLower];
                    }
                    
                    return null;
                },
                
                // Inject geolocation into nodes that have default (0,0) positions
                injectGeolocationIntoNodes: function(nodes, geoData) {
                    if (!nodes || !geoData) return nodes;
                    
                    const baseLat = geoData.lat;
                    const baseLon = geoData.lon;
                    
                    return nodes.map((node, index) => {
                        // Check if node has valid position (not at 0,0)
                        const hasValidPosition = node.position && 
                            (Math.abs(node.position.lat) > 0.1 || Math.abs(node.position.lon) > 0.1);
                        
                        if (!hasValidPosition) {
                            // Distribute nodes in a small area around the geolocated center
                            const spread = 0.02; // ~2km spread
                            const angle = (index / nodes.length) * 2 * Math.PI;
                            const radius = spread * (0.3 + Math.random() * 0.7);
                            
                            node.position = {
                                lat: baseLat + radius * Math.sin(angle),
                                lon: baseLon + radius * Math.cos(angle)
                            };
                        }
                        
                        return node;
                    });
                },
                
                // Update hypergraph with nDPI protocol data
                updateWithProtocolData: async function(analysis) {
                    if (!analysis || !analysis.protocols) {
                        console.warn('[Hypergraph] No protocol data to update');
                        return;
                    }
                    
                    console.log('[Hypergraph] Updating with protocol data:', analysis.protocols.length, 'protocols');
                    
                    // Create a protocol distribution node if not exists
                    const protocolNodeId = `protocol_dist_${analysis.target || 'unknown'}`;
                    const existingNode = viewer.entities.getById(`rf_node_${protocolNodeId}`);
                    
                    if (!existingNode) {
                        // Create a central protocol distribution node
                        this.addRFNode({
                            node_id: protocolNodeId,
                            frequency: 0,
                            signal_strength: -50,
                            position: { lat: 37.7749, lon: -122.4194 }, // Default position
                            type: 'protocol_distribution',
                            protocols: analysis.protocols
                        });
                    }
                    
                    // Add protocol-weighted edges based on traffic
                    analysis.protocols.forEach((proto, idx) => {
                        if (proto.percentage > 5) { // Only show significant protocols
                            const protoColor = this.getProtocolColor(proto.name);
                            const edgeWidth = Math.max(1, proto.percentage / 10);
                            
                            // Log protocol as a metric
                            if (window.logMetric) {
                                window.logMetric('hypergraph', `protocol_${proto.name.toLowerCase().replace(/[^a-z0-9]/g, '_')}`, proto.percentage);
                            }
                        }
                    });
                    
                    // Update visualization
                    console.log('[Hypergraph] Protocol data integrated successfully');
                },
                
                // Add protocol-weighted edges between nodes
                addProtocolEdges: function(target, protocols) {
                    if (!protocols || protocols.length === 0) return;
                    
                    // Check if altitude allows hyperedge display
                    if (window.HierarchicalRenderManager && !HierarchicalRenderManager.shouldShowDetail('hyperedges')) {
                        console.log('[Hypergraph] Skipping protocol edges at global altitude');
                        return;
                    }
                    
                    protocols.forEach(proto => {
                        if (proto.percentage < 5) return; // Skip minor protocols
                        
                        const edgeColor = this.getProtocolColor(proto.name);
                        const edgeWidth = Math.max(1, Math.min(6, proto.percentage / 15));
                        const opacity = Math.min(0.9, 0.3 + proto.percentage / 100);
                        
                        // Create visual representation
                        const edgeId = `protocol_edge_${target}_${proto.name.replace(/[^a-z0-9]/gi, '')}`;
                        
                        // Remove existing edge if present
                        const existing = viewer.entities.getById(edgeId);
                        if (existing) {
                            viewer.entities.remove(existing);
                            hypergraphEntities.delete(existing);
                        }
                        
                        // Add new edge representation (ring around target area)
                        const ringEntity = viewer.entities.add({
                            id: edgeId,
                            name: `${proto.name} Traffic (${proto.percentage}%)`,
                            position: Cesium.Cartesian3.fromDegrees(-122.4194, 37.7749, 1000),
                            ellipse: {
                                semiMajorAxis: 5000 + proto.percentage * 100,
                                semiMinorAxis: 5000 + proto.percentage * 100,
                                height: proto.percentage * 50,
                                material: edgeColor.withAlpha(opacity * 0.3),
                                outline: true,
                                outlineColor: edgeColor.withAlpha(opacity),
                                outlineWidth: edgeWidth
                            },
                            label: {
                                text: `${proto.name}: ${proto.percentage.toFixed(1)}%`,
                                font: '10px sans-serif',
                                fillColor: edgeColor,
                                outlineColor: Cesium.Color.BLACK,
                                outlineWidth: 2,
                                style: Cesium.LabelStyle.FILL_AND_OUTLINE,
                                verticalOrigin: Cesium.VerticalOrigin.BOTTOM,
                                pixelOffset: new Cesium.Cartesian2(0, -20),
                                show: window.HierarchicalRenderManager ? 
                                    HierarchicalRenderManager.shouldShowDetail('labels') : true
                            }
                        });
                        
                        hypergraphEntities.add(ringEntity);
                    });
                    
                    console.log(`[Hypergraph] Added ${protocols.filter(p => p.percentage >= 5).length} protocol edges for ${target}`);
                },
                
                // Get color for protocol type
                getProtocolColor: function(protocolName) {
                    const name = protocolName.toUpperCase();
                    
                    if (name.includes('HTTP') && !name.includes('HTTPS')) return Cesium.Color.LIME;
                    if (name.includes('HTTPS') || name.includes('TLS') || name.includes('SSL')) return Cesium.Color.GREEN;
                    if (name.includes('DNS')) return Cesium.Color.CYAN;
                    if (name.includes('SSH')) return Cesium.Color.BLUE;
                    if (name.includes('FTP')) return Cesium.Color.ORANGE;
                    if (name.includes('SMTP') || name.includes('EMAIL')) return Cesium.Color.YELLOW;
                    if (name.includes('QUIC')) return Cesium.Color.MAGENTA;
                    if (name.includes('UDP')) return Cesium.Color.PURPLE;
                    if (name.includes('TCP')) return Cesium.Color.AQUA;
                    if (name.includes('UNKNOWN')) return Cesium.Color.RED;
                    
                    return Cesium.Color.WHITE;
                },
                
                // Setup altitude listener for hypergraph edges
                setupAltitudeListener: function() {
                    const self = this;
                    
                    document.addEventListener('altitudeChanged', function(e) {
                        const { level } = e.detail;
                        const showEdges = window.HierarchicalRenderManager ? 
                            HierarchicalRenderManager.shouldShowDetail('hyperedges') : true;
                        const showLabels = window.HierarchicalRenderManager ? 
                            HierarchicalRenderManager.shouldShowDetail('labels') : true;
                        
                        // Update visibility of all hypergraph entities based on altitude
                        Array.from(hypergraphEntities).forEach(entity => {
                            // Skip node entities (keep those visible)
                            if (entity.id && entity.id.startsWith('rf_node_')) return;
                            
                            // Toggle hyperedge visibility
                            if (entity.polyline) {
                                entity.show = showEdges;
                            }
                            
                            // Toggle labels
                            if (entity.label) {
                                entity.label.show = showLabels;
                            }
                            
                            // Toggle ellipses (protocol rings)
                            if (entity.ellipse && entity.id?.includes('protocol_edge')) {
                                entity.show = showEdges;
                            }
                        });
                        
                        // At global level, aggregate edges
                        if (level === 'GLOBAL') {
                            self.aggregateEdgesForGlobalView();
                        }
                    });
                    
                    console.log('[Hypergraph] Altitude listener registered');
                },
                
                // Aggregate hyperedges at global view to reduce clutter
                aggregateEdgesForGlobalView: function() {
                    // This could create summary polylines or hide individual edges
                    // For now, individual edges are hidden via the altitude listener
                    console.log('[Hypergraph] Aggregating edges for global view');
                }
            };
        };
        
        // Initialize hypergraph visualization (called when panel is shown)
        function initializeHypergraphVisualization() {
            // Initialize the Cesium-based visualizer if not already done
            if (!hypergraphVisualizer && viewer && window.RF_SCYTHE.createHypergraphVisualizer) {
                hypergraphVisualizer = window.RF_SCYTHE.createHypergraphVisualizer(viewer);
                
                // Setup altitude listener for hierarchical edge rendering
                if (hypergraphVisualizer.setupAltitudeListener) {
                    hypergraphVisualizer.setupAltitudeListener();
                }
            }
            
            // Enable the hypergraph overlay checkbox
            const overlayCheckbox = document.getElementById('showHypergraphOverlay');
            if (overlayCheckbox && !overlayCheckbox.checked) {
                overlayCheckbox.checked = true;
                overlayCheckbox.dispatchEvent(new Event('change'));
            }
            
            // Start updates
            startHypergraphUpdates();
            
            console.log('Hypergraph visualization initialized with altitude-based rendering');
        }
        
        // Lightweight WebGL2 instanced renderer for large hypergraphs
        class WebGLHypergraphRenderer {
            constructor(container, opts = {}) {
                this.container = container || document.body;
                this.opts = Object.assign({
                    initialCapacity: 16384,
                    texelsPerNode: 4,
                    // adaptive parameters
                    maxSamples: 120,
                    adaptiveMinPartial: 4,
                    adaptiveMaxPartial: 4096,
                    // bytes-based adaptive budget (preferred)
                    adaptiveMinBytesPerFrame: 4 * 16, // 4 nodes worth (approx)
                    adaptiveMaxBytesPerFrame: 1024 * 1024 * 4, // 4MB
                    adaptiveMinMergeWindow: 0,
                    adaptiveMaxMergeWindow: 256,
                    safetyMs: 2.0
                }, opts);
                this.canvas = null;
                this.gl = null;
                this.nodeIdToIndex = new Map();
                this.indexToId = [];
                this.nodeCount = 0;
                this.capacity = 0;

                // Node GPU packing: texelsPerNode rows (width=4) per node
                this.texelsPerNode = this.opts.texelsPerNode; // 4 texels (RGBA32F each)
                this.nodeData = null; // Float32Array (capacity * texelsPerNode * 4)
                this.nodeTexture = null;

                // Edge storage (per-edge: srcIndex, tgtIndex, weight, kind)
                this.edgeIdToIndex = new Map();
                this.edgeIndexToId = [];
                this.edgeCount = 0;
                this.edgeCapacity = 0;
                this.edgeData = null; // Float32Array (edgeCapacity * 4)
                this.edgeBuffer = null;

                this._needsNodeUpload = false;
                this.changedNodeRows = new Set();
                this.changedEdgeIndices = new Set();
                this._needsEdgeUpload = false;

                // derived constants (will be updated in ensureCapacity)
                this.floatsPerNode = this.texelsPerNode * 4;
                this.bytesPerNode = this.floatsPerNode * 4; // Float32 = 4 bytes

                this.initCanvas();
                this.initGL();
                this.ensureCapacity(this.opts.initialCapacity);
                // Debug overlay
                try{
                    this.debugOverlay = document.createElement('div');
                    this.debugOverlay.style.position = 'absolute';
                    this.debugOverlay.style.right = '8px';
                    this.debugOverlay.style.top = '8px';
                    this.debugOverlay.style.zIndex = 999999;
                    this.debugOverlay.style.padding = '8px';
                    this.debugOverlay.style.background = 'rgba(0,0,0,0.6)';
                    this.debugOverlay.style.color = '#fff';
                    this.debugOverlay.style.fontFamily = 'monospace';
                    this.debugOverlay.style.fontSize = '11px';
                    this.debugOverlay.style.lineHeight = '1.2';
                    this.debugOverlay.style.borderRadius = '4px';
                    this.debugOverlay.style.pointerEvents = 'none';
                    this.container.appendChild(this.debugOverlay);
                }catch(e){ this.debugOverlay = null; }
                this._lastRenderStart = performance.now();
            }

            initCanvas() {
                this.canvas = document.createElement('canvas');
                this.canvas.style.position = 'absolute';
                this.canvas.style.left = '0';
                this.canvas.style.top = '0';
                this.canvas.style.width = '100%';
                this.canvas.style.height = '100%';
                this.canvas.style.pointerEvents = 'auto';
                this.container.appendChild(this.canvas);
                window.addEventListener('resize', () => this._resize());
                this._resize();
            }

            _resize() {
                const dpr = window.devicePixelRatio || 1;
                const w = Math.floor(this.canvas.clientWidth * dpr);
                const h = Math.floor(this.canvas.clientHeight * dpr);
                if (this.canvas.width !== w || this.canvas.height !== h) {
                    this.canvas.width = w;
                    this.canvas.height = h;
                    if (this.gl) this.gl.viewport(0,0,w,h);
                }
            }

            initGL() {
                try {
                    this.gl = this.canvas.getContext('webgl2', {antialias: false, preserveDrawingBuffer: false});
                } catch (e) {
                    this.gl = null;
                }
                if (!this.gl) return;
                const gl = this.gl;

                // Node program: fetch per-node attributes from a RGBA32F texture (width=4, height=nodeCount)
                const nodeVS = `#version 300 es
                precision highp float;
                uniform mat4 u_viewProj;
                uniform sampler2D u_nodeTex;
                uniform int u_texWidth; // should be 4
                out vec4 v_color;
                void main(){
                  int nodeIndex = int(gl_InstanceID);
                  ivec2 t0 = ivec2(0, nodeIndex);
                  ivec2 t1 = ivec2(1, nodeIndex);
                  ivec2 t2 = ivec2(2, nodeIndex);
                  vec4 tex0 = texelFetch(u_nodeTex, t0, 0);
                  vec4 tex1 = texelFetch(u_nodeTex, t1, 0);
                  vec4 tex2 = texelFetch(u_nodeTex, t2, 0);
                  // tex0: pos.xyz, size
                  vec3 pos = tex0.xyz;
                  float size = tex0.w;
                  v_color = tex1;
                  vec4 world = vec4(pos, 1.0);
                  gl_Position = u_viewProj * world;
                  gl_PointSize = max(1.0, size);
                }`;

                const nodeFS = `#version 300 es
                precision mediump float;
                in vec4 v_color;
                out vec4 outColor;
                void main(){ outColor = v_color; }`;

                this.nodeProgram = this._compileProgram(nodeVS, nodeFS);

                // Edge program: per-instance attributes sourceIndex,targetIndex,weight,kind
                const edgeVS = `#version 300 es
                precision highp float;
                in float a_vtx; // 0 or 1
                in float i_src; // source index
                in float i_tgt; // target index
                uniform mat4 u_viewProj;
                uniform sampler2D u_nodeTex;
                out vec4 v_color;
                void main(){
                  int src = int(i_src + 0.5);
                  int tgt = int(i_tgt + 0.5);
                  vec4 s0 = texelFetch(u_nodeTex, ivec2(0, src), 0);
                  vec4 s1 = texelFetch(u_nodeTex, ivec2(1, src), 0);
                  vec4 t0 = texelFetch(u_nodeTex, ivec2(0, tgt), 0);
                  vec4 t1 = texelFetch(u_nodeTex, ivec2(1, tgt), 0);
                  vec3 p1 = s0.xyz;
                  vec3 p2 = t0.xyz;
                  float v = a_vtx; // 0 or 1
                  vec3 pos = mix(p1, p2, v);
                  gl_Position = u_viewProj * vec4(pos, 1.0);
                  v_color = mix(s1, t1, 0.5);
                }`;

                const edgeFS = `#version 300 es
                precision mediump float;
                in vec4 v_color;
                out vec4 outColor;
                void main(){ outColor = v_color; }`;

                this.edgeProgram = this._compileProgram(edgeVS, edgeFS);

                // Common buffers
                this.edgeBuffer = gl.createBuffer();

                // Base geometry: for edges a two-vertex line [0,1]; for nodes a single point
                this.basePointBuf = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, this.basePointBuf);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0.0, 1.0]), gl.STATIC_DRAW);

                // VAOs
                this.vaoNode = gl.createVertexArray();
                gl.bindVertexArray(this.vaoNode);
                // bind base point (single vertex)
                const nodeBaseLoc = 0; // not used but keep attribute slot
                gl.bindBuffer(gl.ARRAY_BUFFER, this.basePointBuf);
                gl.enableVertexAttribArray(nodeBaseLoc);
                gl.vertexAttribPointer(nodeBaseLoc, 1, gl.FLOAT, false, 0, 0);
                gl.vertexAttribDivisor(nodeBaseLoc, 0);
                gl.bindVertexArray(null);

                this.vaoEdge = gl.createVertexArray();
                gl.bindVertexArray(this.vaoEdge);
                // base two-vertex attribute a_vtx
                const aVtxLoc = gl.getAttribLocation(this.edgeProgram, 'a_vtx');
                gl.bindBuffer(gl.ARRAY_BUFFER, this.basePointBuf);
                gl.enableVertexAttribArray(aVtxLoc);
                gl.vertexAttribPointer(aVtxLoc, 1, gl.FLOAT, false, 0, 0);
                gl.vertexAttribDivisor(aVtxLoc, 0);

                // per-instance edge data will be bound at render time
                gl.bindVertexArray(null);

                // Texture for node attributes
                this.nodeTexture = gl.createTexture();
                gl.bindTexture(gl.TEXTURE_2D, this.nodeTexture);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                gl.bindTexture(gl.TEXTURE_2D, null);

                // Uniform locations
                this.u_node_viewProj = gl.getUniformLocation(this.nodeProgram, 'u_viewProj');
                this.u_node_tex = gl.getUniformLocation(this.nodeProgram, 'u_nodeTex');
                this.u_edge_viewProj = gl.getUniformLocation(this.edgeProgram, 'u_viewProj');
                this.u_edge_tex = gl.getUniformLocation(this.edgeProgram, 'u_nodeTex');

                // Runtime metrics for adaptive partial uploads
                this.metrics = {
                    frameTimes: [],    // ms
                    perRowUploadTimes: [], // ms (legacy)
                    perByteUploadTimes: [], // ms per byte
                    batchOverheads: [],
                    maxSamples: this.opts.maxSamples
                };
                this._lastAdaptiveMax = this.opts.adaptiveMaxPartial || 128;
                this._lastAdaptiveMaxBytes = this.opts.adaptiveMaxBytesPerFrame || null;
            }

            computeAdaptiveMergeWindow() {
                // Estimate mergeWindow = floor(avgBatchOverhead / avgPerRow)
                const avgPerRow = this._movingAvg(this.metrics.perRowUploadTimes) || 0;
                if (avgPerRow <= 0) return 4;
                const avgOverhead = this._movingAvg(this.metrics.batchOverheads) || 0.0;
                // If no observed overhead, keep small default
                if (avgOverhead <= 0) return this.opts.adaptiveMinMergeWindow || 4;
                let calc = Math.floor(avgOverhead / avgPerRow);
                const min = this.opts.adaptiveMinMergeWindow || 0, max = this.opts.adaptiveMaxMergeWindow || 256;
                calc = Math.max(min, Math.min(max, calc));
                return calc;
            }

            _compileProgram(vsSource, fsSource){
                const gl = this.gl;
                function compile(type, src){ const sh = gl.createShader(type); gl.shaderSource(sh, src); gl.compileShader(sh); if(!gl.getShaderParameter(sh, gl.COMPILE_STATUS)){ console.error(gl.getShaderInfoLog(sh)); gl.deleteShader(sh); return null;} return sh; }
                const sv = compile(gl.VERTEX_SHADER, vsSource);
                const sf = compile(gl.FRAGMENT_SHADER, fsSource);
                const p = gl.createProgram(); gl.attachShader(p, sv); gl.attachShader(p, sf); gl.linkProgram(p); if(!gl.getProgramParameter(p, gl.LINK_STATUS)){ console.error(gl.getProgramInfoLog(p)); return null;} return p;
            }

            ensureCapacity(cap){
                if (cap <= this.capacity) return;
                const newCap = Math.max(cap, Math.floor(this.capacity*1.5)||1);
                const floatsPerNode = this.texelsPerNode * 4; // 4 texels * 4 floats
                this.floatsPerNode = floatsPerNode;
                this.bytesPerNode = floatsPerNode * 4;
                const newData = new Float32Array(newCap * floatsPerNode);
                if (this.nodeData) newData.set(this.nodeData);
                this.nodeData = newData;
                this.capacity = newCap;
                // recreate texture with new height
                const gl = this.gl; if (!gl) return;
                gl.bindTexture(gl.TEXTURE_2D, this.nodeTexture);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA32F, 4, this.capacity, 0, gl.RGBA, gl.FLOAT, this.nodeData);
                gl.bindTexture(gl.TEXTURE_2D, null);
            }

            ensureEdgeCapacity(cap){
                if (cap <= this.edgeCapacity) return;
                const newCap = Math.max(cap, Math.floor(this.edgeCapacity*1.5)||1);
                const newEdgeData = new Float32Array(newCap * 4);
                if (this.edgeData) newEdgeData.set(this.edgeData);
                this.edgeData = newEdgeData;
                this.edgeCapacity = newCap;
                const gl = this.gl; if (!gl) return;
                gl.bindBuffer(gl.ARRAY_BUFFER, this.edgeBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, this.edgeData.byteLength, gl.DYNAMIC_DRAW);
            }

            packNodeAtIndex(idx, node){
                const floatsPerNode = this.texelsPerNode * 4;
                const base = idx * floatsPerNode;
                const pos = [node.x||0, node.y||0, node.z||0];
                const size = node.size || 1.0;
                const color = node.color || [1,1,1,1];
                const risk = node.risk || 0.0;
                const signal = node.signalStrength || 0.0;
                const centrality = node.centrality || 0.0;
                const kind = node.kind || 0;
                const flags = node.flags || 0;
                // texel0
                this.nodeData[base+0] = pos[0];
                this.nodeData[base+1] = pos[1];
                this.nodeData[base+2] = pos[2];
                this.nodeData[base+3] = size;
                // texel1 = color
                this.nodeData[base+4] = color[0]; this.nodeData[base+5] = color[1]; this.nodeData[base+6] = color[2]; this.nodeData[base+7] = color[3];
                // texel2 = analytics
                this.nodeData[base+8] = risk; this.nodeData[base+9] = signal; this.nodeData[base+10] = centrality; this.nodeData[base+11] = kind;
                // texel3 = flags + padding
                this.nodeData[base+12] = flags; this.nodeData[base+13] = 0; this.nodeData[base+14] = 0; this.nodeData[base+15] = 0;
                this._needsNodeUpload = true;
                if(!this.changedNodeRows) this.changedNodeRows = new Set();
                this.changedNodeRows.add(idx);
            }

            addOrUpdateNode(node){
                const id = node.id;
                if (!this.nodeIdToIndex.has(id)) {
                    const idx = this.nodeCount;
                    this.nodeIdToIndex.set(id, idx);
                    this.indexToId[idx] = id;
                    this.nodeCount++;
                    if (this.nodeCount > this.capacity) this.ensureCapacity(this.nodeCount*2);
                }
                const idx = this.nodeIdToIndex.get(id);
                this.packNodeAtIndex(idx, node);
            }

            removeNode(id){
                const idx = this.nodeIdToIndex.get(id);
                if (idx === undefined) return;
                const lastIdx = this.nodeCount - 1;
                if (idx !== lastIdx) {
                    // copy last node row into idx
                    const floatsPerNode = this.texelsPerNode * 4;
                    const dst = idx * floatsPerNode;
                    const src = lastIdx * floatsPerNode;
                    for (let i=0;i<floatsPerNode;i++) this.nodeData[dst+i] = this.nodeData[src+i];
                    const lastId = this.indexToId[lastIdx];
                    this.indexToId[idx] = lastId;
                    this.nodeIdToIndex.set(lastId, idx);
                    if(!this.changedNodeRows) this.changedNodeRows = new Set();
                    this.changedNodeRows.add(idx);
                }
                this.nodeIdToIndex.delete(id);
                this.indexToId.pop();
                this.nodeCount--;
                this._needsNodeUpload = true;
            }

            // Helper: compute moving average
            _movingAvg(arr) {
                if(!arr || arr.length === 0) return 0;
                const l = arr.length; let s = 0;
                for(let i=0;i<l;i++) s += arr[i];
                return s / l;
            }

            updateDebugOverlay(){
                if(!this.debugOverlay) return;
                const avgFrame = this._movingAvg(this.metrics.frameTimes) || 0;
                const avgRow = this._movingAvg(this.metrics.perRowUploadTimes) || 0;
                const avgBatch = this._movingAvg(this.metrics.batchOverheads) || 0;
                const avgPerByte = this._movingAvg(this.metrics.perByteUploadTimes) || ((avgRow || 0) / (this.bytesPerNode || 64));
                const maxPartial = this.computeAdaptiveMaxPartial();
                const mergeWindow = this.computeAdaptiveMergeWindow();
                const changedRows = (this.changedNodeRows && this.changedNodeRows.size) ? this.changedNodeRows.size : 0;
                const changedEdges = (this.changedEdgeIndices && this.changedEdgeIndices.size) ? this.changedEdgeIndices.size : 0;
                const lines = [];
                lines.push('FPS (approx): ' + (avgFrame>0 ? (1000/avgFrame).toFixed(1) : '---'));
                lines.push('Avg render ms: ' + avgFrame.toFixed(2));
                lines.push('Avg upload ms/byte: ' + (avgPerByte>0 ? avgPerByte.toExponential(2) : '---'));
                lines.push('Avg batch overhead ms: ' + avgBatch.toFixed(3));
                lines.push('Adaptive bytes budget (last): ' + (this._lastAdaptiveMaxBytes ? (this._lastAdaptiveMaxBytes + ' B') : '---'));
                lines.push('Adaptive maxPartial (rows): ' + maxPartial);
                lines.push('Adaptive mergeWindow: ' + mergeWindow);
                lines.push('Changed rows: ' + changedRows + ' | Changed edges: ' + changedEdges);
                lines.push('Bytes/node: ' + (this.bytesPerNode || '---'));
                this.debugOverlay.textContent = lines.join('\n');
            }

            // Compute adaptive max rows allowed based on frame budget and per-row upload time
            computeAdaptiveMaxPartial() {
                // Preferred: compute bytes budget then convert to rows
                const targetFrameMs = 1000/60; // aim for 60fps
                const safetyMs = this.opts.safetyMs || 2.0; // reserve a small margin
                const avgFrame = this._movingAvg(this.metrics.frameTimes) || 0;
                const allowedMs = Math.max(0, targetFrameMs - avgFrame - safetyMs);

                // avg per-byte time (ms/byte) from metrics, fallback to per-row-derived
                const avgPerByte = this._movingAvg(this.metrics.perByteUploadTimes) || ((this._movingAvg(this.metrics.perRowUploadTimes) || 0.02) / (this.bytesPerNode || 64));
                if (!avgPerByte || avgPerByte <= 0) {
                    // fallback to older row-based behavior
                    const fallbackRows = this._lastAdaptiveMax || this.opts.adaptiveMaxPartial || 128;
                    return fallbackRows;
                }

                let calcBytes = Math.floor(allowedMs / avgPerByte);
                const minBytes = this.opts.adaptiveMinBytesPerFrame || Math.max(1, (this.opts.adaptiveMinPartial || 4) * (this.bytesPerNode || 64));
                const maxBytes = this.opts.adaptiveMaxBytesPerFrame || Math.max(1024, (this.opts.adaptiveMaxPartial || 4096) * (this.bytesPerNode || 64));
                calcBytes = Math.max(minBytes, Math.min(maxBytes, calcBytes || 0));
                this._lastAdaptiveMaxBytes = calcBytes;

                // Convert bytes to rows
                const rows = Math.max(1, Math.floor(calcBytes / (this.bytesPerNode || 64)));
                // clamp to legacy min/max rows as well
                const minRows = this.opts.adaptiveMinPartial || 4;
                const maxRows = this.opts.adaptiveMaxPartial || 4096;
                const finalRows = Math.max(minRows, Math.min(maxRows, rows));
                this._lastAdaptiveMax = finalRows;
                return finalRows;
            }

            // Allow runtime option updates
            setOptions(newOpts) {
                this.opts = Object.assign(this.opts || {}, newOpts || {});
                this.metrics.maxSamples = this.opts.maxSamples || this.metrics.maxSamples;
            }

            addOrUpdateEdge(edge){
                const id = edge.id;
                if (!this.edgeIdToIndex.has(id)) {
                    const idx = this.edgeCount;
                    this.edgeIdToIndex.set(id, idx);
                    this.edgeIndexToId[idx] = id;
                    this.edgeCount++;
                    if (this.edgeCount > this.edgeCapacity) this.ensureEdgeCapacity(this.edgeCount*2);
                }
                const idx = this.edgeIdToIndex.get(id);
                const base = idx*4;
                const s = this.nodeIdToIndex.get(edge.source) ?? 0;
                const t = this.nodeIdToIndex.get(edge.target) ?? 0;
                this.edgeData[base+0] = s;
                this.edgeData[base+1] = t;
                this.edgeData[base+2] = edge.weight || 1.0;
                this.edgeData[base+3] = edge.kind || 0;
                this._needsEdgeUpload = true;
                if(!this.changedEdgeIndices) this.changedEdgeIndices = new Set();
                this.changedEdgeIndices.add(idx);
            }

            removeEdge(id){
                const idx = this.edgeIdToIndex.get(id);
                if (idx === undefined) return;
                const lastIdx = this.edgeCount - 1;
                if (idx !== lastIdx) {
                    const dst = idx*4; const src = lastIdx*4;
                    this.edgeData[dst]=this.edgeData[src]; this.edgeData[dst+1]=this.edgeData[src+1]; this.edgeData[dst+2]=this.edgeData[src+2]; this.edgeData[dst+3]=this.edgeData[src+3];
                    const lastId = this.edgeIndexToId[lastIdx];
                    this.edgeIndexToId[idx] = lastId;
                    this.edgeIdToIndex.set(lastId, idx);
                }
                this.edgeIdToIndex.delete(id);
                this.edgeIndexToId.pop();
                this.edgeCount--;
                this._needsEdgeUpload = true;
                if(!this.changedEdgeIndices) this.changedEdgeIndices = new Set();
                this.changedEdgeIndices.add(idx);
            }

            applyDiff(diff){
                if (!diff) return;
                const nodes = diff.nodes || {created:[],updated:[],deleted:[]};
                (nodes.deleted||[]).forEach(id=>{ const idVal = (typeof id === 'string')? id : (id.id||id); this.removeNode(idVal); });
                (nodes.created||[]).forEach(n=> this.addOrUpdateNode(n));
                (nodes.updated||[]).forEach(n=> this.addOrUpdateNode(n));

                const edges = diff.edges || {created:[],updated:[],deleted:[]};
                (edges.deleted||[]).forEach(id=>{ const idVal = (typeof id === 'string')? id : (id.id||id); this.removeEdge(idVal); });
                (edges.created||[]).forEach(e=> this.addOrUpdateEdge(e));
                (edges.updated||[]).forEach(e=> this.addOrUpdateEdge(e));

                this._uploadIfNeeded();
            }

            _uploadIfNeeded(){
                const gl = this.gl; if (!gl) return;
                // Track bytes uploaded in this frame to respect budget
                let bytesUploadedThisFrame = 0;

                // --- Node uploads (texSubImage2D) using bytes-based adaptivity ---
                if (this._needsNodeUpload) {
                    gl.bindTexture(gl.TEXTURE_2D, this.nodeTexture);
                    const floatsPerNode = this.texelsPerNode * 4;
                    const bytesPerNode = this.bytesPerNode || (floatsPerNode * 4);
                    const changedCount = (this.changedNodeRows && this.changedNodeRows.size) ? this.changedNodeRows.size : 0;
                    // compute adaptive budget (also updates _lastAdaptiveMaxBytes)
                    const maxRowsFromBytes = this.computeAdaptiveMaxPartial();
                    const maxBytesBudget = this._lastAdaptiveMaxBytes || (maxRowsFromBytes * bytesPerNode);

                    if (changedCount > 0) {
                        const totalChangedBytes = changedCount * bytesPerNode;
                        // If small enough to upload partially within budget, do batched partial uploads
                        if (totalChangedBytes > 0 && totalChangedBytes <= maxBytesBudget) {
                            gl.pixelStorei(gl.UNPACK_ALIGNMENT, 4);
                            const baselineAvgByte = this._movingAvg(this.metrics.perByteUploadTimes) || ((this._movingAvg(this.metrics.perRowUploadTimes) || 0.02) / (bytesPerNode || 64));
                            const mergeWindow = this.computeAdaptiveMergeWindow();
                            const rows = Array.from(this.changedNodeRows).map(r=>Number(r)).sort((a,b)=>a-b);
                            let i = 0;
                            while(i < rows.length){
                                let start = rows[i];
                                let end = start;
                                i++;
                                while(i < rows.length){
                                    const gap = rows[i] - end - 1;
                                    if (rows[i] === end + 1) { end = rows[i]; i++; continue; }
                                    if (gap > 0 && gap <= mergeWindow) { end = rows[i]; i++; continue; }
                                    break;
                                }
                                const rowCount = end - start + 1;
                                const t0 = performance.now();
                                const offsetFloats = start * floatsPerNode;
                                const lengthFloats = rowCount * floatsPerNode;
                                const slice = this.nodeData.subarray(offsetFloats, offsetFloats + lengthFloats);
                                gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, start, 4, rowCount, gl.RGBA, gl.FLOAT, slice);
                                const t1 = performance.now();
                                const batchDt = t1 - t0;
                                const bytesThisBatch = rowCount * bytesPerNode;
                                // record per-byte upload time
                                const perByte = batchDt / bytesThisBatch;
                                const pba = this.metrics.perByteUploadTimes; pba.push(perByte); if (pba.length > this.metrics.maxSamples) pba.shift();
                                // estimate call overhead
                                const baseline = baselineAvgByte * bytesThisBatch;
                                const overhead = Math.max(0, batchDt - baseline);
                                const bh = this.metrics.batchOverheads; bh.push(overhead); if (bh.length > this.metrics.maxSamples) bh.shift();
                                bytesUploadedThisFrame += bytesThisBatch;
                            }
                            this.changedNodeRows.clear();
                        } else {
                            // fallback: full texture upload
                            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA32F, 4, this.capacity, 0, gl.RGBA, gl.FLOAT, this.nodeData);
                            if (this.changedNodeRows) this.changedNodeRows.clear();
                            bytesUploadedThisFrame += (this.capacity * bytesPerNode) || 0;
                        }
                    }
                    gl.bindTexture(gl.TEXTURE_2D, null);
                    this._needsNodeUpload = false;
                }

                // --- Edge uploads: batch bufferSubData with merged index ranges ---
                if (this._needsEdgeUpload) {
                    gl.bindBuffer(gl.ARRAY_BUFFER, this.edgeBuffer);
                    const bytesPerEdge = 4 * 4; // 4 floats * 4 bytes
                    const changedEdges = (this.changedEdgeIndices && this.changedEdgeIndices.size) ? this.changedEdgeIndices.size : 0;
                    // ensure adaptive budget computed
                    this.computeAdaptiveMaxPartial();
                    const maxBytesBudget = this._lastAdaptiveMaxBytes || (this._lastAdaptiveMax * (this.bytesPerNode || 64));
                    const remainingBudget = Math.max(0, (maxBytesBudget - bytesUploadedThisFrame) || 0);
                    const totalChangedEdgeBytes = changedEdges * bytesPerEdge;

                    if (changedEdges > 0 && totalChangedEdgeBytes > 0 && totalChangedEdgeBytes <= remainingBudget) {
                        const baselineAvgByte = this._movingAvg(this.metrics.perByteUploadTimes) || 0.0;
                        const mergeWindow = this.computeAdaptiveMergeWindow();
                        const idxs = Array.from(this.changedEdgeIndices).map(r=>Number(r)).sort((a,b)=>a-b);
                        let i = 0;
                        while(i < idxs.length){
                            let start = idxs[i]; let end = start; i++;
                            while(i < idxs.length){
                                const gap = idxs[i] - end - 1;
                                if (idxs[i] === end + 1) { end = idxs[i]; i++; continue; }
                                if (gap > 0 && gap <= mergeWindow) { end = idxs[i]; i++; continue; }
                                break;
                            }
                            const count = end - start + 1;
                            const offsetBytes = start * 4 * 4;
                            const lengthFloats = count * 4;
                            const t0 = performance.now();
                            const sub = this.edgeData.subarray(start*4, start*4 + lengthFloats);
                            gl.bufferSubData(gl.ARRAY_BUFFER, offsetBytes, sub);
                            const t1 = performance.now();
                            const dt = t1 - t0;
                            const bytesThis = count * bytesPerEdge;
                            const perByte = dt / bytesThis;
                            const pba = this.metrics.perByteUploadTimes; pba.push(perByte); if (pba.length > this.metrics.maxSamples) pba.shift();
                            const overhead = Math.max(0, dt - (baselineAvgByte * bytesThis));
                            const bh = this.metrics.batchOverheads; bh.push(overhead); if (bh.length > this.metrics.maxSamples) bh.shift();
                            bytesUploadedThisFrame += bytesThis;
                        }
                        this.changedEdgeIndices.clear();
                    } else {
                        // Too large or no per-edge batching budget; upload full buffer
                        gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.edgeData.subarray(0, this.edgeCount*4));
                        this.changedEdgeIndices.clear && this.changedEdgeIndices.clear();
                        bytesUploadedThisFrame += (this.edgeCount * bytesPerEdge) || 0;
                    }
                    this._needsEdgeUpload = false;
                }
            }

            render(viewProjMatrix){
                if (!this.gl) return;
                const frameStart = performance.now();
                const gl = this.gl;
                this._resize();
                gl.enable(gl.DEPTH_TEST);
                gl.clearColor(0,0,0,0);
                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

                this._uploadIfNeeded();

                // Bind node texture to unit 0
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, this.nodeTexture);

                // Draw edges first
                if (this.edgeCount > 0) {
                    gl.useProgram(this.edgeProgram);
                    gl.uniformMatrix4fv(this.u_edge_viewProj, false, viewProjMatrix);
                    gl.uniform1i(this.u_edge_tex, 0);

                    // Bind edge buffer as per-instance attributes
                    gl.bindVertexArray(this.vaoEdge);
                    gl.bindBuffer(gl.ARRAY_BUFFER, this.edgeBuffer);
                    const iSrc = gl.getAttribLocation(this.edgeProgram, 'i_src');
                    const iTgt = gl.getAttribLocation(this.edgeProgram, 'i_tgt');
                    const iWeight = gl.getAttribLocation(this.edgeProgram, 'i_weight');
                    const iKind = gl.getAttribLocation(this.edgeProgram, 'i_kind');
                    // each edge has 4 floats
                    const stride = 4 * 4;
                    gl.enableVertexAttribArray(iSrc); gl.vertexAttribPointer(iSrc,1,gl.FLOAT,false,stride,0); gl.vertexAttribDivisor(iSrc,1);
                    gl.enableVertexAttribArray(iTgt); gl.vertexAttribPointer(iTgt,1,gl.FLOAT,false,stride,4); gl.vertexAttribDivisor(iTgt,1);
                    gl.enableVertexAttribArray(iWeight); gl.vertexAttribPointer(iWeight,1,gl.FLOAT,false,stride,8); gl.vertexAttribDivisor(iWeight,1);
                    gl.enableVertexAttribArray(iKind); gl.vertexAttribPointer(iKind,1,gl.FLOAT,false,stride,12); gl.vertexAttribDivisor(iKind,1);

                    gl.drawArraysInstanced(gl.LINES, 0, 2, this.edgeCount);
                    gl.bindVertexArray(null);
                }

                // Draw nodes
                if (this.nodeCount > 0) {
                    gl.useProgram(this.nodeProgram);
                    gl.uniformMatrix4fv(this.u_node_viewProj, false, viewProjMatrix);
                    gl.uniform1i(this.u_node_tex, 0);
                    gl.bindVertexArray(this.vaoNode);
                    gl.drawArraysInstanced(gl.POINTS, 0, 1, this.nodeCount);
                    gl.bindVertexArray(null);
                }
                const frameEnd = performance.now();
                const dt = frameEnd - frameStart;
                try{
                    const arr = this.metrics.frameTimes;
                    arr.push(dt);
                    if (arr.length > this.metrics.maxSamples) arr.shift();
                }catch(e){}
                try{ this.updateDebugOverlay(); }catch(e){}
            }
        }

        // Start a WebGL hypergraph renderer overlay when the hypergraph initializes
        function startWebGLHypergraphRenderer() {
            try {
                if (window.webglHypergraphRenderer) return window.webglHypergraphRenderer;
                const container = document.getElementById('cesiumContainer') || document.body;
                const canvasTest = document.createElement('canvas');
                const gl2 = canvasTest.getContext && canvasTest.getContext('webgl2');
                if (!gl2) return null; // no WebGL2, skip
                window.webglHypergraphRenderer = new WebGLHypergraphRenderer(container, (window.webglHypergraphRendererOptions||{initialCapacity:16384}));
                // expose option setter
                window.setWebGLHypergraphOptions = function(o){ if(window.webglHypergraphRenderer) window.webglHypergraphRenderer.setOptions(o); else window.webglHypergraphRendererOptions = Object.assign(window.webglHypergraphRendererOptions||{}, o); };
                return window.webglHypergraphRenderer;
            } catch (e) { console.warn('WebGLHypergraphRenderer failed to start', e); return null; }
        }
        
        // Initialize Cesium-based hypergraph system
        function initializeCesiumHypergraph() {
            if (!viewer || !window.RF_SCYTHE.createHypergraphVisualizer) {
                return;
            }
            
            hypergraphVisualizer = window.RF_SCYTHE.createHypergraphVisualizer(viewer);
            
            // Setup altitude listener for hierarchical edge rendering
            if (hypergraphVisualizer.setupAltitudeListener) {
                hypergraphVisualizer.setupAltitudeListener();
            }
            
            // Set up UI event handlers
            setupCesiumHypergraphControls();
        }
        
        function setupCesiumHypergraphControls() {
            // Hypergraph overlay toggle
            const overlayCheckbox = document.getElementById('showHypergraphOverlay');
            if (overlayCheckbox) {
                overlayCheckbox.addEventListener('change', function() {
                    const metricsPanel = document.getElementById('hypergraph-metrics');
                    const filtersPanel = document.getElementById('hypergraphFilters');
                    if (this.checked) {
                        if (metricsPanel) metricsPanel.style.display = 'block';
                        if (filtersPanel) filtersPanel.style.display = 'block';
                        startHypergraphUpdates();
                    } else {
                        if (metricsPanel) metricsPanel.style.display = 'none';
                        if (filtersPanel) filtersPanel.style.display = 'none';
                        stopHypergraphUpdates();
                        if (hypergraphVisualizer) {
                            hypergraphVisualizer.clearHypergraph();
                        }
                    }
                });
            }
            
            // Cardinality filter
            const cardinalityFilter = document.getElementById('hypergraphCardinalityFilter');
            const cardinalityValue = document.getElementById('cardinalityValue');
            if (cardinalityFilter && cardinalityValue) {
                cardinalityFilter.addEventListener('input', function() {
                    cardinalityValue.textContent = this.value;
                    updateHypergraphVisualization();
                });
            }
            
            // Strength filter
            const strengthFilter = document.getElementById('hypergraphStrengthFilter');
            const strengthValue = document.getElementById('strengthValue');
            if (strengthFilter && strengthValue) {
                strengthFilter.addEventListener('input', function() {
                    strengthValue.textContent = this.value;
                    updateHypergraphVisualization();
                });
            }
            
            // Generate test data button
            const generateButton = document.getElementById('generateTestData');
            if (generateButton) {
                generateButton.addEventListener('click', generateTestHypergraphData);
            }
            
            // Reset hypergraph button
            const resetButton = document.getElementById('resetHypergraph');
            if (resetButton) {
                resetButton.addEventListener('click', resetHypergraphSession);
            }
        }
        
        function startHypergraphUpdates() {
            if (hypergraphUpdateInterval) {
                clearInterval(hypergraphUpdateInterval);
            }
            
            // Update immediately
            updateHypergraphVisualization();
            updateHypergraphMetrics();
            
            // Then update every 5 seconds
            hypergraphUpdateInterval = setInterval(() => {
                updateHypergraphVisualization();
                updateHypergraphMetrics();
            }, 5000);
        }
        
        function stopHypergraphUpdates() {
            if (hypergraphUpdateInterval) {
                clearInterval(hypergraphUpdateInterval);
                hypergraphUpdateInterval = null;
            }
        }
        
        async function updateHypergraphVisualization() {
            if (!hypergraphVisualizer) return;
            
            const cardinalityFilter = document.getElementById('hypergraphCardinalityFilter');
            const strengthFilter = document.getElementById('hypergraphStrengthFilter');
            
            const cardinality = cardinalityFilter ? parseInt(cardinalityFilter.value) : 5;
            const strength = strengthFilter ? parseFloat(strengthFilter.value) : -90;
            
            await hypergraphVisualizer.visualizeHypergraph(cardinality, strength);
        }
        
        async function updateHypergraphMetrics() {
            try {
                const response = await fetch('/api/rf-hypergraph/metrics');
                if (!response.ok) {
                    document.getElementById('hypergraphStatus').textContent = '❌';
                    return;
                }
                
                const data = await response.json();
                if (data.status !== 'ok') return;
                
                const metrics = data.metrics;
                
                // Update basic stats
                document.getElementById('hypergraphNodes').textContent = metrics.total_nodes || 0;
                document.getElementById('hypergraphEdges').textContent = metrics.total_hyperedges || 0;
                document.getElementById('hypergraphSession').textContent = metrics.session_id || '-';
                document.getElementById('hypergraphStatus').textContent = '✅';
                
                // Update frequency bands
                updateFrequencyBandChart(metrics.frequency_distribution || {});
                
                // Update central nodes list
                updateCentralNodesList(metrics.high_centrality_nodes || []);
                
            } catch (error) {
                console.error('Error updating hypergraph metrics:', error);
                document.getElementById('hypergraphStatus').textContent = '❌';
            }
        }
        
        function updateFrequencyBandChart(freqDistribution) {
            const chartContainer = document.getElementById('frequencyBandChart');
            if (!chartContainer) return;
            
            const bands = Object.entries(freqDistribution).slice(0, 5); // Top 5 bands
            
            chartContainer.innerHTML = '';
            
            if (bands.length === 0) {
                chartContainer.innerHTML = '<div style="color: #666;">No data</div>';
                return;
            }
            
            const maxCount = Math.max(...bands.map(([_, count]) => count));
            
            for (const [band, count] of bands) {
                const barContainer = document.createElement('div');
                barContainer.style.cssText = 'margin: 2px 0; padding: 2px; background: rgba(255, 255, 255, 0.1); border-radius: 3px; display: flex; align-items: center;';
                
                const barFill = document.createElement('div');
                barFill.style.cssText = `width: ${(count / maxCount) * 40}px; height: 8px; background: #4a9eff; border-radius: 2px; margin-right: 5px;`;
                
                const barLabel = document.createElement('span');
                barLabel.textContent = `${band}MHz: ${count}`;
                barLabel.style.cssText = 'font-size: 9px; color: #ccc;';
                
                barContainer.appendChild(barFill);
                barContainer.appendChild(barLabel);
                chartContainer.appendChild(barContainer);
            }
        }
        
        function updateCentralNodesList(centralNodes) {
            const listContainer = document.getElementById('centralNodesList');
            if (!listContainer) return;
            
            listContainer.innerHTML = '';
            
            if (centralNodes.length === 0) {
                listContainer.innerHTML = '<div style="color: #666;">No central nodes</div>';
                return;
            }
            
            for (const node of centralNodes.slice(0, 3)) { // Top 3 central nodes
                const nodeItem = document.createElement('div');
                nodeItem.style.cssText = 'padding: 3px; margin: 2px 0; background: rgba(255, 255, 255, 0.1); border-radius: 3px; cursor: pointer; font-size: 9px; display: flex; justify-content: space-between; align-items: center;';
                
                // Safely format frequency display; use '?' if not a finite number
                const freqDisplay = (node.frequency !== undefined && isFinite(node.frequency))
                    ? `${Number(node.frequency).toFixed(1)}`
                    : '?';
                nodeItem.innerHTML = `
                    <span style="color: #4a9eff; font-weight: bold;">${node.node_id}</span>
                    <span style="color: #ccc;">${freqDisplay} MHz</span>
                `;
                
                nodeItem.addEventListener('click', () => {
                    focusOnRFNode(node.node_id);
                });
                
                listContainer.appendChild(nodeItem);
            }
        }
        
        function focusOnRFNode(nodeId) {
            const entity = viewer.entities.getById(`rf_node_${nodeId}`);
            if (entity) {
                viewer.selectedEntity = entity;
                viewer.zoomTo(entity);
            }
        }
        
        async function generateTestHypergraphData() {
            try {
                const response = await fetch('/api/rf-hypergraph/generate-test?nodes=20&freq_min=88&freq_max=108&area_size=1000');
                if (response.ok) {
                    addConsoleMessage('Generated test hypergraph data', 'response');
                    updateHypergraphVisualization();
                    updateHypergraphMetrics();
                } else {
                    addConsoleMessage('Failed to generate test data', 'alert');
                }
            } catch (error) {
                console.error('Error generating test data:', error);
                addConsoleMessage('Error generating test data', 'alert');
            }
        }
        
        async function resetHypergraphSession() {
            try {
                const response = await fetch('/api/rf-hypergraph/reset', { method: 'POST' });
                if (response.ok) {
                    addConsoleMessage('Hypergraph session reset', 'response');
                    if (hypergraphVisualizer) {
                        hypergraphVisualizer.clearHypergraph();
                    }
                    updateHypergraphMetrics();
                } else {
                    addConsoleMessage('Failed to reset hypergraph session', 'alert');
                }
            } catch (error) {
                console.error('Error resetting hypergraph:', error);
                addConsoleMessage('Error resetting hypergraph', 'alert');
            }
        }
        
        // =====================================================================
        // NETWORK HYPERGRAPH SCANNING (NMAP INTEGRATION)
        // =====================================================================
        
        async function scanNetworkHypergraph() {
            const targetInput = document.getElementById('networkScanTarget');
            const target = targetInput?.value?.trim() || '192.168.1.0/24';
            const scanButton = document.getElementById('scanNetworkHypergraph');
            
            // Update button state
            if (scanButton) {
                scanButton.disabled = true;
                scanButton.textContent = '🔄 Scanning...';
            }
            
            addConsoleMessage(`Starting network hypergraph scan: ${target}`, 'info');
            
            try {
                const response = await fetch('/api/network-hypergraph/scan', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        target: target,
                        options: '-sV -sn -T4',
                        reset: true
                    })
                });
                
                if (!response.ok) {
                    throw new Error(`Scan failed: ${response.status}`);
                }
                
                const data = await response.json();
                
                // Log scan results
                const scanInfo = data.scan_info || {};
                addConsoleMessage(`Network scan complete: ${scanInfo.hosts_discovered || 0} hosts found`, 'response');
                addConsoleMessage(`Service groups: ${scanInfo.service_groups || 0}, Subnet groups: ${scanInfo.subnet_groups || 0}`, 'info');
                
                if (scanInfo.simulated) {
                    addConsoleMessage('Note: Using simulated data (nmap may require sudo)', 'warning');
                }
                
                // Update visualization
                await updateHypergraphVisualization();
                await updateHypergraphMetrics();
                
                // Show network hosts in the central nodes panel
                if (data.nodes && data.nodes.length > 0) {
                    updateNetworkNodesList(data.nodes);
                }
                
            } catch (error) {
                console.error('Error in network scan:', error);
                addConsoleMessage(`Network scan error: ${error.message}`, 'alert');
            } finally {
                if (scanButton) {
                    scanButton.disabled = false;
                    scanButton.textContent = '🔍 Scan Network';
                }
            }
        }
        
        async function quickScanHypergraph() {
            const targetInput = document.getElementById('networkScanTarget');
            const target = targetInput?.value?.trim() || '192.168.1.0/24';
            const scanButton = document.getElementById('quickScanHypergraph');
            
            if (scanButton) {
                scanButton.disabled = true;
                scanButton.textContent = '⏳ Scanning...';
            }
            
            addConsoleMessage(`Quick network scan: ${target}`, 'info');
            
            try {
                const response = await fetch(`/api/network-hypergraph/quick-scan?target=${encodeURIComponent(target)}`);
                
                if (!response.ok) {
                    throw new Error(`Quick scan failed: ${response.status}`);
                }
                
                const data = await response.json();
                
                addConsoleMessage(`Quick scan complete: ${data.hosts_found || 0} hosts discovered`, 'response');
                
                await updateHypergraphVisualization();
                await updateHypergraphMetrics();
                
            } catch (error) {
                console.error('Error in quick scan:', error);
                addConsoleMessage(`Quick scan error: ${error.message}`, 'alert');
            } finally {
                if (scanButton) {
                    scanButton.disabled = false;
                    scanButton.textContent = '⚡ Quick Scan';
                }
            }
        }
        
        function updateNetworkNodesList(nodes) {
            const listContainer = document.getElementById('centralNodesList');
            if (!listContainer) return;
            
            // Filter to network hosts
            const networkHosts = nodes.filter(n => n.type === 'network_host').slice(0, 10);
            
            if (networkHosts.length === 0) {
                listContainer.innerHTML = '<div style="color: #666;">No network hosts</div>';
                return;
            }
            
            listContainer.innerHTML = '';
            
            for (const host of networkHosts) {
                const hostItem = document.createElement('div');
                hostItem.style.cssText = 'padding: 4px; margin: 2px 0; background: rgba(34, 197, 94, 0.2); border-radius: 3px; cursor: pointer; border-left: 2px solid #22c55e;';
                
                const services = host.services?.filter(s => s && s !== 'unknown').join(', ') || 'No services';
                
                hostItem.innerHTML = `
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <span style="color: #22c55e; font-weight: bold; font-size: 9px;">${host.ip || host.node_id}</span>
                        <span style="color: #888; font-size: 8px;">${host.hostname || ''}</span>
                    </div>
                    <div style="color: #aaa; font-size: 8px; margin-top: 2px;">${services}</div>
                `;
                
                hostItem.addEventListener('click', () => {
                    focusOnNetworkNode(host.node_id);
                });
                
                listContainer.appendChild(hostItem);
            }
        }
        
        function focusOnNetworkNode(nodeId) {
            const entity = viewer.entities.getById(`rf_node_${nodeId}`);
            if (entity) {
                viewer.selectedEntity = entity;
                viewer.zoomTo(entity);
            }
        }
        
        // Initialize network scan button listeners
        document.addEventListener('DOMContentLoaded', function() {
            const scanBtn = document.getElementById('scanNetworkHypergraph');
            if (scanBtn) {
                scanBtn.addEventListener('click', scanNetworkHypergraph);
            }
            
            const quickBtn = document.getElementById('quickScanHypergraph');
            if (quickBtn) {
                quickBtn.addEventListener('click', quickScanHypergraph);
            }
            
            // Allow Enter key in target input to trigger scan
            const targetInput = document.getElementById('networkScanTarget');
            if (targetInput) {
                targetInput.addEventListener('keypress', function(e) {
                    if (e.key === 'Enter') {
                        scanNetworkHypergraph();
                    }
                });
            }
        });
    </script>
    <!-- Clarktech Visual Graph Query UI -->
    <style>
        #query-builder-panel { display: none; position: fixed; right: 12px; top: 72px; width: 360px; bottom: 24px; background: rgba(18,18,18,0.95); color: #eee; border-radius: 8px; box-shadow: 0 6px 20px rgba(0,0,0,0.6); overflow: hidden; font-family: sans-serif; z-index: 2000; }
        #query-builder-header { display:flex; align-items:center; justify-content:space-between; padding:10px 12px; border-bottom:1px solid rgba(255,255,255,0.04); }
        #query-builder-body { display:flex; height: calc(100% - 48px); }
        #qb-left { width: 58%; padding: 10px; overflow:auto; border-right:1px solid rgba(255,255,255,0.03); }
        #qb-right { width: 42%; padding: 10px; overflow:auto; }
        .pill { display:inline-block; padding:6px 10px; margin:4px 4px 4px 0; border-radius:16px; background:#2b2b2b; cursor:pointer; font-size:12px; }
        .pill.active { background:linear-gradient(90deg,#0066ff,#00c2ff); color:#000; font-weight:700; }
        .qb-section { margin-bottom:12px; }
        .qb-section h4 { margin:6px 0; font-size:12px; color:#9aa; }
        .dsl-view { background:#071020; border-radius:6px; padding:8px; font-family:monospace; font-size:12px; color:#bfefff; height:86px; overflow:auto; }
        .qb-footer { padding:8px; border-top:1px solid rgba(255,255,255,0.03); display:flex; gap:8px; }
        .btn { background:#0b84ff; color:white; padding:8px 10px; border-radius:6px; cursor:pointer; border:none; }
        .btn.ghost { background:transparent; border:1px solid rgba(255,255,255,0.06); }
        .inspector { font-size:12px; color:#cfe; }
        .filter-row { display:flex; gap:8px; align-items:center; margin:6px 0; }
        .small-input { width:100%; padding:6px; border-radius:4px; background:#121212; border:1px solid rgba(255,255,255,0.04); color:#ddd; }
    </style>

    <div id="query-builder-panel" aria-hidden="false">
        <div id="query-builder-header">
            <div style="font-weight:700;">Graph Query Builder</div>
            <div style="font-size:12px;color:#9aa">Live DSL • Silent Builder</div>
        </div>
        <div id="query-builder-body">
            <div id="qb-left">
                <div class="qb-section">
                    <h4>Entity Type</h4>
                    <div id="entity-pills">
                        <span class="pill active" data-kind="rf">RF</span>
                        <span class="pill" data-kind="network_host">Network</span>
                        <span class="pill" data-kind="ais">AIS</span>
                        <span class="pill" data-kind="operator">Operators</span>
                        <span class="pill" data-kind="room">Rooms</span>
                    </div>
                </div>

                <div class="qb-section" id="attribute-filters">
                    <h4>Attribute Filters</h4>
                    <!-- RF filters (default) -->
                    <div id="filters-rf">
                        <div class="filter-row">
                            <label style="width:72px;font-size:12px;color:#9aa">Frequency</label>
                            <input id="freq-min" class="small-input" type="number" step="0.1" placeholder="min (MHz)" />
                        </div>
                        <div class="filter-row">
                            <label style="width:72px;font-size:12px;color:#9aa">to</label>
                            <input id="freq-max" class="small-input" type="number" step="0.1" placeholder="max (MHz)" />
                        </div>
                        <div class="filter-row">
                            <label style="width:72px;font-size:12px;color:#9aa">Modulation</label>
                            <select id="modulation" class="small-input">
                                <option value="">Any</option>
                                <option>FM</option>
                                <option>AM</option>
                                <option>PSK</option>
                                <option>FSK</option>
                                <option>QAM</option>
                                <option>OFDM</option>
                            </select>
                        </div>
                    </div>

                    <!-- AIS filters (hidden until selected) -->
                    <div id="filters-ais" style="display:none;">
                        <div class="filter-row"><label style="width:72px;font-size:12px;color:#9aa">Vessel Type</label><input id="ais-type" class="small-input" placeholder="e.g. Cargo"/></div>
                        <div class="filter-row"><label style="width:72px;font-size:12px;color:#9aa">Speed</label><input id="ais-speed" class="small-input" placeholder="min - max"/></div>
                    </div>
                </div>

                <div class="qb-section">
                    <h4>Spatial</h4>
                    <div class="filter-row">
                        <button id="use-view" class="btn ghost" style="flex:1">Use Current View</button>
                    </div>
                    <div class="filter-row">
                        <input id="bbox-input" class="small-input" placeholder="lat1,lon1,lat2,lon2 (optional)" />
                    </div>
                </div>

                <div class="qb-section">
                    <h4>Temporal</h4>
                    <div class="filter-row">
                        <select id="time-range" class="small-input">
                            <option value="5m">Last 5m</option>
                            <option value="10m">Last 10m</option>
                            <option value="1h">Last 1h</option>
                            <option value="24h">Last 24h</option>
                            <option value="custom">Custom</option>
                        </select>
                    </div>
                </div>

                <div class="qb-section">
                    <h4>Room / Scope</h4>
                    <div class="filter-row">
                        <select id="room-select" class="small-input"><option value="global">Global</option></select>
                    </div>
                </div>

                <div class="qb-section">
                    <h4>Output</h4>
                    <div class="filter-row">
                        <select id="output-mode" class="small-input"><option value="nodes">Nodes</option><option value="edges">Edges</option><option value="subgraph">Subgraph</option></select>
                    </div>
                </div>

                <div class="qb-footer">
                    <button id="run-query" class="btn">Run Query</button>
                    <button id="copy-dsl" class="btn ghost">Copy DSL</button>
                    <button id="save-preset" class="btn ghost">Save</button>
                </div>
            </div>
            <div id="qb-right">
                <div class="qb-section">
                    <h4>Live DSL</h4>
                    <div id="live-dsl" class="dsl-view">--</div>
                </div>
                <div class="qb-section">
                    <h4>Result Inspector</h4>
                    <div id="result-summary" class="inspector">No results yet</div>
                </div>
                <div class="qb-section">
                    <h4>Event Stream</h4>
                    <div id="event-stream" style="height:200px; overflow:auto; font-size:12px; color:#9ad; background:#041018; padding:6px; border-radius:6px">Waiting for events...</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        (function(){
            // Simple UI wiring
            const pills = document.querySelectorAll('#entity-pills .pill');
            let selectedKind = 'rf';
            const qbPanel = document.getElementById('query-builder-panel');
            pills.forEach(p => p.addEventListener('click', ()=>{
                pills.forEach(x=>x.classList.remove('active'));
                p.classList.add('active');
                selectedKind = p.dataset.kind;
                document.getElementById('filters-rf').style.display = selectedKind==='rf' ? 'block':'none';
                document.getElementById('filters-ais').style.display = selectedKind==='ais' ? 'block':'none';
                compileAndShowDSL();
            }));

            document.getElementById('use-view').addEventListener('click', function(){
                // Attempt to read map view bounding box from Cesium viewer
                if(window.viewer && window.viewer.camera){
                    try{
                        const rect = window.viewer.camera.computeViewRectangle(Cesium.Ellipsoid.WGS84);
                        if(rect){
                            const sw = Cesium.Rectangle.southwest(rect);
                            const ne = Cesium.Rectangle.northeast(rect);
                            const bbox = [Cesium.Math.toDegrees(sw.latitude), Cesium.Math.toDegrees(sw.longitude), Cesium.Math.toDegrees(ne.latitude), Cesium.Math.toDegrees(ne.longitude)];
                            document.getElementById('bbox-input').value = bbox.join(',');
                            compileAndShowDSL();
                        }
                    }catch(e){ console.warn('Use view failed',e); }
                }
            });

            document.getElementById('run-query').addEventListener('click', runQuery);
            document.getElementById('copy-dsl').addEventListener('click', function(){ navigator.clipboard.writeText(document.getElementById('live-dsl').innerText||''); });

            async function populateRooms(){
                try{
                    // Only fetch rooms if authenticated
                    if (!window.OperatorSession || !window.OperatorSession.sessionToken) {
                        console.debug('[populateRooms] Skipping - not authenticated yet');
                        return;
                    }
                    const res = await fetch('/api/rooms/my', {
                        headers: { 'X-Session-Token': OperatorSession.sessionToken }
                    });
                    if(res.ok){ const data = await res.json(); if(Array.isArray(data.rooms)){ const sel = document.getElementById('room-select'); data.rooms.forEach(r=>{ const opt=document.createElement('option'); opt.value=r.id||r.room_id||r.name; opt.textContent=r.name||r.id||r.room_id; sel.appendChild(opt); }); }
                }
                }catch(e){}
            }
            // Defer populateRooms until after login
            if (window.OperatorSession && window.OperatorSession.sessionToken) {
                populateRooms();
            }

            function compileAndShowDSL(){
                const parts = [];
                parts.push('FIND NODES');
                const where = [];
                if(selectedKind){ where.push(`kind = \"${selectedKind}\"`); }
                // RF freq
                const fmin = document.getElementById('freq-min').value;
                const fmax = document.getElementById('freq-max').value;
                if(fmin && fmax){ where.push(`frequency BETWEEN ${fmin} AND ${fmax}`); }
                const mod = document.getElementById('modulation').value;
                if(mod){ where.push(`modulation = \"${mod}\"`); }
                // bbox
                const bbox = document.getElementById('bbox-input').value;
                if(bbox){ parts.push(`IN BBOX [${bbox}]`); }
                if(where.length) parts.push('WHERE ' + where.join(' AND '));
                parts.push('RETURN ' + document.getElementById('output-mode').value);
                const dsl = parts.join(' \n');
                document.getElementById('live-dsl').innerText = dsl;
                return dsl;
            }

            // update DSL live when inputs change
            ['freq-min','freq-max','modulation','bbox-input','output-mode','time-range','ais-type','ais-speed','room-select'].forEach(id=>{
                const el = document.getElementById(id); if(!el) return; el.addEventListener('change', compileAndShowDSL); el.addEventListener('input', compileAndShowDSL);
            });

            // initial compile
            compileAndShowDSL();

            // Expose control functions to main menu
            window.openQueryBuilder = function(){ if(qbPanel) qbPanel.style.display = 'block'; compileAndShowDSL(); };
            window.closeQueryBuilder = function(){ if(qbPanel) qbPanel.style.display = 'none'; };
            window.toggleQueryBuilder = function(){ if(qbPanel) qbPanel.style.display === 'none' ? window.openQueryBuilder() : window.closeQueryBuilder(); };
            window.openQueryBuilderWithKind = function(kind, run){
                // set UI to requested kind
                selectedKind = kind;
                pills.forEach(x=>{ if(x.dataset.kind===kind) x.classList.add('active'); else x.classList.remove('active'); });
                if(qbPanel) qbPanel.style.display = 'block';
                compileAndShowDSL();
                if(run) runQuery();
            };

            // Main menu buttons
            try{
                const menuBtn = document.getElementById('menu-query-btn');
                if(menuBtn) menuBtn.addEventListener('click', ()=>{ window.toggleQueryBuilder(); });
                const opBtn = document.getElementById('show-operators-btn');
                if(opBtn) opBtn.addEventListener('click', ()=>{ window.openQueryBuilderWithKind('operator', true); });
            }catch(e){ console.warn('Main menu wiring failed', e); }

            async function runQuery(){
                const dsl = compileAndShowDSL();
                const body = { dsl: dsl };
                try{
                    const res = await fetch('/api/hypergraph/query', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(body)});
                    const data = await res.json();
                    const summary = document.getElementById('result-summary');
                    if(data && data.result){
                        // Support both legacy result and canonical subgraph payload
                        if(data.result.stats){
                            summary.innerHTML = `<div>Nodes: <strong>${data.result.stats.node_count}</strong></div><div>Edges: <strong>${data.result.stats.edge_count}</strong></div>`;
                        } else {
                            summary.innerHTML = `<div>Nodes: <strong>${data.result.count_nodes|| (data.result.nodes?data.result.nodes.length:0)}</strong></div><div>Edges: <strong>${data.result.count_edges|| (data.result.edges?data.result.edges.length:0)}</strong></div>`;
                        }
                        // quick highlight on map if available
                        try{ if(window.applyQueryResultsToViewer) window.applyQueryResultsToViewer(data.result); }catch(e){}

                        // If server returned a sequence_id for stream continuity, ensure SSE connects with that since
                        try{
                            const seq = data.result.sequence_id || (data.result.stats && data.result.sequence_id);
                            if(window.EntitySync && seq){
                                // pass sequence id so server can replay missed events
                                try{ EntitySync.connect(seq); }catch(e){ console.warn('EntitySync connect failed', e); }
                                // start diff poller for incremental updates
                                try{ if(window.startDiffStream) window.startDiffStream(dsl, seq); }catch(e){ console.warn('startDiffStream failed', e); }
                            } else {
                                // ensure connected if not already
                                if(window.EntitySync && !EntitySync.connected) EntitySync.connect();
                            }
                        }catch(e){/* ignore */}
                    } else {
                        summary.innerText = JSON.stringify(data).slice(0,800);
                    }
                }catch(e){ document.getElementById('result-summary').innerText = 'Query failed: ' + e.message; }
            }

            // Simple event stream helper (connect to SSE if available)
            // Note: Only connect after operator is authenticated
            try{
                if(window.EventSource && window.OperatorSession && window.OperatorSession.sessionToken){
                    const es = new EventSource(`/api/entities/stream?token=${encodeURIComponent(OperatorSession.sessionToken)}`);
                    es.onmessage = function(ev){ const el = document.getElementById('event-stream'); if(el){ const item = document.createElement('div'); item.textContent = ev.data; el.prepend(item); } };
                    es.onerror = function(err){ console.debug('[EntityStream] SSE error (may be auth issue):', err); es.close(); };
                }
            }catch(e){}

            // Apply subgraph results to Cesium viewer (minimal renderer)
            window.applyQueryResultsToViewer = function(result){
                try{
                    if(!window.viewer) return;
                    // maintain list of added entity ids
                    window._queryEntities = window._queryEntities || [];
                    // remove previous
                    try{ window._queryEntities.forEach(id=>{ const e = viewer.entities.getById(id); if(e) viewer.entities.remove(e); }); }catch(e){}
                    window._queryEntities = [];

                    const nodes = result.nodes || [];
                    const edges = result.edges || [];

                    // add nodes
                    nodes.forEach(n=>{
                        if(!n || !n.id) return;
                        const id = `query_node_${n.id}`;
                        window._queryEntities.push(id);
                        const pos = (n.position && n.position.length>=2) ? Cesium.Cartesian3.fromDegrees(n.position[1], n.position[0], n.position[2]||0) : null;
                        const color = (n.kind === 'rf') ? Cesium.Color.ORANGE : (n.kind === 'vessel' ? Cesium.Color.CYAN : Cesium.Color.LIGHTGRAY);
                        const ent = viewer.entities.add({ id: id, position: pos, point: { pixelSize: 8, color: color, heightReference: Cesium.HeightReference.CLAMP_TO_GROUND }, label: { text: n.id, font: '12px sans-serif', fillColor: Cesium.Color.WHITE, style: Cesium.LabelStyle.FILL_AND_OUTLINE, outlineColor: Cesium.Color.BLACK, outlineWidth: 2, pixelOffset: new Cesium.Cartesian2(0,-16) } });
                    });

                    // add simple polyline edges when both endpoints have positions
                    edges.forEach((e, idx)=>{
                        if(!e || !e.nodes || e.nodes.length<2) return;
                        const pts = [];
                        for(const nid of e.nodes){
                            const node = nodes.find(x=>x.id===nid);
                            if(node && node.position && node.position.length>=2){ pts.push(Cesium.Cartesian3.fromDegrees(node.position[1], node.position[0], node.position[2]||0)); }
                        }
                        if(pts.length>=2){ const eid = `query_edge_${idx}`; window._queryEntities.push(eid); viewer.entities.add({ id: eid, polyline: { positions: pts, width: 2, material: Cesium.Color.YELLOW.withAlpha(0.6), clampToGround: true } }); }
                    });

                    // zoom to results if any
                    try{ if(window._queryEntities.length>0){ const first = viewer.entities.getById(window._queryEntities[0]); if(first) viewer.zoomTo(first); } }catch(e){}
                }catch(e){ console.warn('applyQueryResultsToViewer failed', e); }
            };

            // --- Subgraph diff client helpers ---------------------------------
            // Render state maps
            window.renderedNodes = window.renderedNodes || new Map();
            window.renderedEdges = window.renderedEdges || new Map();
            window.lastSequenceId = window.lastSequenceId || 0;
            window._diffPollIntervalId = window._diffPollIntervalId || null;

            async function fetchSubgraphDiff(dsl, fromSeq, toSeq, queryId){
                try{
                    const body = { dsl: dsl, from_sequence: Number(fromSeq||0), to_sequence: Number(toSeq||0) };
                    if(queryId) body.query_id = queryId;
                    const res = await fetch('/api/hypergraph/diff', { method:'POST', headers: {'Content-Type':'application/json'}, body: JSON.stringify(body) });
                    if(!res.ok) throw new Error('Diff request failed: ' + res.status);
                    const data = await res.json();
                    return data && data.diff ? data.diff : null;
                }catch(e){ console.warn('fetchSubgraphDiff failed', e); return null; }
            }

            function _addOrUpdateNodeEntity(node){
                if(!node || !node.id) return;
                const nid = `node_${node.id}`;
                const existing = viewer.entities.getById(nid);
                const pos = (node.position && node.position.length>=2) ? Cesium.Cartesian3.fromDegrees(node.position[1], node.position[0], node.position[2]||0) : null;
                const color = (node.kind === 'rf') ? Cesium.Color.ORANGE : (node.kind === 'vessel' ? Cesium.Color.CYAN : Cesium.Color.LIGHTGRAY);
                if(existing){
                    try{
                        if(pos) existing.position = pos;
                        if(existing.label && node.id) existing.label.text = node.id;
                    }catch(e){ }
                } else {
                    try{
                        const ent = viewer.entities.add({ id: nid, position: pos, point: { pixelSize: 8, color: color, heightReference: Cesium.HeightReference.CLAMP_TO_GROUND }, label: { text: node.id, font: '12px sans-serif', fillColor: Cesium.Color.WHITE, style: Cesium.LabelStyle.FILL_AND_OUTLINE, outlineColor: Cesium.Color.BLACK, outlineWidth: 2, pixelOffset: new Cesium.Cartesian2(0,-16) } });
                        window.renderedNodes.set(node.id, node);
                    }catch(e){ console.warn('add node entity failed', e); }
                }
            }

            function _removeNodeEntity(nodeId){
                if(!nodeId) return;
                const nid = `node_${nodeId}`;
                try{ const e = viewer.entities.getById(nid); if(e) viewer.entities.remove(e); }catch(e){}
                window.renderedNodes.delete(nodeId);
            }

            function _addOrUpdateEdgeEntity(edge){
                if(!edge || !edge.id) return;
                const eid = `edge_${edge.id}`;
                // Build positions from current renderedNodes map
                const pts = [];
                for(const nid of (edge.nodes||[])){
                    const n = window.renderedNodes.get(nid) || null;
                    if(n && n.position && n.position.length>=2){ pts.push(Cesium.Cartesian3.fromDegrees(n.position[1], n.position[0], n.position[2]||0)); }
                }
                const existing = viewer.entities.getById(eid);
                if(pts.length<2){
                    // remove if exists
                    if(existing) try{ viewer.entities.remove(existing); }catch(e){}
                    window.renderedEdges.delete(edge.id);
                    return;
                }
                if(existing){
                    try{ existing.polyline.positions = pts; }catch(e){}
                } else {
                    try{ viewer.entities.add({ id: eid, polyline: { positions: pts, width: 2, material: Cesium.Color.YELLOW.withAlpha(0.6), clampToGround: true } }); window.renderedEdges.set(edge.id, edge); }catch(e){ console.warn('add edge failed', e); }
                }
            }

            function _removeEdgeEntity(edgeId){
                if(!edgeId) return;
                const eid = `edge_${edgeId}`;
                try{ const e = viewer.entities.getById(eid); if(e) viewer.entities.remove(e); }catch(e){}
                window.renderedEdges.delete(edgeId);
            }

            // Apply a canonical diff payload to viewer state
            window.applySubgraphDiff = function(diff){
                try{
                    if(!diff) return;
                    // If WebGL renderer is enabled, prefer it for node rendering
                    const useWebGL = !!window.webglHypergraphEnabled && window.webglHypergraphRenderer;
                    const nodes = diff.nodes || { created:[], updated:[], deleted:[] };
                    if(useWebGL){
                        try{ window.webglHypergraphRenderer.applyDiff(diff); }catch(e){ console.warn('webgl applyDiff failed', e); }
                    } else {
                        (nodes.created||[]).forEach(n=>{ _addOrUpdateNodeEntity(n); });
                        (nodes.updated||[]).forEach(n=>{ _addOrUpdateNodeEntity(n); window.renderedNodes.set(n.id, Object.assign((window.renderedNodes.get(n.id)||{}), n)); });
                        (nodes.deleted||[]).forEach(id=>{ _removeNodeEntity(id); });
                    }

                    // Edges still handled by Cesium entity layer (for now)
                    const edges = diff.edges || { created:[], updated:[], deleted:[] };
                    (edges.created||[]).forEach(e=>{ _addOrUpdateEdgeEntity(e); });
                    (edges.updated||[]).forEach(e=>{ _addOrUpdateEdgeEntity(e); window.renderedEdges.set(e.id, Object.assign((window.renderedEdges.get(e.id)||{}), e)); });
                    (edges.deleted||[]).forEach(id=>{ _removeEdgeEntity(id); });

                    // Advance lastSequenceId
                    if(diff.to_sequence) window.lastSequenceId = Number(diff.to_sequence);
                }catch(e){ console.warn('applySubgraphDiff failed', e); }
            };

            // WebGL renderer toggle UI and wiring
            (function setupWebGLToggle(){
                // ensure only once
                if(document.getElementById('webglHypergraphToggle')) return;
                const btn = document.createElement('button');
                btn.id = 'webglHypergraphToggle';
                btn.textContent = 'WebGL Nodes: Off';
                btn.style.position = 'fixed';
                btn.style.right = '16px';
                btn.style.bottom = '16px';
                btn.style.zIndex = 99999;
                btn.style.padding = '8px 12px';
                btn.style.background = '#222';
                btn.style.color = '#fff';
                btn.style.border = '1px solid rgba(255,255,255,0.08)';
                btn.style.borderRadius = '4px';
                btn.style.cursor = 'pointer';
                document.body.appendChild(btn);

                function setState(enabled){
                    window.webglHypergraphEnabled = !!enabled;
                    btn.textContent = enabled ? 'WebGL Nodes: On' : 'WebGL Nodes: Off';
                    if(enabled){
                        const r = startWebGLHypergraphRenderer();
                        if(r && window.lastSubgraphSnapshot){
                            try{ r.applyDiff(window.lastSubgraphSnapshot); }catch(e){ console.warn('initial webgl apply failed', e); }
                        }
                    } else {
                        // optionally hide or destroy renderer canvas
                        if(window.webglHypergraphRenderer && window.webglHypergraphRenderer.canvas){
                            window.webglHypergraphRenderer.canvas.style.display = 'none';
                        }
                    }
                }

                btn.addEventListener('click', ()=>{
                    setState(!window.webglHypergraphEnabled);
                });

                // expose programmatic API
                window.setWebGLHypergraphEnabled = setState;
            })();

            // Start a polling loop to fetch diffs for given DSL
            window.startDiffPoll = function(dsl, initialFrom){
                // clear existing
                if(window._diffPollIntervalId) { clearInterval(window._diffPollIntervalId); window._diffPollIntervalId = null; }
                window.lastSequenceId = Number(initialFrom||window.lastSequenceId||0);
                // poll every 1000ms
                window._diffPollIntervalId = setInterval(async ()=>{
                    try{
                        const diff = await fetchSubgraphDiff(dsl, window.lastSequenceId, 0);
                        if(diff){ window.applySubgraphDiff(diff); }
                    }catch(e){ console.warn('diff poll error', e); }
                }, 1000);
            };

            window.stopDiffPoll = function(){ if(window._diffPollIntervalId){ clearInterval(window._diffPollIntervalId); window._diffPollIntervalId = null; } };

            // Start server-pushed diff stream via SSE (preferred over polling)
            window._diffEventSource = null;
            // Register DSL on server and return query_id
            async function registerQueryDSL(dsl){
                try{
                    const res = await fetch('/api/hypergraph/query/register', { method: 'POST', headers: {'Content-Type':'application/json'}, body: JSON.stringify({dsl: dsl}) });
                    if(!res.ok) throw new Error('register failed ' + res.status);
                    const j = await res.json();
                    if(j && j.status === 'ok' && j.query_id) return j.query_id;
                }catch(e){ console.warn('registerQueryDSL failed', e); }
                return null;
            }

            window.startDiffStream = async function(dsl, initialFrom){
                try{
                    // Stop any existing poll or stream
                    window.stopDiffPoll();
                    if(window._diffEventSource){ try{ window._diffEventSource.close(); }catch(e){} window._diffEventSource = null; }

                    const token = (window.OperatorSession && window.OperatorSession.sessionToken) ? encodeURIComponent(window.OperatorSession.sessionToken) : '';
                    const since = Number(initialFrom||window.lastSequenceId||0);

                    // Prefer registering the DSL and subscribing by query_id
                    let qid = null;
                    try{ qid = await registerQueryDSL(dsl); }catch(e){ qid = null; }

                    let url;
                    if(qid){
                        url = `/api/hypergraph/diff/stream?query_id=${encodeURIComponent(qid)}&since=${encodeURIComponent(since)}&token=${token}`;
                    } else {
                        // fallback to sending DSL directly (if register failed)
                        url = `/api/hypergraph/diff/stream?dsl=${encodeURIComponent(dsl)}&since=${encodeURIComponent(since)}&token=${token}`;
                    }

                    window._diffEventSource = new EventSource(url);

                    window._diffEventSource.addEventListener('DIFF', function(e){
                        try{ const diff = JSON.parse(e.data); window.applySubgraphDiff(diff); }catch(err){ console.warn('DIFF parse failed', err); }
                    });

                    window._diffEventSource.addEventListener('HEARTBEAT', function(e){
                        try{ const hb = JSON.parse(e.data); if(hb.to_sequence) window.lastSequenceId = Number(hb.to_sequence); }catch(err){}
                    });

                    window._diffEventSource.onopen = function(){ console.log('[DiffStream] connected'); };
                    window._diffEventSource.onerror = function(err){ console.warn('[DiffStream] error', err); };
                }catch(e){ console.warn('startDiffStream failed', e); }
            };

            window.stopDiffStream = function(){ try{ if(window._diffEventSource){ window._diffEventSource.close(); window._diffEventSource = null; } }catch(e){} };

            // ----------------------- Mission SSE + Membership Helpers -----------------------
            window._missionEventSource = null;

            window.joinMission = async function(missionId){
                try{
                    const token = (window.OperatorSession && window.OperatorSession.sessionToken) ? window.OperatorSession.sessionToken : null;
                    const headers = {'Content-Type':'application/json'};
                    if(token) headers['X-Session-Token'] = token;
                    const res = await fetch(`/api/missions/${encodeURIComponent(missionId)}/join`, { method: 'POST', headers: headers, body: JSON.stringify({}) });
                    const j = await res.json();
                    if(res.ok && j && j.status === 'ok'){
                        const s = document.getElementById('missionStatus'); if(s) s.textContent = 'joined';
                        return { ok:true, data:j };
                    }
                    return { ok:false, data:j };
                }catch(e){ console.warn('joinMission failed', e); return { ok:false, error: e.message }; }
            };

            window.leaveMission = async function(missionId){
                try{
                    const token = (window.OperatorSession && window.OperatorSession.sessionToken) ? window.OperatorSession.sessionToken : null;
                    const headers = {'Content-Type':'application/json'};
                    if(token) headers['X-Session-Token'] = token;
                    const res = await fetch(`/api/missions/${encodeURIComponent(missionId)}/leave`, { method: 'POST', headers: headers, body: JSON.stringify({}) });
                    const j = await res.json();
                    if(res.ok && j && j.status === 'ok'){
                        const s = document.getElementById('missionStatus'); if(s) s.textContent = 'left';
                        return { ok:true, data:j };
                    }
                    return { ok:false, data:j };
                }catch(e){ console.warn('leaveMission failed', e); return { ok:false, error: e.message }; }
            };

            window.startMissionStream = function(missionId, since){
                try{
                    window.stopMissionStream();
                    const token = (window.OperatorSession && window.OperatorSession.sessionToken) ? encodeURIComponent(window.OperatorSession.sessionToken) : '';
                    const s = Number(since||window.lastSequenceId||0);
                    const url = `/api/missions/${encodeURIComponent(missionId)}/diff/stream?since=${encodeURIComponent(s)}&token=${token}`;
                    window._missionEventSource = new EventSource(url);

                    window._missionEventSource.addEventListener('DIFF', function(e){
                        try{ const diff = JSON.parse(e.data); window.applySubgraphDiff(diff); }catch(err){ console.warn('mission DIFF parse failed', err); }
                    });

                    window._missionEventSource.addEventListener('HEARTBEAT', function(e){
                        try{ const hb = JSON.parse(e.data); if(hb.to_sequence) window.lastSequenceId = Number(hb.to_sequence); }catch(err){}
                    });

                    window._missionEventSource.onopen = function(){ const s = document.getElementById('missionStatus'); if(s) s.textContent = 'stream'; console.log('[MissionStream] connected'); };
                    window._missionEventSource.onerror = function(err){ console.warn('[MissionStream] error', err); const s = document.getElementById('missionStatus'); if(s) s.textContent = 'error'; };
                    return true;
                }catch(e){ console.warn('startMissionStream failed', e); return false; }
            };

            window.stopMissionStream = function(){ try{ if(window._missionEventSource){ window._missionEventSource.close(); window._missionEventSource = null; const s = document.getElementById('missionStatus'); if(s) s.textContent = 'idle'; } }catch(e){} };

            // Wire UI buttons
            (function wireMissionControls(){
                try{
                    const joinBtn = document.getElementById('missionJoinBtn');
                    const leaveBtn = document.getElementById('missionLeaveBtn');
                    const subBtn = document.getElementById('missionSubscribeBtn');
                    const autoCb = document.getElementById('missionAutoSubscribe');
                    const input = document.getElementById('missionIdInput');

                    if(!joinBtn || !leaveBtn || !subBtn || !input) return;

                    joinBtn.addEventListener('click', async ()=>{
                        const mid = input.value.trim(); if(!mid) return alert('enter mission id');
                        const r = await window.joinMission(mid);
                        if(r && r.ok){ const s = document.getElementById('missionStatus'); if(s) s.textContent = 'joined'; if(autoCb && autoCb.checked) window.startMissionStream(mid); }
                    });

                    leaveBtn.addEventListener('click', async ()=>{
                        const mid = input.value.trim(); if(!mid) return alert('enter mission id');
                        const r = await window.leaveMission(mid);
                        if(r && r.ok){ window.stopMissionStream(); const s = document.getElementById('missionStatus'); if(s) s.textContent = 'left'; }
                    });

                    subBtn.addEventListener('click', ()=>{
                        const mid = input.value.trim(); if(!mid) return alert('enter mission id');
                        // toggle subscribe
                        if(window._missionEventSource){ window.stopMissionStream(); subBtn.textContent = 'Subscribe'; }
                        else { const ok = window.startMissionStream(mid); if(ok) subBtn.textContent = 'Unsubscribe'; }
                    });
                }catch(e){ console.warn('wireMissionControls failed', e); }
            })();

            // Wire up mission controls for the secondary Missions panel.  This
            // duplicates the logic of wireMissionControls but targets the
            // elements with suffix 2 (missionJoinBtn2, missionLeaveBtn2, etc.).
            (function wireMissionControls2(){
                try{
                    const joinBtn2 = document.getElementById('missionJoinBtn2');
                    const leaveBtn2 = document.getElementById('missionLeaveBtn2');
                    const subBtn2 = document.getElementById('missionSubscribeBtn2');
                    const autoCb2 = document.getElementById('missionAutoSubscribe2');
                    const input2 = document.getElementById('missionIdInput2');
                    const status2 = document.getElementById('missionStatus2');

                    if(!joinBtn2 || !leaveBtn2 || !subBtn2 || !input2) return;

                    joinBtn2.addEventListener('click', async ()=>{
                        const mid = input2.value.trim(); if(!mid) return alert('enter mission id');
                        const r = await window.joinMission(mid);
                        if(r && r.ok){ if(status2) status2.textContent = 'joined'; if(autoCb2 && autoCb2.checked) window.startMissionStream(mid); }
                    });

                    leaveBtn2.addEventListener('click', async ()=>{
                        const mid = input2.value.trim(); if(!mid) return alert('enter mission id');
                        const r = await window.leaveMission(mid);
                        if(r && r.ok){ window.stopMissionStream(); if(status2) status2.textContent = 'left'; }
                    });

                    subBtn2.addEventListener('click', ()=>{
                        const mid = input2.value.trim(); if(!mid) return alert('enter mission id');
                        // toggle subscribe/unsubscribe
                        if(window._missionEventSource){ window.stopMissionStream(); subBtn2.textContent = 'Subscribe'; }
                        else { const ok = window.startMissionStream(mid); if(ok) subBtn2.textContent = 'Unsubscribe'; }
                    });
                }catch(e){ console.warn('wireMissionControls2 failed', e); }
            })();

            // --- MissionStore UI integration (module) ---
            (async function(){ const { MissionStore } = await import('/assets/missions/missionStore.js');

            let missionStore = null;

            async function loadMissionForUI(){
              try{
                const [pkg, tpl] = await Promise.all([
                  fetch('/assets/missions/mission.example.mission.json').then(r=>r.json()),
                  fetch('/assets/missions/mission.template.isr_patrol.json').then(r=>r.json())
                ]);
                missionStore = new MissionStore({ template: tpl.template });
                missionStore.loadMissionPackage(pkg);
                renderMissionHeader(missionStore.state.mission);
                renderTaskList(missionStore.getTasksForRender());
                renderTriggers(missionStore.state.triggers);
              }catch(e){ console.warn('loadMissionForUI failed', e); }
            }

            function renderMissionHeader(m, store = missionStore){
              const nameEl = document.getElementById('mission-header-name');
              const badgesEl = document.getElementById('mission-header-badges');
              const ownerEl = document.getElementById('mission-header-owner');
              const lastEl = document.getElementById('mission-header-lastupdate');
              const doctrineEl = document.getElementById('mission-header-doctrine');
              if(!m) {
                nameEl.textContent='(no mission loaded)';
                badgesEl.innerHTML='';
                ownerEl.textContent='owner: -';
                lastEl.textContent='last: -';
                doctrineEl.textContent='doctrine: -';
                return;
              }
              nameEl.textContent = m.name || m.id;
              badgesEl.innerHTML = `<span class="pill" style="background:#2a9d8f; color:#fff; padding:4px 6px; border-radius:4px;">${m.phase||''}</span><span class="pill" style="background:#264653; color:#fff; padding:4px 6px; border-radius:4px;">P${m.priority||0}</span>`;
              ownerEl.textContent = 'owner: ' + (m.owner_operator_id || m.created_by || '-');
              lastEl.textContent = 'last: ' + (new Date().toISOString());
              doctrineEl.textContent = 'doctrine: ' + (store?.state?.doctrine ? store.state.doctrine.emcon?.transmit_power_profile || 'default' : '-');
            }

            function renderTaskList(tasks){
              const el = document.getElementById('missions-task-list');
              if(!el) return;
              el.innerHTML = '';
              for(const t of tasks){
                const card = document.createElement('div');
                card.className = 'task-card';
                card.style = 'background:linear-gradient(180deg, rgba(22,22,22,0.9), rgba(12,12,12,0.9)); padding:8px; border-radius:6px; margin-bottom:8px; border:1px solid #333; color:#ddd;';
                card.innerHTML = `
                  <div style="display:flex; justify-content:space-between; align-items:center;">
                    <div>
                      <div style="font-weight:600; color:#ffd166;">${escapeHtml(t.title)}</div>
                      <div style="font-size:12px; color:#aaa;">${escapeHtml(t.type)} • ${t.params?.zone_id || ''}</div>
                    </div>
                    <div style="display:flex; gap:8px; align-items:center;">
                      <div style="font-size:12px;" class="pill state-${t.state}" title="state">${t.state}</div>
                      <div style="font-size:12px;" class="pill pri-${t.priority}">P${t.priority}</div>
                    </div>
                  </div>
                  <div style="margin-top:8px; display:flex; justify-content:space-between; align-items:center;">
                    <div style="color:#9aa;">assets: ${(t.assigned_assets||[]).map(a=>`<a href="#" data-asset="${escapeHtml(a)}" style="color:#9aa; text-decoration:underline; margin-right:6px;">${escapeHtml(a)}</a>`).join('')}</div>
                    <div class="task-actions">
                      <button data-act="queue" data-id="${t.id}" style="margin-right:6px;">Queue</button>
                      <button data-act="start" data-id="${t.id}" style="margin-right:6px;">Start</button>
                      <button data-act="done" data-id="${t.id}" style="margin-right:6px;">Complete</button>
                      <button data-act="abort" data-id="${t.id}" style="margin-right:6px;">Abort</button>
                      <button data-act="assign" data-id="${t.id}" style="margin-left:6px;">Assign</button>
                    </div>
                  </div>
                `;
                el.appendChild(card);
              }
              el.querySelectorAll('button[data-act]').forEach(btn=> {
                btn.addEventListener('click', async ()=>{
                  const id=btn.getAttribute('data-id');
                  const act=btn.getAttribute('data-act');
                  if(act==='assign'){
                    const ass = prompt('Assign asset ids (comma separated)');
                    if(!ass) return;
                    const asset_ids = ass.split(',').map(s=>s.trim()).filter(Boolean);
                    await missionStore.appendEvent('task.assigned', {kind:'operator', id:'local_ui'}, {task_id:id, asset_ids});
                    renderTaskList(missionStore.getTasksForRender());
                    return;
                  }
                  const map = {queue:'queued', start:'active', done:'completed', abort:'aborted'};
                  const next = map[act];
                  if(!next) return;
                  await missionStore.appendEvent('task.state_set', {kind:'operator', id:'local_ui'}, {task_id:id, state:next});
                  renderTaskList(missionStore.getTasksForRender());
                });
              });

// Attach click handlers to asset links to open Unit Card and select unit trail
  el.querySelectorAll('a[data-asset]').forEach(a => {
    a.addEventListener('click', (ev) => {
      try{
        ev.preventDefault();
        const aid = a.getAttribute('data-asset');
        const asset = missionStore?.state?.assets?.find(x => x.id === aid || x.callsign === aid) || null;
        if(!asset){
          document.getElementById('unit-callsign').textContent = aid;
          document.getElementById('unit-role').textContent = 'role: unknown';
          document.getElementById('unit-posture').textContent = 'posture: -';
          document.getElementById('unit-order').textContent = 'order: -';
          try{ selectUnit(aid, {follow:true}); }catch(e){}
          return;
        }
        document.getElementById('unit-callsign').textContent = asset.callsign || asset.id;
        document.getElementById('unit-role').textContent = 'role: ' + (asset.type || '-');
        document.getElementById('unit-posture').textContent = 'posture: ' + (asset.posture || 'Cautious');
        document.getElementById('unit-order').textContent = 'order: ' + (asset.current_order || '-');
        try{ selectUnit(asset.id || asset.callsign, {follow:true}); }catch(e){}
      }catch(e){ console.warn('unit link handler failed', e); }
    });
  });

  // Unit card quick actions
  document.getElementById('unit-retask-btn')?.addEventListener('click', async ()=>{
    try{
      const callsign = document.getElementById('unit-callsign').textContent;
      if(!missionStore) return alert('No mission loaded');
      const asset = missionStore.state.assets.find(a => a.callsign === callsign || a.id === callsign);
      if(!asset) return alert('No asset selected');
      const order = prompt('Enter new order (e.g., Patrol, Shadow, Hold)');
      if(!order) return;
      asset.current_order = order;
      await missionStore.appendEvent('asset.updated', {kind:'operator', id:'local_ui'}, {asset_id: asset.id, patch:{ current_order: order }});
      document.getElementById('unit-order').textContent = 'order: ' + order;
      renderTaskList(missionStore.getTasksForRender());
    }catch(e){ console.warn('unit-retask failed', e); }
  });

  // Follow toggle
  document.getElementById('unit-follow-btn')?.addEventListener('click', ()=>{
    try{
      const callsign = document.getElementById('unit-callsign').textContent;
      if(!callsign || callsign === 'No unit selected') return alert('No unit selected to follow');
      // find subject id by callsign
      const a = missionStore?.state?.assets?.find(x=>x.callsign === callsign || x.id === callsign);
      if(!a) return alert('Selected unit not found');
      const subj = a.id;
      const isFollowing = missionReplay.followingUnit === subj;
      if(isFollowing){ missionReplay.followingUnit = null; window.viewer.trackedEntity = undefined; document.getElementById('unit-follow-btn').textContent = 'Follow'; }
      else { missionReplay.followingUnit = subj; selectUnit(subj, { follow: true }); document.getElementById('unit-follow-btn').textContent = 'Unfollow'; }
    }catch(e){ console.warn('unit-follow failed', e); }
  });
            }

            function renderTriggers(trgs){
              const el = document.getElementById('mission-triggers');
              if(!el) return;
              el.innerHTML = '';
              if(!trgs || trgs.length===0){ el.innerHTML = '<div class="list-placeholder">No triggers loaded</div>'; return; }
              for(const trg of trgs){
                const d = document.createElement('div');
                d.style='padding:8px; border-radius:6px; border:1px solid #333; margin-bottom:6px; color:#ccc;';
                d.innerHTML = `<div style="font-weight:600; color:#ffd166;">${escapeHtml(trg.id)}</div><div style="font-size:12px; color:#9aa;">when ${escapeHtml(trg.when.event_type)} → ${trg.actions?.map(a=>escapeHtml(a.type)).join(', ')}</div>`;
                el.appendChild(d);
              }
            }

            async function setMissionPhase(phase){
              if(!missionStore) return;
              await missionStore.appendEvent('mission.phase_set', {kind:'operator', id:'local_ui'}, {phase});
              renderMissionHeader(missionStore.state.mission);
            }

            async function setMissionStatus(status){
              if(!missionStore) return;
              await missionStore.appendEvent('mission.status_set', {kind:'operator', id:'local_ui'}, {status});
              renderMissionHeader(missionStore.state.mission);
            }

            document.getElementById('missionActivateBtn2')?.addEventListener('click', async ()=>{ await setMissionStatus('active'); await setMissionPhase('execute'); renderMissionHeader(missionStore.state.mission); });
            document.getElementById('missionPauseBtn2')?.addEventListener('click', async ()=>{ await setMissionStatus('paused'); renderMissionHeader(missionStore.state.mission); });
            document.getElementById('missionAbortBtn2')?.addEventListener('click', async ()=>{ if(!confirm('Abort mission?')) return; await setMissionStatus('aborted'); await setMissionPhase('abort'); renderMissionHeader(missionStore.state.mission); });
            document.getElementById('missionCloneBtn2')?.addEventListener('click', ()=>{ if(!missionStore) return; const data = JSON.stringify(missionStore.pkg, null, 2); const blob = new Blob([data], {type:'application/json'}); const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href=url; a.download = (missionStore.pkg.mission?.id || 'mission') + '.clone.json'; a.click(); URL.revokeObjectURL(url); });

            document.getElementById('missionSimulateIncursionBtn2')?.addEventListener('click', async ()=>{
              if(!missionStore) return; 
              await missionStore.appendEvent('contact.zone_entered', {kind:'system', id:'sim'}, {contact_id:'ctr_sim', zone_id:'zn_watchbox', confidence:0.75});
              renderTaskList(missionStore.getTasksForRender());
              renderTriggers(missionStore.state.triggers);
              try{ buildTimeline(); }catch(e){ console.warn('buildTimeline after simulate failed', e); }
            });

            document.getElementById('missionSimulateMoveBtn2')?.addEventListener('click', async ()=>{
              if(!missionStore) return;
              // Simulate an asset moving across the watchbox with position samples
              const path = [
                [-74.0, 40.55, 800],
                [-73.95, 40.6, 900],
                [-73.9, 40.65, 850],
                [-73.85, 40.7, 800],
                [-73.8, 40.75, 750]
              ];
              for(let i=0;i<path.length;i++){
                const p = path[i];
                // space events a bit so timestamps differ
                setTimeout(async ()=>{
                  await missionStore.appendEvent('asset.position', {kind:'system', id:'sim'}, { asset_id: 'ast_recon_01', position: [p[0], p[1], p[2]] });
                  try{ buildTimeline(); }catch(e){}
                }, i * 400);
              }
            });

            // --- Timeline / AAR playback (timestamp-based scrub) ---
            const missionReplay = {
              playTimer: null,
              playing: false,
              speed: 1,
              currentIndex: 0,
              playStore: null,
              replayEntities: [],
              selectedUnit: null,
              followingUnit: null,
              historicSpeeds: {}, // subject -> [m/s values]
              speedUnit: 'm/s' // 'm/s' | 'km/h' | 'knots'
            };

            function timeToIndex(timeMs){
              const events = missionStore?.pkg?.event_log || [];
              if(!events || events.length===0) return -1;
              for(let i = events.length - 1; i >= 0; --i){
                const t = new Date(events[i].ts).getTime();
                if(t <= timeMs) return i;
              }
              return 0;
            }
            function indexToTimeMs(idx){
              const events = missionStore?.pkg?.event_log || [];
              if(!events || events.length===0) return Date.now();
              idx = Math.max(0, Math.min(events.length-1, idx));
              return new Date(events[idx].ts).getTime();
            }

            function buildTimeline(){
              if(!missionStore || !missionStore.pkg) return;
              const events = missionStore.pkg.event_log || [];
              const scrub = document.getElementById('mission-timeline-scrub');
              const ticks = document.getElementById('timelineTicks');
              const label = document.getElementById('timelineTimeLabel');
              if(!scrub || !ticks || !label) return;

              ticks.innerHTML = '';
              if(events.length===0){
                scrub.min = 0; scrub.max = 0; scrub.value = 0; scrub.step = 1;
                label.textContent = 'no events';
                return;
              }

              const minTs = new Date(events[0].ts).getTime();
              const maxTs = new Date(events[events.length-1].ts).getTime();

              // Set scrub to timestamp range (ms) with 1s steps
              scrub.min = minTs; scrub.max = maxTs; scrub.value = minTs; scrub.step = 1000;

              for(let i=0;i<events.length;i++){
                const e = events[i];
                const t = new Date(e.ts).getTime();
                const pct = (t - minTs) / Math.max(1, (maxTs - minTs));
                const mark = document.createElement('div');
                mark.style.position='absolute'; mark.style.left = (pct*100) + '%'; mark.style.top='0'; mark.style.width='2px'; mark.style.height='100%'; mark.style.background = 'rgba(255,255,255,0.06)';
                mark.title = `${e.type} @ ${e.ts}`;
                ticks.appendChild(mark);
              }
              updateTimelineLabel(minTs);
            }

            function updateTimelineLabel(timeMs){
              const label = document.getElementById('timelineTimeLabel');
              if(!label) return;
              const events = missionStore?.pkg?.event_log || [];
              if(!events || events.length===0){ label.textContent = '—'; return; }
              const idx = timeToIndex(timeMs);
              const e = events[Math.max(0, Math.min(events.length-1, idx))];
              label.textContent = e ? `${e.type} @ ${new Date(timeMs).toISOString()} (${idx+1}/${events.length})` : '—';
            }

            function clearReplayEntities(){
              try{
                if(!window.viewer) return;
                (missionReplay.replayEntities||[]).forEach(ent => { try{ if(ent && window.viewer.entities && window.viewer.entities.contains(ent)) window.viewer.entities.remove(ent);}catch(e){} });
                missionReplay.replayEntities = [];
              }catch(e){ console.warn('clearReplayEntities failed', e); }
            }

            function computeZoneCentroid(zone){
              try{
                if(!zone || !zone.geometry || zone.geometry.kind !== 'polygon') return null;
                const coords = zone.geometry.coordinates[0];
                let x=0,y=0; for(const p of coords){ x+=p[0]; y+=p[1]; } x/=coords.length; y/=coords.length; return [x,y];
              }catch(e){ return null; }
            }

            function updateMapFromReplay(store, currentTimeMs){
              try{
                clearReplayEntities();
                if(!window.viewer) return;
                const events = (store.pkg && store.pkg.event_log) ? store.pkg.event_log : [];

                // Group position samples by subject (asset/contact/entity)
                const sampleBuckets = {};

                for(const e of events){
                  // CONTACT INCURSION markers (static)
                  if(e.type === 'contact.zone_entered'){
                    const z = store.state.zones.find(z=>z.id === e.payload.zone_id);
                    const c = computeZoneCentroid(z);
                    if(c){
                      const ent = window.viewer.entities.add({
                        name: 'AAR Contact '+e.payload.contact_id,
                        position: Cesium.Cartesian3.fromDegrees(c[0], c[1], 0),
                        point: { pixelSize: 14, color: Cesium.Color.ORANGE, outlineColor: Cesium.Color.WHITE, outlineWidth:1 }
                      });
                      missionReplay.replayEntities.push(ent);
                    }
                  }

                  // POSITION-TYPE events — normalize to {id, lat, lon, alt, ts}
                  let subj = null; let lat = null; let lon = null; let alt = 0;
                  if(e.payload){
                    if(e.payload.lat !== undefined && e.payload.lon !== undefined){ lat = Number(e.payload.lat); lon = Number(e.payload.lon); alt = Number(e.payload.alt || 0); subj = e.payload.asset_id || e.payload.contact_id || e.payload.entity_id || null; }
                    else if(e.payload.position && Array.isArray(e.payload.position) && e.payload.position.length >= 2){ lon = Number(e.payload.position[0]); lat = Number(e.payload.position[1]); alt = Number(e.payload.position[2] || 0); subj = e.payload.asset_id || e.payload.contact_id || e.payload.entity_id || e.payload.subject_id || null; }
                    else if(e.payload.patch && e.payload.patch.position){ const p = e.payload.patch.position; if(Array.isArray(p) && p.length>=2){ lon = Number(p[0]); lat = Number(p[1]); alt = Number(p[2] || 0); subj = e.payload.asset_id || e.payload.assetId || null; } }
                  }

                  if(subj && isFinite(lat) && isFinite(lon)){
                    const ts = new Date(e.ts).getTime();
                    sampleBuckets[subj] = sampleBuckets[subj] || [];
                    sampleBuckets[subj].push({ ts, lat, lon, alt, confidence: (e.payload && (e.payload.confidence || e.payload.confidence_score)) ?? null });
                  }
                }

                // Create a single polyline per subject using an alpha texture and a head arrow
                const trailMs = (store?.state?.doctrine?.confidence?.decay_half_life_s || 900) * 1000; // how long trail lingers

                for(const [subj, samples] of Object.entries(sampleBuckets)){
                  // sort by time
                  samples.sort((a,b)=>a.ts - b.ts);
                  if(samples.length === 0) continue;

                  // Build positions array for polyline
                  const positions = samples.map(s => Cesium.Cartesian3.fromDegrees(s.lon, s.lat, s.alt));

                  // Build a small canvas texture where each horizontal pixel corresponds to a segment and alpha encodes recency relative to currentTimeMs
                  const segCount = Math.max(1, samples.length - 1);
                  const texW = Math.max(64, Math.min(1024, segCount));
                  const texH = 2;
                  const canvas = document.createElement('canvas'); canvas.width = texW; canvas.height = texH;
                  const ctx = canvas.getContext('2d');
                  // fill transparent
                  ctx.clearRect(0,0,texW,texH);

                  for(let i=0;i<segCount;i++){
                    const a = samples[i], b = samples[i+1];
                    const segMid = Math.round((a.ts + b.ts) / 2);
                    const age = (currentTimeMs || Date.now()) - segMid;
                    const alpha = Math.max(0, Math.min(1, 1 - (age / trailMs)));
                    const x = Math.floor((i / Math.max(1, segCount-1)) * (texW-1));
                    ctx.fillStyle = `rgba(50,255,100,${alpha.toFixed(3)})`;
                    ctx.fillRect(x, 0, Math.ceil(texW / segCount) + 1, texH);
                  }

                  // Create custom fabric that samples the texture by st.s coordinate (along polyline)
                  const fabric = {
                    uniforms: { image: canvas },
                    source: `
                      czm_material czm_getMaterial(czm_materialInput materialInput){
                        vec2 st = materialInput.st;
                        vec4 col = texture2D(image, vec2(clamp(st.s,0.0,1.0), 0.5));
                        materialInput.alpha = col.a;
                        materialInput.diffuse = col.rgb;
                        return czm_getDefaultMaterial(materialInput);
                      }
                    `
                  };

                  const material = new Cesium.Material({ fabric });

                  const poly = window.viewer.entities.add({
                    name: `AAR Poly ${subj}`,
                    polyline: {
                      positions,
                      width: 4,
                      material
                    }
                  });
                  // record and expose subj on entities for selection; keep original material for restore
              poly._subj = subj; poly._origMaterial = material; missionReplay.replayEntities.push(poly);

                  // Create a sampled position property for smooth movement and orientation
                  const prop = new Cesium.SampledPositionProperty();
                  for(const s of samples){
                    try{ const jd = Cesium.JulianDate.fromDate(new Date(s.ts)); prop.addSample(jd, Cesium.Cartesian3.fromDegrees(s.lon, s.lat, s.alt)); }catch(e){}
                  }

                  // Create moving entity with orientation driven by velocity
                  const movingEnt = window.viewer.entities.add({
                    name: `AAR Unit ${subj}`,
                    position: prop,
                    orientation: new Cesium.VelocityOrientationProperty(prop),
                    point: { pixelSize: 10, color: Cesium.Color.LIME, outlineColor: Cesium.Color.WHITE, outlineWidth: 1 },
                    label: {
                      text: new Cesium.CallbackProperty(function(time, result){
                        try{
                          const jd = time;
                          const now = Cesium.JulianDate.toDate(jd).getTime();
                          // compute previous sample 1s earlier for velocity/heading estimate
                          const prevJd = Cesium.JulianDate.addSeconds(jd, -1.0, new Cesium.JulianDate());
                          const posNow = prop.getValue(jd);
                          const posPrev = prop.getValue(prevJd);
                          if(!posNow || !posPrev) return '';
                          const cartoNow = Cesium.Cartographic.fromCartesian(posNow);
                          const cartoPrev = Cesium.Cartographic.fromCartesian(posPrev);
                          const geodesic = new Cesium.EllipsoidGeodesic(cartoPrev, cartoNow);
                          const distM = geodesic.surfaceDistance || Cesium.Cartesian3.distance(posPrev, posNow);
                          const dt = (Cesium.JulianDate.toDate(jd).getTime() - Cesium.JulianDate.toDate(prevJd).getTime())/1000.0 || 1.0;
                          const speed = distM / dt; // m/s
                          // bearing
                          const lat1 = cartoPrev.latitude; const lat2 = cartoNow.latitude; const dLon = cartoNow.longitude - cartoPrev.longitude;
                          const y = Math.sin(dLon) * Math.cos(lat2);
                          const x = Math.cos(lat1)*Math.sin(lat2) - Math.sin(lat1)*Math.cos(lat2)*Math.cos(dLon);
                          let heading = Math.atan2(y, x);
                          let hdgDeg = Math.round((heading * 180/Math.PI + 360) % 360);
                          return `HDG:${hdgDeg}° SPD:${speed.toFixed(1)}m/s`;
                        }catch(e){ return ''; }
                      }, false),
                      font: '12px sans-serif',
                      fillColor: Cesium.Color.WHITE,
                      style: Cesium.LabelStyle.FILL_AND_OUTLINE,
                      outlineWidth: 2,
                      pixelOffset: new Cesium.Cartesian2(12, -12)
                    }
                  });
                  movingEnt._subj = subj;
                  movingEnt._samples = samples;
                  missionReplay.replayEntities.push(movingEnt);

                  // Add a dynamic arrow billboard that rotates with heading (derived from velocity)
                  const arrowCanvas = document.createElement('canvas'); arrowCanvas.width = 32; arrowCanvas.height = 32;
                  const arrowCtx = arrowCanvas.getContext('2d');
                  arrowCtx.clearRect(0,0,32,32); arrowCtx.translate(16,16);
                  arrowCtx.beginPath(); arrowCtx.moveTo(0,-10); arrowCtx.lineTo(6,6); arrowCtx.lineTo(0,2); arrowCtx.lineTo(-6,6); arrowCtx.closePath();
                  arrowCtx.fillStyle = 'rgba(255,255,255,0.95)'; arrowCtx.fill();
                  const arrowImg = arrowCanvas.toDataURL();

                  const arrowEnt = window.viewer.entities.add({
                    name: `AAR Head ${subj}`,
                    position: prop,
                    billboard: {
                      image: arrowImg,
                      verticalOrigin: Cesium.VerticalOrigin.CENTER,
                      scale: 1.0,
                      rotation: new Cesium.CallbackProperty(function(time, result){
                        try{
                          const jd = time;
                          const prevJd = Cesium.JulianDate.addSeconds(jd, -0.5, new Cesium.JulianDate());
                          const pNow = prop.getValue(jd); const pPrev = prop.getValue(prevJd);
                          if(!pNow || !pPrev) return 0.0;
                          const cNow = Cesium.Cartographic.fromCartesian(pNow);
                          const cPrev = Cesium.Cartographic.fromCartesian(pPrev);
                          const y = Math.sin(cNow.longitude - cPrev.longitude) * Math.cos(cNow.latitude);
                          const x = Math.cos(cPrev.latitude)*Math.sin(cNow.latitude) - Math.sin(cPrev.latitude)*Math.cos(cNow.latitude)*Math.cos(cNow.longitude - cPrev.longitude);
                          const heading = Math.atan2(y, x);
                          return heading; // Cesium billboard rotation in radians
                        }catch(e){ return 0.0; }
                      }, false)
                    }
                  });
                  // Tag created entities with subject id for quick lookup
                prop._subj = subj; poly._subj = subj; movingEnt._subj = subj; arrowEnt._subj = subj; missionReplay.replayEntities.push(arrowEnt);
                }

                // Optionally set viewer clock to the current replay time so SampledPositionProperty interpolates
                if(currentTimeMs && window.viewer && window.viewer.clock){
                  try{
                    const jd = Cesium.JulianDate.fromDate(new Date(currentTimeMs));
                    window.viewer.clock.shouldAnimate = false;
                    window.viewer.clock.currentTime = jd;
                    // Force scene update
                    window.viewer.scene.requestRender();
                  }catch(e){ console.warn('failed to set viewer clock for replay', e); }
                }

                // Wire up a pick handler once to allow selecting units by clicking the head/polyline/point
                try{
                  if(window.viewer && !window._missionTrailSelectHandler){
                    window._missionTrailSelectHandler = new Cesium.ScreenSpaceEventHandler(window.viewer.canvas);
                    window._missionTrailSelectHandler.setInputAction(function(click){
                      try{
                        const picked = window.viewer.scene.pick(click.position);
                        if(picked && picked.id){
                          const ent = picked.id;
                          const subj = ent._subj || (ent.name && (ent.name.match(/AAR (?:Unit|Poly|Head) (.+)/) || [])[1]);
                          if(subj){ selectUnit(subj, { follow: true }); return; }
                        }
                        // clicked empty space -> deselect
                        selectUnit(null);
                      }catch(e){ console.warn('pick handler error', e); }
                    }, Cesium.ScreenSpaceEventType.LEFT_CLICK);

                    // allow deselect with ESC
                    window.addEventListener('keydown', function(e){ if(e.key === 'Escape') selectUnit(null); });

                    // attach a cheap postRender HUD updater so HUD updates smoothly while scrubbing/playing
                    if(!window._unitHudUpdaterAttached && window.viewer && window.viewer.scene){
                      window.viewer.scene.postRender.addEventListener(function(){
                        try{
                          if(missionReplay.selectedUnit){ updateUnitHUD(missionReplay.selectedUnit); }
                        }catch(e){}
                      });
                      window._unitHudUpdaterAttached = true;
                    }
                  }
                }catch(e){ console.warn('failed to attach pick handler', e); }

                // --- Selection utilities: highlight trail and unit info ---

                function updateUnitHUD(subj){
                  try{
                    if(!subj){ return; }
                    const ent = (missionReplay.replayEntities||[]).find(e=>e._subj === subj && e.name && e.name.indexOf('AAR Unit') === 0);
                    if(!ent) return;
                    const prop = ent.position;
                    const nowJd = (window.viewer && window.viewer.clock && window.viewer.clock.currentTime) ? window.viewer.clock.currentTime : Cesium.JulianDate.now();
                    const prevJd = Cesium.JulianDate.addSeconds(nowJd, -1.0, new Cesium.JulianDate());
                    const pNow = prop.getValue(nowJd); const pPrev = prop.getValue(prevJd);
                    let lastSpeed = null;
                    if(pNow && pPrev){
                      const cartoNow = Cesium.Cartographic.fromCartesian(pNow);
                      const cartoPrev = Cesium.Cartographic.fromCartesian(pPrev);
                      const geodesic = new Cesium.EllipsoidGeodesic(cartoPrev, cartoNow);
                      const distM = geodesic.surfaceDistance || Cesium.Cartesian3.distance(pPrev, pNow);
                      const dt = (Cesium.JulianDate.toDate(nowJd).getTime() - Cesium.JulianDate.toDate(prevJd).getTime())/1000.0 || 1.0;
                      const speed = distM / dt; // m/s
                      lastSpeed = speed;
                      const y = Math.sin(cartoNow.longitude - cartoPrev.longitude) * Math.cos(cartoNow.latitude);
                      const x = Math.cos(cartoPrev.latitude)*Math.sin(cartoNow.latitude) - Math.sin(cartoPrev.latitude)*Math.cos(cartoNow.latitude)*Math.cos(cartoNow.longitude - cartoPrev.longitude);
                      const heading = Math.atan2(y, x);
                      const hdgDeg = Math.round((heading * 180/Math.PI + 360) % 360);
                      document.getElementById('unit-hud-speed').textContent = `${speed.toFixed(1)} m/s`;
                      document.getElementById('unit-hud-heading').textContent = `${hdgDeg}°`;
                      document.getElementById('unit-hud-altitude').textContent = `${(cartoNow.height||0).toFixed(0)} m`;
                    } else {
                      document.getElementById('unit-hud-speed').textContent = '-';
                      document.getElementById('unit-hud-heading').textContent = '-';
                      document.getElementById('unit-hud-altitude').textContent = '-';
                    }
                    // last update and confidence from samples
                    const samples = ent._samples || [];
                    if(samples.length>0){
                      const last = samples[samples.length-1];
                      document.getElementById('unit-hud-lastupdate').textContent = new Date(last.ts).toISOString();
                      document.getElementById('unit-hud-confidence').textContent = (last.confidence==null) ? '-' : (Math.round(last.confidence*100) + '%');
                    }else{
                      document.getElementById('unit-hud-lastupdate').textContent = '-';
                      document.getElementById('unit-hud-confidence').textContent = '-';
                    }

                    // draw sparkline of recent speeds using historical buffer (persisted between rebuilds)
                    try{
                      const cvs = document.getElementById('unit-hud-sparkline');
                      let speeds = (missionReplay.historicSpeeds && missionReplay.historicSpeeds[subj]) ? missionReplay.historicSpeeds[subj].slice() : [];
                      // fallback: derive from samples if historic buffer not present
                      if(speeds.length === 0 && samples.length>1){
                        for(let i=0;i<samples.length-1;i++){
                          const a = samples[i], b = samples[i+1];
                          const dt = (b.ts - a.ts)/1000.0; if(dt <= 0) { speeds.push(0); continue; }
                          const cA = Cesium.Cartographic.fromDegrees(a.lon,a.lat); const cB = Cesium.Cartographic.fromDegrees(b.lon,b.lat);
                          const geo = new Cesium.EllipsoidGeodesic(cA, cB);
                          const d = geo.surfaceDistance || 0;
                          speeds.push(d / dt);
                        }
                      }

                      if(cvs && speeds.length>0){
                        const ctx = cvs.getContext('2d');
                        const W = cvs.width; const H = cvs.height; ctx.clearRect(0,0,W,H);

                        // Convert speeds to selected unit for plotting
                        const unit = missionReplay.speedUnit || 'm/s';
                        const conv = (v)=> unit === 'km/h' ? v*3.6 : unit === 'knots' ? v*1.94384449 : v;
                        const convSpeeds = speeds.map(conv);

                        // pad or trim buffer to a maximum display length
                        const maxPoints = Math.min(120, Math.max(8, Math.floor(W/3)));
                        const pts = convSpeeds.slice(-maxPoints);

                        const maxV = Math.max(1, Math.max(...pts)); const minV = Math.min(...pts, 0);
                        const pxPer = W / Math.max(1, pts.length - 1);
                        // draw gradient fill
                        ctx.beginPath();
                        for(let i=0;i<pts.length;i++){
                          const v = pts[i];
                          const x = Math.round(i * pxPer);
                          const y = H - Math.round(((v - minV) / Math.max(1e-6, (maxV - minV))) * (H-6)) - 3;
                          if(i===0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
                        }
                        ctx.lineWidth = 2; ctx.strokeStyle = 'rgba(50,200,250,0.95)'; ctx.stroke();
                        // fill under curve
                        ctx.lineTo(W, H); ctx.lineTo(0, H); ctx.closePath();
                        const g = ctx.createLinearGradient(0,0,0,H); g.addColorStop(0, 'rgba(50,200,250,0.25)'); g.addColorStop(1, 'rgba(50,200,250,0.02)');
                        ctx.fillStyle = g; ctx.fill();
                        // draw last value marker
                        const lastX = Math.round((pts.length-1) * pxPer); const lastY = H - Math.round(((pts[pts.length-1] - minV) / Math.max(1e-6, (maxV - minV))) * (H-6)) - 3;
                        ctx.beginPath(); ctx.arc(lastX, lastY, 3, 0, Math.PI*2); ctx.fillStyle = 'rgba(255,255,255,0.95)'; ctx.fill();

                        // update displayed speed with units
                        const lastVal = pts[pts.length-1];
                        document.getElementById('unit-hud-speed').textContent = `${lastVal.toFixed(1)} ${unit}`;
                      } else if(cvs){ const ctx = cvs.getContext('2d'); ctx.clearRect(0,0,cvs.width,cvs.height); ctx.fillStyle='rgba(255,255,255,0.06)'; ctx.fillRect(0,cvs.height/2-1,cvs.width,2); }
                    }catch(e){ /* ignore sparkline errors */ }

                  }catch(e){ console.warn('updateUnitHUD failed', e); }
                }

                function updateSelectionVisuals(){
                  try{
                    const sel = missionReplay.selectedUnit;
                    (missionReplay.replayEntities || []).forEach(ent => {
                      try{
                        const isSel = ent._subj && sel && ent._subj === sel;
                        if(ent.polyline){
                          if(isSel){ ent.polyline.width = 8; ent.polyline.material = new Cesium.ColorMaterialProperty(Cesium.Color.YELLOW.withAlpha(0.95)); }
                          else { ent.polyline.width = 4; ent.polyline.material = ent._origMaterial || new Cesium.ColorMaterialProperty(Cesium.Color.LIME.withAlpha(0.5)); }
                        }
                        if(ent.point){
                          if(isSel){ ent.point.pixelSize = 14; ent.point.color = Cesium.Color.YELLOW; }
                          else { ent.point.pixelSize = 8; ent.point.color = ent.point.color || Cesium.Color.LIME; }
                        }
                        if(ent.billboard){ ent.billboard.scale = isSel ? 1.6 : 1.0; }
                        if(ent.label){ ent.label.scale = isSel ? 1.1 : 1.0; }
                      }catch(e){}
                    });
                  }catch(e){ console.warn('updateSelectionVisuals failed', e); }
                }

                function selectUnit(subj, opts = { follow: false }){
                  try{
                    const followBtn = document.getElementById('unit-follow-btn');
                    if(!subj){ missionReplay.selectedUnit = null; updateSelectionVisuals(); if(window.viewer) window.viewer.trackedEntity = undefined; document.getElementById('unit-callsign').textContent = 'No unit selected'; if(followBtn) followBtn.textContent = 'Follow'; // clear HUD
                      document.getElementById('unit-hud-speed').textContent = '-'; document.getElementById('unit-hud-heading').textContent = '-'; document.getElementById('unit-hud-altitude').textContent = '-'; document.getElementById('unit-hud-lastupdate').textContent = '-'; document.getElementById('unit-hud-confidence').textContent = '-';
                      // clear sparkline
                      const sc = document.getElementById('unit-hud-sparkline'); if(sc){ const ctx = sc.getContext('2d'); ctx.clearRect(0,0,sc.width, sc.height); ctx.fillStyle='rgba(255,255,255,0.06)'; ctx.fillRect(0,sc.height/2-1,sc.width,2); }
                      return; }
                    missionReplay.selectedUnit = subj;
                    updateSelectionVisuals();
                    const a = missionReplay.playStore?.state?.assets?.find(x=>x.id===subj) || missionStore?.state?.assets?.find(x=>x.id===subj);
                    if(a){ document.getElementById('unit-callsign').textContent = a.callsign || a.id; document.getElementById('unit-role').textContent = 'role: ' + (a.type || '-'); document.getElementById('unit-posture').textContent = 'posture: ' + (a.posture || '-'); }
                    else { document.getElementById('unit-callsign').textContent = subj; }

                    if(opts.follow && window.viewer){
                      const target = (missionReplay.replayEntities||[]).find(e=>e._subj === subj && e.name && e.name.indexOf('AAR Unit') === 0);
                      if(target){ window.viewer.trackedEntity = target; missionReplay.followingUnit = subj; if(followBtn) followBtn.textContent = 'Unfollow'; }
                    }
                    // update follow button text if following
                    if(followBtn){ if(missionReplay.followingUnit === subj) followBtn.textContent = 'Unfollow'; else followBtn.textContent = 'Follow'; }

                    // populate HUD now
                    updateUnitHUD(subj);
                  }catch(e){ console.warn('selectUnit failed', e); }
                }

              }catch(e){ console.warn('updateMapFromReplay failed', e); }
            }

            async function setPlaybackIndex(idx){
              if(!missionStore || !missionStore.pkg) return;
              const events = missionStore.pkg.event_log || [];
              idx = Math.max(0, Math.min(events.length-1, idx));
              missionReplay.currentIndex = idx;
              // Create a shallow clone of pkg but slice event_log
              const pkg = JSON.parse(JSON.stringify(missionStore.pkg));
              pkg.event_log = (missionStore.pkg.event_log || []).slice(0, idx+1);
              const playStore = new MissionStore({ template: missionStore.template });
              playStore.loadMissionPackage(pkg);
              missionReplay.playStore = playStore;

              // Update UI
              renderTaskList(playStore.getTasksForRender());
              renderMissionHeader(playStore.state.mission, playStore);

              // Update map (pass the timestamp so moving tracks interpolate)
              const curTimeMs = indexToTimeMs(idx);
              updateMapFromReplay(playStore, curTimeMs);

              // restore selection/follow after rebuild
              if(missionReplay.selectedUnit) { selectUnit(missionReplay.selectedUnit, { follow: false }); updateUnitHUD(missionReplay.selectedUnit); }
              if(missionReplay.followingUnit) selectUnit(missionReplay.followingUnit, { follow: true });

              // set scrub input to the event timestamp for this index
              const scrub = document.getElementById('mission-timeline-scrub'); 
              if(scrub) scrub.value = curTimeMs;
              updateTimelineLabel(curTimeMs);
            }

            async function setPlaybackTime(timeMs){
              if(!missionStore || !missionStore.pkg) return;
              const idx = timeToIndex(Number(timeMs));
              await setPlaybackIndex(idx);
              const scrub = document.getElementById('mission-timeline-scrub'); if(scrub) scrub.value = Number(timeMs);
              updateTimelineLabel(Number(timeMs));
            }

            function stopPlayback(){
              missionReplay.playing = false;
              if(missionReplay.playTimer){ clearTimeout(missionReplay.playTimer); missionReplay.playTimer = null; }
            }

            function startPlayback(){
              if(!missionStore || !missionStore.pkg) return;
              const events = missionStore.pkg.event_log || [];
              if(events.length===0) return;
              stopPlayback();
              missionReplay.playing = true;

              // recursive step using event timestamps scaled by speed
              const step = async ()=>{
                if(!missionReplay.playing) return;
                const curIdx = missionReplay.currentIndex;
                const nextIdx = curIdx + 1;
                if(nextIdx >= events.length){ stopPlayback(); return; }
                const curT = indexToTimeMs(curIdx);
                const nextT = indexToTimeMs(nextIdx);
                const delta = Math.max(1, nextT - curT);
                const delay = delta / Math.max(0.001, missionReplay.speed);
                missionReplay.playTimer = setTimeout(async ()=>{
                  try{
                    await setPlaybackIndex(nextIdx);
                    step();
                  }catch(e){ console.warn('playback step failed', e); stopPlayback(); }
                }, delay);
              };

              // Kick off
              step();
            }

            // Wire timeline controls
            document.getElementById('timelinePlayBtn')?.addEventListener('click', ()=>{ startPlayback(); });
            document.getElementById('timelinePauseBtn')?.addEventListener('click', ()=>{ stopPlayback(); });
            document.getElementById('timelineSpeed')?.addEventListener('change', (e)=>{ missionReplay.speed = Number(e.target.value || 1); if(missionReplay.playing){ stopPlayback(); startPlayback(); }});
            document.getElementById('mission-timeline-scrub')?.addEventListener('input', (e)=>{ const v=Number(e.target.value); stopPlayback(); setPlaybackTime(v); });
            document.getElementById('timelineStepBack')?.addEventListener('click', ()=>{ const v = Number(document.getElementById('mission-timeline-scrub')?.value || 0); const idx = timeToIndex(v); setPlaybackIndex(Math.max(0, idx-1)); });
            document.getElementById('timelineStepForward')?.addEventListener('click', ()=>{ const v = Number(document.getElementById('mission-timeline-scrub')?.value || 0); const idx = timeToIndex(v); setPlaybackIndex(Math.min((missionStore?.pkg?.event_log||[]).length-1, idx+1)); });

            // Rebuild timeline whenever missionStore loads a new package
            const origLoad = loadMissionForUI;
            loadMissionForUI = async function(){ await origLoad(); buildTimeline(); };

            // units selector handler
            document.getElementById('unit-hud-units')?.addEventListener('change', (e)=>{
              missionReplay.speedUnit = e.target.value || 'm/s';
              if(missionReplay.selectedUnit) updateUnitHUD(missionReplay.selectedUnit);
            });

            // After initial load
            buildTimeline();
            document.getElementById('missionExportAARBtn2')?.addEventListener('click', ()=>{ if(!missionStore) return; const aar = { mission_id: missionStore.pkg.mission.id, event_log: missionStore.pkg.event_log }; const data = JSON.stringify(aar, null, 2); const blob = new Blob([data], {type:'application/json'}); const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href=url; a.download = (missionStore.pkg.mission?.id || 'mission') + '.aar.json'; a.click(); URL.revokeObjectURL(url); });

            window.startMissionStream && (function attachEventListenForMissionEvents(){
              const original = window.startMissionStream;
              window.startMissionStream = function(mid, since){
                const ok = original(mid, since);
                try{
                  if(window._missionEventSource){
                    window._missionEventSource.addEventListener('EVENT', function(e){
                      try{
                        const msg = JSON.parse(e.data);
                        // Expecting messages shaped { type:'mission.event', event: {...} }
                        if(msg && msg.type === 'mission.event' && msg.event){
                          if(missionStore) missionStore.applyEvent(msg.event, {replay:false});
                          renderTaskList(missionStore.getTasksForRender());
                          renderMissionHeader(missionStore.state.mission);
                          try{ buildTimeline(); }catch(e){ console.warn('buildTimeline on EVENT failed', e); }
                        }
                      }catch(err){ console.warn('[MissionStream] EVENT parse failed', err); }
                    });
                  }
                }catch(e){ console.warn('attachEventListenForMissionEvents failed', e); }
                return ok;
              };
            })();

            loadMissionForUI();
            })();

        })();
    </script>

<script>
/**
 * AIS Reconciliation & Popup Logic (Fix for Sandbox Issues)
 * Creates a parent-DOM popup for AIS targets instead of using the sandboxed InfoBox
 */
(function() {
    function propVal(prop){
        if(prop && prop.getValue) return prop.getValue(Cesium.JulianDate.now());
        return prop;
    }

    async function addAISToRecon(vessel, correlation){
        const isViolation = !!(correlation && correlation.violation);
        
        // Use deterministic entity_id based on MMSI to prevent duplicates
        const entityId = vessel.mmsi ? `AIS-${vessel.mmsi}` : `AIS-${vessel.name || Date.now()}`.replace(/\s+/g, '_');
        
        // Construct payload
        const payload = {
            entity_id: entityId,  // Deterministic ID for idempotent create-or-update
            mmsi: vessel.mmsi,
            name: vessel.name,
            type: 'RECON_ENTITY',  // Explicit type for proper entity_type resolution
            callsign: vessel.callsign,
            lat: vessel.lat,
            lon: vessel.lon,
            course: vessel.course,
            speed: vessel.speed,
            destination: vessel.destination,
            source: 'AIS_TRAFFIC',
            rf_violation: isViolation
        };

        const log = (msg, type='info') => {
            console.log(`[AIS->Recon] ${msg}`);
            if(window.addConsoleMessage) window.addConsoleMessage(msg, type);
        };
        const toast = (msg) => {
             if(window.showNotification) window.showNotification('Recon Save', msg, 'info');
        };

        log(`Saving ${vessel.name || vessel.mmsi} to Recon...`, 'command');

        try {
            // Include session token for provenance tracking
            const headers = { 'Content-Type': 'application/json' };
            if (window.OperatorSession && window.OperatorSession.sessionToken) {
                headers['X-Session-Token'] = window.OperatorSession.sessionToken;
            }
            
            const resp = await fetch('/api/recon/entity', {
                method: 'POST',
                headers: headers,
                body: JSON.stringify(payload)
            });

            if(!resp.ok){
                toast(`Server persist failed (${resp.status}) — saved locally instead`);
                throw new Error('Server persist failed');
            }

            let data = null;
            try { data = await resp.json(); }
            catch (e) {
                toast('Server returned unexpected response; saved locally instead');
                throw new Error('Non-JSON response from server');
            }

            if (data && data.status === 'ok' && data.entity) {
                const entity = data.entity;
                // Normalize location
                entity.location = entity.location || {};
                entity.location.lat = Number(entity.location.lat) || 0;
                entity.location.lon = Number(entity.location.lon) || 0;
                entity.location.altitude_m = Number(entity.location.altitude_m ?? entity.location.alt ?? 0) || 0;

                window.AutoReconVisualization = window.AutoReconVisualization || {};
                window.AutoReconVisualization.entities = window.AutoReconVisualization.entities || {};
                window.AutoReconVisualization.entities[entity.entity_id] = entity;
                if (window.AutoReconVisualization.addEntityMarker) window.AutoReconVisualization.addEntityMarker(entity);
                if (window.updateReconList) window.updateReconList();
                
                // Show success feedback
                log(`Added to Recon (server): ${entity.name}`, 'response');
                toast(`Saved: ${entity.name}`);
                return entity;
            }

            toast('Server rejected entity; saved locally instead');
            throw new Error('Server rejected entity');
        } catch (err) {
            // Client-only fallback
            console.warn('AIS recon persist failed, falling back to client-only insertion', err);
            const entId = `ais_${vessel.mmsi || (vessel.name || '').replace(/\s+/g,'_') || Math.floor(Math.random()*100000)}`;
            const entity = {
                entity_id: entId,
                name: vessel.name || `AIS ${vessel.mmsi || entId}`,
                disposition: isViolation ? 'HOSTILE' : 'UNKNOWN',
                threat_level: isViolation ? 'HIGH' : 'NONE',
                location: { lat: Number(vessel.lat) || 0, lon: Number(vessel.lon) || 0, altitude_m: 0 },
                ontology: ['vessel','ais'],
                source: 'ais_ui',
                meta: { vessel, correlation }
            };

            window.AutoReconVisualization = window.AutoReconVisualization || {};
            window.AutoReconVisualization.entities = window.AutoReconVisualization.entities || {};
            window.AutoReconVisualization.entities[entity.entity_id] = entity;
            if (window.AutoReconVisualization.addEntityMarker) window.AutoReconVisualization.addEntityMarker(entity);
            if (window.updateReconList) window.updateReconList();
            log(`Added to Recon (client): ${entity.name}`, 'response');
            toast(`Saved (Local): ${entity.name}`);
            return entity;
        }
    }

    function isAisEntity(ent){
        try {
            if (!ent) return false;
            // Check ID prefix
            if (ent.id && typeof ent.id === 'string' && ent.id.startsWith('ais_vessel_')) return true;
            // Check property type
            const t = propVal(ent.properties && ent.properties.type);
            return t === 'ais_vessel';
        } catch(e){ return false; }
    }

    function getSelectedAis(){
        try {
            const viewer = window.viewer;
            if (!viewer) return null;
            const ent = viewer.selectedEntity;
            if (!isAisEntity(ent)) return null;

            const vessel = propVal(ent.properties && ent.properties.vesselData);
            const correlation = propVal(ent.properties && ent.properties.rfCorrelation);
            const mmsi = propVal(ent.properties && ent.properties.mmsi) || (vessel && vessel.mmsi);
            
            // Essential check: must have at least an MMSI
            if(!mmsi && !vessel) return null;
            
            // Reconstruct vessel object if missing (using properties)
            const v = vessel || {
                mmsi: mmsi,
                name: propVal(ent.properties.name) || `AIS ${mmsi}`,
                lat: propVal(ent.properties.latitude),
                lon: propVal(ent.properties.longitude),
                callsign: propVal(ent.properties.callsign)
            };
            
            return { entity: ent, vessel: v, correlation, mmsi };
        } catch(e){ return null; }
    }

    function ensurePopupElements(){
        const popup = document.getElementById('ais-recon-popup');
        if (!popup) return null;

        const els = {
            popup,
            title: document.getElementById('ais-recon-title'),
            subtitle: document.getElementById('ais-recon-subtitle'),
            btnSave: document.getElementById('ais-recon-save'),
            btnFly: document.getElementById('ais-recon-flyto'),
            btnTrack: document.getElementById('ais-recon-track'),
            btnIgnore: document.getElementById('ais-recon-ignore'),
            btnClose: document.getElementById('ais-recon-close')
        };
        return els;
    }

    function showPopup(state){
        const els = ensurePopupElements();
        if (!els) return;

        const vesselName = (state.vessel && state.vessel.name) ? state.vessel.name : 'Unknown Vessel';
        const mmsiTxt = state.mmsi ? `MMSI ${state.mmsi}` : 'MMSI ?';
        const isViolation = !!(state.correlation && state.correlation.violation);

        els.title.textContent = isViolation ? 'AIS Target (⚠ RF Violation)' : 'AIS Target';
        els.subtitle.textContent = `${vesselName} • ${mmsiTxt}`;
        
        // Color code title based on threat
        els.title.style.color = isViolation ? '#ff4d4d' : '#4a9eff';

        els.popup.dataset.mmsi = String(state.mmsi || '');
        els.popup.style.display = 'block';

        // Wire buttons (idempotent - checked via dataset)
        if (!els.popup.dataset._wired) {
            
            // 1. Close
            els.btnClose.addEventListener('click', () => { els.popup.style.display = 'none'; });
            
            // 2. Fly To (Action: Animation)
            els.btnFly.addEventListener('click', () => {
                try {
                    const s = getSelectedAis();
                    if (s && window.viewer) {
                        // Fly to with a slight offset so we see the ship
                        window.viewer.flyTo(s.entity, { duration: 1.5, offset: new Cesium.HeadingPitchRange(0, -0.5, 2000) });
                    }
                } catch(e){ console.warn(e); }
            });

            // 3. Track (Action: Lock Camera)
            if(els.btnTrack) els.btnTrack.addEventListener('click', () => {
                 try {
                    const s = getSelectedAis();
                    if (s && window.viewer) {
                        window.viewer.trackedEntity = s.entity;
                        // Toast not avail in this scope unless defined, simple console for now
                        console.log('Tracking entity:', s.entity.name);
                    }
                } catch(e){ console.warn(e); }
            });

            // 4. Ignore (Action: Remove from view / blacklist)
            if(els.btnIgnore) els.btnIgnore.addEventListener('click', () => {
                const s = getSelectedAis();
                if(s && window.viewer && confirm(`Ignore/Hide vessel ${s.vessel.name}?`)){
                    // Hide entity
                    s.entity.show = false; 
                    // Use standard selection clearing to dismiss popup
                    window.viewer.selectedEntity = undefined;
                    // TODO: Persist blacklist if needed
                }
            });

            // 5. Save (Action: API)
            els.btnSave.addEventListener('click', async () => {
                const s = getSelectedAis();
                if (!s || !s.vessel) return;
                
                // Visual feedback on button
                const btn = els.btnSave;
                // Save original icon html
                const origHtml = btn.innerHTML;
                
                btn.style.opacity = '0.7';
                btn.innerHTML = 'Saving...';
                btn.disabled = true;

                try {
                    // Prefer an app-provided promotion hook if it exists
                    if (window.AISVisualization && typeof window.AISVisualization.promoteToRecon === 'function') {
                        await window.AISVisualization.promoteToRecon(s.vessel, s.correlation);
                    } else {
                        await addAISToRecon(s.vessel, s.correlation);
                    }
                    btn.innerHTML = '<span style="color:#aaffaa">✅ Saved</span>';
                } catch(e){ 
                    console.warn('AIS promote failed', e); 
                    btn.innerHTML = '<span style="color:#ffaaaa">❌ Error</span>';
                }
                
                // Reset button after delay
                setTimeout(() => {
                    btn.innerHTML = origHtml;
                    btn.style.opacity = '1';
                    btn.disabled = false;
                }, 2000);
            });
            els.popup.dataset._wired = '1';
        }
    }

    function hidePopup(){
        const popup = document.getElementById('ais-recon-popup');
        if (popup) popup.style.display = 'none';
    }

    function onSelectionChanged(){
        const s = getSelectedAis();
        if (s) showPopup(s);
        else hidePopup();
    }

    function attach(){
        try {
            const viewer = window.viewer;
            if (!viewer || !viewer.selectedEntityChanged || typeof viewer.selectedEntityChanged.addEventListener !== 'function') {
                return false;
            }
            if (viewer.__aisReconPopupAttached) return true;
            viewer.__aisReconPopupAttached = true;

            viewer.selectedEntityChanged.addEventListener(onSelectionChanged);
            
            // Check initial selection
            onSelectionChanged();
            
            console.log('[AIS Popup] attached successfully');
            return true;
        } catch(e){ console.warn('attach ais recon popup failed', e); return false; }
    }

    // Attach after load (viewer is created async in this app)
    window.addEventListener('load', () => {
        let tries = 0;
        const t = setInterval(() => {
            tries++;
            if (attach() || tries > 30) clearInterval(t);
        }, 500);
    });
})();
</script>

<div id="cesium-context-menu" aria-label="Cesium context menu"></div>
<div id="cesium-hover-tooltip" aria-label="Cesium hover tooltip"></div>


<script>
/**
 * Tactical context menu + hover tooltip for Cesium picks.
 * Avoids Cesium InfoBox iframe sandbox entirely (no about:blank script blocking).
 */
(function() {
  function propVal(props, key) {
    try {
      if (!props || !props[key]) return null;
      const p = props[key];
      if (p && typeof p.getValue === 'function') return p.getValue(Cesium.JulianDate.now());
      return p;
    } catch (_) { return null; }
  }

  function resolvePickedEntity(picked) {
    if (!picked) return null;
    return picked.id || (picked.primitive && picked.primitive.id) || null;
  }

  function clampToViewport(x, y, pad) {
    const p = pad || 6;
    const vw = window.innerWidth || 1920;
    const vh = window.innerHeight || 1080;
    return {
      x: Math.max(p, Math.min(vw - p, x)),
      y: Math.max(p, Math.min(vh - p, y))
    };
  }

  function buildTooltipHTML(entity) {
    const props = entity && entity.properties;
    const type = propVal(props, 'type');

    if (type === 'recon_entity') {
      const entityId = propVal(props, 'entityId') || (entity.id && String(entity.id).replace(/^recon_/, ''));
      const data = propVal(props, 'entityData') || {};
      const name = data.name || entityId || 'Recon Entity';
      const disp = data.disposition || data.status || 'UNKNOWN';
      const threat = (data.threat_level !== undefined && data.threat_level !== null) ? data.threat_level : '—';

      const loc = data.location || {};
      const lat = parseFloat(loc.lat ?? loc.latitude);
      const lon = parseFloat(loc.lon ?? loc.longitude);

      const assignedIds = (window.SensorManager && window.SensorManager.assignments && entityId) ? (window.SensorManager.assignments[entityId] || []) : [];
      const sensorLabels = assignedIds
        .map(sid => (window.SensorManager && window.SensorManager.sensors && window.SensorManager.sensors[sid] && window.SensorManager.sensors[sid].label) ? window.SensorManager.sensors[sid].label : sid)
        .filter(Boolean);

      const coord = (!isNaN(lat) && !isNaN(lon)) ? `${lat.toFixed(5)}, ${lon.toFixed(5)}` : '—';

      return `
        <div class="tt-title">🧭 ${escapeHTML(name)}</div>
        <div class="tt-line"><span class="tt-dim">ID:</span> ${escapeHTML(String(entityId || '—'))}</div>
        <div class="tt-line"><span class="tt-dim">Coord:</span> ${escapeHTML(coord)}</div>
        <div class="tt-line"><span class="tt-dim">Disposition:</span> ${escapeHTML(String(disp))}</div>
        <div class="tt-line"><span class="tt-dim">Threat:</span> ${escapeHTML(String(threat))}</div>
        <div class="tt-line"><span class="tt-dim">Sensors:</span> ${escapeHTML(sensorLabels.length ? sensorLabels.join(', ') : '—')}</div>
      `.trim();
    }

    if (type === 'ais_vessel') {
      const vessel = propVal(props, 'vesselData') || {};
      const mmsi = vessel.mmsi || propVal(props, 'mmsi') || '—';
      const name = vessel.name || vessel.shipname || vessel.callsign || `MMSI ${mmsi}`;
      const lat = parseFloat(vessel.lat ?? vessel.latitude);
      const lon = parseFloat(vessel.lon ?? vessel.longitude);
      const sog = (vessel.sog !== undefined && vessel.sog !== null) ? vessel.sog : '—';
      const cog = (vessel.cog !== undefined && vessel.cog !== null) ? vessel.cog : '—';
      const coord = (!isNaN(lat) && !isNaN(lon)) ? `${lat.toFixed(5)}, ${lon.toFixed(5)}` : '—';

      return `
        <div class="tt-title">🚢 ${escapeHTML(String(name))}</div>
        <div class="tt-line"><span class="tt-dim">MMSI:</span> ${escapeHTML(String(mmsi))}</div>
        <div class="tt-line"><span class="tt-dim">Coord:</span> ${escapeHTML(coord)}</div>
        <div class="tt-line"><span class="tt-dim">SOG/COG:</span> ${escapeHTML(String(sog))} / ${escapeHTML(String(cog))}</div>
      `.trim();
    }

    return null;
  }

  function escapeHTML(s) {
    return String(s)
      .replaceAll('&', '&amp;')
      .replaceAll('<', '&lt;')
      .replaceAll('>', '&gt;')
      .replaceAll('"', '&quot;')
      .replaceAll("'", '&#039;');
  }

  function attach() {
    const viewer = window.viewer;
    if (!viewer || window.__tacticalContextAttached) return !!window.__tacticalContextAttached;

    const cm = document.getElementById('cesium-context-menu');
    const tt = document.getElementById('cesium-hover-tooltip');
    if (!cm || !tt) return false;

    window.__tacticalContextAttached = true;

    const canvas = viewer.canvas;

    // Kill browser default context menu over canvas
    canvas.addEventListener('contextmenu', (e) => {
      e.preventDefault();
      e.stopPropagation();
      return false;
    }, { passive: false });

    function hideMenu() {
      cm.style.display = 'none';
      cm.innerHTML = '';
    }

    function hideTooltip() {
      tt.style.display = 'none';
      tt.innerHTML = '';
    }

    function showMenuAt(clientX, clientY, title, items) {
      // Build
      const parts = [];
      parts.push(`<div class="cm-title">${escapeHTML(title)}</div>`);
      if (!items || !items.length) {
        parts.push(`<div class="cm-muted">No actions available</div>`);
      } else {
        items.forEach(it => {
          if (it === 'sep') {
            parts.push(`<div class="cm-sep"></div>`);
          } else {
            const id = `cm_${Math.random().toString(16).slice(2)}`;
            parts.push(`<div class="cm-item" data-cm-id="${id}">${escapeHTML(it.label)}</div>`);
            it.__id = id;
          }
        });
      }
      cm.innerHTML = parts.join('');
      cm.style.display = 'block';

      // Position (clamp)
      const desired = clampToViewport(clientX, clientY, 10);
      cm.style.left = `${desired.x}px`;
      cm.style.top = `${desired.y}px`;

      // Wire click
      cm.querySelectorAll('.cm-item').forEach(el => {
        const found = items.find(it => it && it.__id === el.getAttribute('data-cm-id'));
        if (!found) return;
        el.addEventListener('click', (ev) => {
          ev.preventDefault();
          ev.stopPropagation();
          hideMenu();
          try { found.onClick(); } catch (e) { console.error(e); }
        });
      });
    }

    // Hide menu on any left click elsewhere / ESC
    window.addEventListener('mousedown', (e) => {
      if (cm.style.display === 'block') {
        // If click is outside cm => hide
        if (!cm.contains(e.target)) hideMenu();
      }
    }, true);
    window.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') hideMenu();
    });

    // Cesium input handler
    const handler = new Cesium.ScreenSpaceEventHandler(canvas);
    window.__tacticalContextHandler = handler;

    // Right click => show tactical menu at cursor
    handler.setInputAction((movement) => {
      try {
        const picked = viewer.scene.pick(movement.position);
        const entity = resolvePickedEntity(picked);

        const rect = canvas.getBoundingClientRect();
        const clientX = rect.left + movement.position.x;
        const clientY = rect.top + movement.position.y;

        // Default: if nothing picked, show coord menu
        if (!entity) {
          // Try get globe position
          let carto = null;
          const ray = viewer.camera.getPickRay(movement.position);
          const cart = ray ? viewer.scene.globe.pick(ray, viewer.scene) : null;
          if (cart) carto = Cesium.Cartographic.fromCartesian(cart);
          const lat = carto ? Cesium.Math.toDegrees(carto.latitude) : null;
          const lon = carto ? Cesium.Math.toDegrees(carto.longitude) : null;
          const title = (lat !== null && lon !== null) ? `📍 ${lat.toFixed(5)}, ${lon.toFixed(5)}` : '📍 Map';
          showMenuAt(clientX, clientY, title, [
            { label: 'Center camera here', onClick: () => {
              if (lat !== null && lon !== null) viewer.camera.flyTo({ destination: Cesium.Cartesian3.fromDegrees(lon, lat, 25000) });
            }},
            'sep',
            { label: 'Drop recon marker (manual)', onClick: () => {
              if (lat === null || lon === null) return;
              if (window.AutoReconVisualization && typeof window.AutoReconVisualization.createEntity === 'function') {
                // If you have a createEntity helper, use it. Otherwise just log.
                addConsoleMessage(`Manual marker requested at ${lat.toFixed(5)}, ${lon.toFixed(5)}`, 'command');
              } else {
                addConsoleMessage(`Manual marker requested at ${lat.toFixed(5)}, ${lon.toFixed(5)}`, 'command');
              }
            }}
          ]);
          return;
        }

        const props = entity.properties;
        const type = propVal(props, 'type');

        if (type === 'recon_entity') {
          const entityId = propVal(props, 'entityId') || (entity.id && String(entity.id).replace(/^recon_/, ''));
          const data = propVal(props, 'entityData') || {};
          const title = `🧭 ${data.name || entityId || 'Recon Entity'}`;
          showMenuAt(clientX, clientY, title, [
            { label: '🎯 Fly to', onClick: () => {
              if (window.AutoReconVisualization && typeof window.AutoReconVisualization.flyToEntity === 'function') {
                window.AutoReconVisualization.flyToEntity(entityId);
              } else {
                viewer.flyTo(entity);
              }
            }},
            { label: '📌 Track (lock camera)', onClick: () => { viewer.trackedEntity = entity; } },
            'sep',
            { label: '📝 Create task', onClick: () => {
              if (window.AutoReconVisualization && typeof window.AutoReconVisualization.createTaskForEntity === 'function') {
                window.AutoReconVisualization.createTaskForEntity(entityId);
              }
            }},
            { label: '📡 Assign sensor…', onClick: () => {
              if (typeof window.showPanel === 'function') window.showPanel('sensors');
              // reveal the create form & preselect entity
              const createBtn = document.getElementById('sensorCreateBtn');
              const form = document.getElementById('sensor-create-form');
              if (form && form.style.display === 'none' && createBtn) createBtn.click();
              if (window.SensorManager && typeof window.SensorManager._populateEntityDropdown === 'function') {
                window.SensorManager._populateEntityDropdown();
              }
              const sel = document.getElementById('sensor-assign-entity');
              if (sel) sel.value = entityId;
              sel && sel.scrollIntoView({ block: 'center', behavior: 'smooth' });
            }},
            'sep',
            { label: '🧹 Clear tracking', onClick: () => { viewer.trackedEntity = undefined; } }
          ]);
          return;
        }

        if (type === 'ais_vessel') {
          const vessel = propVal(props, 'vesselData') || {};
          const name = vessel.name || vessel.shipname || vessel.callsign || (vessel.mmsi ? `MMSI ${vessel.mmsi}` : 'AIS Vessel');
          showMenuAt(clientX, clientY, `🚢 ${name}`, [
            { label: '🎯 Fly to', onClick: () => viewer.flyTo(entity) },
            { label: '📌 Track (lock camera)', onClick: () => { viewer.trackedEntity = entity; } },
            'sep',
            { label: '💾 Save as Recon Entity', onClick: () => {
              if (window.AISVisualization && typeof window.AISVisualization.promoteToRecon === 'function') {
                window.AISVisualization.promoteToRecon(vessel);
              } else {
                addConsoleMessage('AISVisualization.promoteToRecon not available', 'alert');
              }
            }},
            'sep',
            { label: '🧹 Clear tracking', onClick: () => { viewer.trackedEntity = undefined; } }
          ]);
          return;
        }

        // Unknown picked entity => generic menu
        showMenuAt(clientX, clientY, 'Object', [
          { label: '🎯 Fly to', onClick: () => viewer.flyTo(entity) },
          { label: '📌 Track', onClick: () => { viewer.trackedEntity = entity; } }
        ]);
      } catch (e) {
        console.error('[ContextMenu] Error', e);
      }
    }, Cesium.ScreenSpaceEventType.RIGHT_CLICK);

    // Hover tooltip for recon/ais entities
    let lastEntityId = null;
    handler.setInputAction((movement) => {
      try {
        if (cm.style.display === 'block') return; // don't fight the menu
        const picked = viewer.scene.pick(movement.endPosition);
        const entity = resolvePickedEntity(picked);

        if (!entity) {
          lastEntityId = null;
          hideTooltip();
          return;
        }

        const html = buildTooltipHTML(entity);
        if (!html) {
          lastEntityId = null;
          hideTooltip();
          return;
        }

        // avoid DOM churn if hovering same entity
        const eid = String(entity.id || '');
        if (eid !== lastEntityId) {
          tt.innerHTML = html;
          lastEntityId = eid;
        }

        const rect = canvas.getBoundingClientRect();
        const clientX = rect.left + movement.endPosition.x + 14;
        const clientY = rect.top + movement.endPosition.y + 16;
        const pos = clampToViewport(clientX, clientY, 10);
        tt.style.left = `${pos.x}px`;
        tt.style.top = `${pos.y}px`;
        tt.style.display = 'block';
      } catch (e) {
        // silent
      }
    }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);

    console.log('[TacticalContext] Context menu + tooltip attached');
    return true;
  }

  function waitAttach() {
    let tries = 0;
    const t = setInterval(() => {
      tries++;
      if (attach() || tries > 40) clearInterval(t);
    }, 500);
  }

  if (document.readyState === 'complete' || document.readyState === 'interactive') {
    waitAttach();
  } else {
    window.addEventListener('DOMContentLoaded', waitAttach);
  }
})();
</script>


<script>
// =========================================================================
// CesiumEntityManager — safe position resolver + geo-aware layout
// =========================================================================
(function() {
    'use strict';

    // ── KIND → BAND mapping (altitude bands in metres above ground) ─────
    const KIND_BAND = {
        anchor:    0,
        host:      1,
        flow:      2,
        dns:       3,
        alert:     4,
        session:   5,
        default:   6,
    };
    const BAND_HEIGHT_M  = 40;   // vertical gap between bands
    const BASE_RADIUS_M  = 30;   // radial offset for siblings in same band

    /**
     * resolveCesiumPosition(entity, fallbackCartesian3)
     *
     * Returns a valid Cesium.Cartesian3 or *fallbackCartesian3*.
     * NEVER returns undefined / NaN cartesian.
     *
     * entity must have { location: { lat, lon, altitude_m? } }
     */
    function resolveCesiumPosition(entity, fallbackCartesian3) {
        const loc = entity && entity.location;
        if (!loc) return fallbackCartesian3 || null;

        const lat = parseFloat(loc.lat);
        const lon = parseFloat(loc.lon);
        const alt = parseFloat(loc.altitude_m) || 0;

        if (!isFinite(lat) || !isFinite(lon)) return fallbackCartesian3 || null;
        if (lat < -90 || lat > 90 || lon < -180 || lon > 180) return fallbackCartesian3 || null;

        try {
            const c3 = Cesium.Cartesian3.fromDegrees(lon, lat, alt);
            // Sanity: Cesium may produce (0,0,0) for degenerate inputs
            if (c3.x === 0 && c3.y === 0 && c3.z === 0) return fallbackCartesian3 || null;
            return c3;
        } catch (e) {
            console.warn('[resolveCesiumPosition] Cartesian3 failed:', e.message);
            return fallbackCartesian3 || null;
        }
    }

    /**
     * CesiumEntityManager
     *
     * Wraps entity creation on the Cesium viewer with:
     *   - coordinate validation (never creates invalid entities)
     *   - geo-aware band layout for hosts/flows relative to an anchor
     *   - safe arc (polyline) creation between valid-only endpoints
     *   - deduplication (re-adds replace old entities)
     */
    class CesiumEntityManager {
        constructor(viewer) {
            this.viewer = viewer;
            this._managed = {};     // entity_id → CesiumEntity ref
            this._anchors = {};     // session_id → Cartesian3 of primary host
            this._bandCounts = {};  // session_id → { band: count } for radial offsets
        }

        /** Set the anchor (primary host) for a session. */
        setAnchor(sessionId, lat, lon) {
            if (!isFinite(lat) || !isFinite(lon)) return;
            this._anchors[sessionId] = Cesium.Cartesian3.fromDegrees(lon, lat, 0);
            this._bandCounts[sessionId] = {};
        }

        /** Get the next radial offset position in a band around an anchor. */
        _bandPosition(sessionId, kind, lat, lon) {
            const band = KIND_BAND[kind] !== undefined ? KIND_BAND[kind] : KIND_BAND.default;
            const alt = band * BAND_HEIGHT_M;

            // If we have an anchor, offset radially from it
            const anchor = this._anchors[sessionId];
            if (!anchor) {
                return Cesium.Cartesian3.fromDegrees(lon, lat, alt);
            }

            if (!this._bandCounts[sessionId]) this._bandCounts[sessionId] = {};
            const counts = this._bandCounts[sessionId];
            counts[band] = (counts[band] || 0) + 1;
            const idx = counts[band];
            const angle = (idx * 2 * Math.PI) / Math.max(idx, 8);
            const radiusM = BASE_RADIUS_M + (idx * 5);

            // ENU offset: east/north in metres → degrees (approximate)
            const dLat = (radiusM * Math.cos(angle)) / 111320;
            const dLon = (radiusM * Math.sin(angle)) / (111320 * Math.cos(lat * Math.PI / 180));

            return Cesium.Cartesian3.fromDegrees(lon + dLon, lat + dLat, alt);
        }

        /**
         * addHost — safely add a PCAP host entity.
         * Returns the Cesium entity or null if coordinates are invalid.
         */
        addHost(hostData, sessionId) {
            const lat = parseFloat(hostData.lat);
            const lon = parseFloat(hostData.lon);
            if (!isFinite(lat) || !isFinite(lon)) {
                console.warn(`[CesiumEntityManager] Skipping host ${hostData.ip} — no valid geo`);
                return null;
            }

            const pcapId = 'PCAP-' + (hostData.ip || 'unknown').replace(/[^a-zA-Z0-9]/g, '_');
            const kind = 'host';
            const position = this._bandPosition(sessionId, kind, lat, lon);
            const color = Cesium.Color.CYAN.withAlpha(0.8);

            // Remove prior entity if exists
            if (this._managed[pcapId]) {
                try { this.viewer.entities.remove(this._managed[pcapId]); } catch (_) {}
            }

            try {
                const entity = this.viewer.entities.add({
                    id: `recon_entity_${pcapId}`,
                    name: `${hostData.ip} (${hostData.city || hostData.country || hostData.org || 'PCAP Host'})`,
                    position: position,
                    billboard: {
                        image: (window.AutoReconVisualization && typeof window.AutoReconVisualization.createEntityIcon === 'function')
                            ? window.AutoReconVisualization.createEntityIcon(color, 'UNKNOWN', false)
                            : undefined,
                        scale: 0.5,
                        verticalOrigin: Cesium.VerticalOrigin.CENTER,
                        horizontalOrigin: Cesium.HorizontalOrigin.CENTER,
                    },
                    label: {
                        text: `${hostData.ip}\n${hostData.org || hostData.city || ''}`,
                        font: '10px sans-serif',
                        fillColor: color,
                        outlineColor: Cesium.Color.BLACK,
                        outlineWidth: 2,
                        style: Cesium.LabelStyle.FILL_AND_OUTLINE,
                        verticalOrigin: Cesium.VerticalOrigin.TOP,
                        pixelOffset: new Cesium.Cartesian2(0, 16),
                        show: true,
                    },
                    properties: {
                        type: 'pcap_host',
                        entityId: pcapId,
                        ip: hostData.ip,
                        bytes: hostData.bytes || 0,
                    },
                });
                this._managed[pcapId] = entity;
                return entity;
            } catch (e) {
                console.error(`[CesiumEntityManager] Failed to add host ${hostData.ip}:`, e);
                return null;
            }
        }

        /**
         * addFlowArc — safely add a flow polyline between two geo-resolved hosts.
         * Both endpoints must have valid lat/lon or the arc is skipped.
         */
        addFlowArc(srcHost, dstHost) {
            const srcLat = parseFloat(srcHost.lat);
            const srcLon = parseFloat(srcHost.lon);
            const dstLat = parseFloat(dstHost.lat);
            const dstLon = parseFloat(dstHost.lon);

            if (!isFinite(srcLat) || !isFinite(srcLon) || !isFinite(dstLat) || !isFinite(dstLon)) {
                return null;
            }

            try {
                return this.viewer.entities.add({
                    name: `Flow: ${srcHost.ip} → ${dstHost.ip}`,
                    polyline: {
                        positions: Cesium.Cartesian3.fromDegreesArray([
                            srcLon, srcLat,
                            dstLon, dstLat
                        ]),
                        width: 2,
                        material: new Cesium.PolylineGlowMaterialProperty({
                            glowPower: 0.15,
                            color: Cesium.Color.CYAN.withAlpha(0.6),
                        }),
                        clampToGround: true,
                    },
                });
            } catch (e) {
                console.warn(`[CesiumEntityManager] Flow arc failed: ${e.message}`);
                return null;
            }
        }

        /** Remove all managed entities. */
        clear() {
            Object.values(this._managed).forEach(e => {
                try { this.viewer.entities.remove(e); } catch (_) {}
            });
            this._managed = {};
            this._anchors = {};
            this._bandCounts = {};
        }
    }

    // Expose globally
    window.resolveCesiumPosition = resolveCesiumPosition;
    window.CesiumEntityManager = CesiumEntityManager;
})();
</script>


<script>
// PCAP Upload & Ingestion Logic
(function() {
    const dropZone = document.getElementById('pcap-drop-zone');
    const fileInput = document.getElementById('pcap-file-input');
    const fileInfo = document.getElementById('pcap-file-info');
    const fileName = document.getElementById('pcap-filename');
    const fileSize = document.getElementById('pcap-filesize');
    const uploadBtn = document.getElementById('pcap-upload-btn');
    const progressContainer = document.getElementById('pcap-progress-container');
    const progressBar = document.getElementById('pcap-progress-bar');
    const progressLabel = document.getElementById('pcap-progress-label');
    const progressPercent = document.getElementById('pcap-progress-percent');
    
    let selectedFile = null;

    if (!dropZone || !fileInput) return;

    // Drag & Drop
    dropZone.addEventListener('dragover', (e) => {
        e.preventDefault();
        dropZone.style.borderColor = '#4a9eff';
        dropZone.style.background = 'rgba(74, 158, 255, 0.1)';
    });

    dropZone.addEventListener('dragleave', (e) => {
        e.preventDefault();
        dropZone.style.borderColor = '#444';
        dropZone.style.background = '';
    });

    dropZone.addEventListener('drop', (e) => {
        e.preventDefault();
        dropZone.style.borderColor = '#444';
        dropZone.style.background = '';
        if (e.dataTransfer.files.length) {
            handleFileSelect(e.dataTransfer.files[0]);
        }
    });

    // Click to browse
    dropZone.addEventListener('click', () => fileInput.click());
    fileInput.addEventListener('change', (e) => {
        if (e.target.files.length) {
            handleFileSelect(e.target.files[0]);
        }
    });

    function handleFileSelect(file) {
        if (!file) return;
        selectedFile = file;
        
        fileName.textContent = file.name;
        fileSize.textContent = `(${(file.size / (1024 * 1024)).toFixed(2)} MB)`;
        
        dropZone.style.display = 'none';
        fileInfo.style.display = 'block';
        uploadBtn.disabled = false;
    }

    // Upload & Ingest
    uploadBtn.addEventListener('click', async () => {
        if (!selectedFile) return;

        uploadBtn.disabled = true;
        uploadBtn.textContent = "Uploading...";
        progressContainer.style.display = 'block';
        updateProgress(0, "Uploading...");

        const formData = new FormData();
        formData.append('file', selectedFile);
        formData.append('sensor_id', document.getElementById('pcap-sensor-id').value);
        formData.append('mission_id', document.getElementById('pcap-mission-id').value);
        
        const tags = document.getElementById('pcap-tags').value.split(',').map(s => s.trim()).filter(s => s);
        formData.append('tags', JSON.stringify(tags));

        try {
            // 1. Upload
            const resp = await fetch('/api/pcap/upload', {
                method: 'POST',
                headers: {
                    'X-Session-Token': window.OperatorSession?.sessionToken || ''
                },
                body: formData
            });

            if (!resp.ok) throw new Error(`Upload failed: ${resp.status}`);
            const data = await resp.json();
            
            if (data.status !== 'ok') throw new Error(data.message || 'Upload error');
            
            const sessionId = data.session.session_id;
            updateProgress(50, "Ingesting...");
            
            // 2. Trigger Ingest
            const ingestResp = await fetch(`/api/pcap/${sessionId}/ingest`, {
                 method: 'POST',
                 headers: { 'Content-Type': 'application/json' },
                 body: JSON.stringify({ mode: 'flows', dpi: true })
            });
            
            const ingestData = await ingestResp.json();
            
            updateProgress(100, "Complete");
            addConsoleMessage(`PCAP Ingest Complete: ${data.session.session_id} — ${ingestData.result?.host_count || 0} hosts, ${ingestData.result?.flow_count || 0} flows`, 'success');
            
            // Add to history
            addHistoryItem(data.session);
            
            // --- PROMOTE PCAP HOSTS TO RECON ENTITIES & FLY ---
            // Uses the same proven pattern as nmap "Geolocate & Fly" button:
            //  1. Create Recon Entity per IP
            //  2. Inject into AutoReconVisualization.entities (optimistic UI)
            //  3. POST to /api/recon/entity for persistence
            //  4. addEntityMarker() for CesiumJS billboard
            //  5. flyToEntity() for camera (proven working)
            const geoPoints = ingestData.result?.geo_points || [];
            const v = window.viewer || (typeof viewer !== 'undefined' ? viewer : null);
            const arv = window.AutoReconVisualization;

            if (geoPoints.length > 0 && v && arv && arv.entities) {
                // Sort by bytes descending — heaviest-traffic host = primary target
                const sorted = [...geoPoints].sort((a, b) => (b.bytes || 0) - (a.bytes || 0));
                const primaryEntityId = null;
                let firstEntityId = null;

                for (let i = 0; i < sorted.length; i++) {
                    const p = sorted[i];
                    // Sanitize entity ID from IP
                    const pcapId = 'PCAP-' + (p.ip || 'unknown').replace(/[^a-zA-Z0-9]/g, '_');

                    // 1. Build Recon Entity object (same schema as nmap target)
                    const reconEntity = {
                        entity_id: pcapId,
                        name: `${p.ip} (${p.city || p.country || p.org || 'PCAP Host'})`,
                        disposition: i === 0 ? 'SUSPICIOUS' : 'UNKNOWN',
                        threat_level: 'UNKNOWN',
                        type: 'PCAP_HOST',
                        location: {
                            lat: p.lat,
                            lon: p.lon,
                            altitude_m: 500
                        },
                        velocity: { heading_deg: 0, speed_kts: 0 },
                        last_seen: new Date().toISOString(),
                        metadata: {
                            source: 'pcap_ingest',
                            session_id: data.session.session_id,
                            ip: p.ip,
                            org: p.org || '',
                            city: p.city || '',
                            country: p.country || '',
                            bytes: p.bytes || 0
                        }
                    };

                    // 2. Inject into AutoReconVisualization store (optimistic UI)
                    arv.entities[pcapId] = reconEntity;

                    // 3. Persist to server (async, non-blocking)
                    fetch('/api/recon/entity', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(reconEntity)
                    }).then(r => r.json()).then(d => {
                        if (d.status === 'ok') console.log('[PCAP] Recon entity persisted:', pcapId);
                    }).catch(e => console.warn('[PCAP] Persist failed:', pcapId, e));

                    // 4. Create visual marker via AutoReconVisualization
                    try {
                        const reconCesiumId = `recon_entity_${pcapId}`;
                        if (v.entities.getById(reconCesiumId)) {
                            console.log('[PCAP] Entity marker already exists:', pcapId);
                        } else if (typeof arv.addEntityMarker === 'function') {
                            arv.addEntityMarker(reconEntity);
                        }
                    } catch (markerErr) {
                        console.warn('[PCAP] Marker creation failed:', pcapId, markerErr);
                    }

                    if (i === 0) firstEntityId = pcapId;
                }

                // Draw flow arcs between primary host and others
                for (let i = 1; i < sorted.length; i++) {
                    try {
                        const src = sorted[0];
                        const dst = sorted[i];
                        v.entities.add({
                            name: `Flow: ${src.ip} → ${dst.ip}`,
                            polyline: {
                                positions: Cesium.Cartesian3.fromDegreesArray([
                                    src.lon, src.lat, dst.lon, dst.lat
                                ]),
                                width: 2,
                                material: new Cesium.PolylineGlowMaterialProperty({
                                    glowPower: 0.15,
                                    color: Cesium.Color.CYAN.withAlpha(0.6)
                                }),
                                clampToGround: true
                            }
                        });
                    } catch (e) { /* ignore arc errors */ }
                }

                // 5. FLY TO PRIMARY HOST using proven flyToEntity pattern
                addConsoleMessage(`Created ${sorted.length} Recon Entities from PCAP hosts`, 'success');

                if (firstEntityId && typeof arv.flyToEntity === 'function') {
                    addConsoleMessage(`Camera tracking PCAP primary host: ${sorted[0].ip}`, 'info');
                    arv.flyToEntity(firstEntityId);
                } else {
                    // Fallback: direct camera flight to primary host
                    const primary = sorted[0];
                    try {
                        v.camera.cancelFlight();
                        v.camera.lookAtTransform(Cesium.Matrix4.IDENTITY);
                        v.trackedEntity = undefined;
                        if (v.scene && v.scene.screenSpaceCameraController) {
                            const ctrl = v.scene.screenSpaceCameraController;
                            ctrl.enableRotate = ctrl.enableTilt = ctrl.enableZoom = ctrl.enableTranslate = ctrl.enableLook = true;
                        }
                        v.camera.flyTo({
                            destination: Cesium.Cartesian3.fromDegrees(primary.lon, primary.lat, 500000),
                            orientation: {
                                heading: v.camera.heading,
                                pitch: Cesium.Math.toRadians(-45),
                                roll: 0
                            },
                            duration: 2.5,
                            complete: function() {
                                try {
                                    v.camera.lookAtTransform(Cesium.Matrix4.IDENTITY);
                                    v.trackedEntity = undefined;
                                    const c = v.scene.screenSpaceCameraController;
                                    c.enableRotate = c.enableTilt = c.enableZoom = c.enableTranslate = c.enableLook = true;
                                    v.scene.requestRender();
                                } catch(e) {}
                                addConsoleMessage(`Camera positioned over ${primary.ip}`, 'success');
                            }
                        });
                        v.scene.requestRender();
                    } catch (flyErr) {
                        console.error('[PCAP] Camera flight failed:', flyErr);
                    }
                }
            } else if (geoPoints.length > 0) {
                addConsoleMessage(`${geoPoints.length} hosts geolocated but AutoReconVisualization not available`, 'alert');
            }
            
            // Reset UI after delay
            setTimeout(() => {
                resetUI();
            }, 2000);

        } catch (e) {
            console.error(e);
            updateProgress(0, "Failed");
            addConsoleMessage(`PCAP Error: ${e.message}`, 'error');
            uploadBtn.textContent = "Retry";
            uploadBtn.disabled = false;
        }
    });

    function updateProgress(percent, label) {
        progressBar.style.width = `${percent}%`;
        progressPercent.textContent = `${percent}%`;
        if (label) progressLabel.textContent = label;
    }

    function resetUI() {
        selectedFile = null;
        fileInput.value = '';
        dropZone.style.display = 'block';
        fileInfo.style.display = 'none';
        progressContainer.style.display = 'none';
        uploadBtn.textContent = "Upload & Ingest";
        uploadBtn.disabled = true;
    }
    
    function addHistoryItem(session, fromServer) {
        const list = document.getElementById('pcap-history-list');
        const placeholder = list.querySelector('.list-placeholder');
        if (placeholder) placeholder.remove();
        
        // Avoid duplicates
        if (list.querySelector(`[data-session-id="${session.session_id}"]`)) return;
        
        const div = document.createElement('div');
        div.setAttribute('data-session-id', session.session_id);
        div.style.padding = '8px';
        div.style.borderBottom = '1px solid #333';
        div.style.background = 'rgba(255,255,255,0.02)';
        
        const timeStr = session.created_at ? new Date(session.created_at * 1000).toLocaleTimeString() : 'Unknown';
        const tags = session.metadata?.tags?.join(', ') || 'No tags';
        const hasPcap = session.pcap_on_disk !== false;
        const shaShort = session.artifact_sha256 ? session.artifact_sha256.substring(0, 12) : '';
        
        div.innerHTML = `
            <div style="display: flex; justify-content: space-between; align-items: center;">
                <div style="flex:1; min-width:0;">
                    <div style="font-weight:bold; color:#4a9eff; font-size:11px; word-break:break-all;">${session.session_id}</div>
                    <div style="color:#888;">${timeStr} • ${tags}</div>
                    ${shaShort ? `<div style="color:#666; font-size:10px;">SHA: ${shaShort}... ${hasPcap ? '✅' : '❌ missing'}</div>` : ''}
                </div>
                <div style="display:flex; flex-direction:column; gap:4px; margin-left:6px;">
                    <button class="action-button pcap-reingest-btn" data-sid="${session.session_id}" 
                        style="padding:4px 8px; font-size:10px; white-space:nowrap;" 
                        ${!hasPcap ? 'disabled title="PCAP file missing from disk"' : ''}
                    >Re-ingest</button>
                    <button class="action-button pcap-viewgraph-btn" data-sid="${session.session_id}" 
                        style="padding:4px 8px; font-size:10px; white-space:nowrap; background:rgba(138,43,226,0.15); border-color:#9b59b6;"
                    >View Graph</button>
                    <button class="action-button pcap-globe-btn" data-sid="${session.session_id}" 
                        style="padding:4px 8px; font-size:10px; white-space:nowrap; background:rgba(26,188,156,0.15); border-color:#1abc9c; color:#1abc9c;"
                    >🌐 Globe</button>
                </div>
            </div>
        `;
        list.prepend(div);
        
        // Attach re-ingest handler
        const btn = div.querySelector('.pcap-reingest-btn');
        if (btn) {
            btn.addEventListener('click', () => reingestSession(session.session_id));
        }
        // Attach view graph handler
        const graphBtn = div.querySelector('.pcap-viewgraph-btn');
        if (graphBtn) {
            graphBtn.addEventListener('click', () => viewSessionGraph(session.session_id));
        }
        // Attach globe overlay handler
        const globeBtn = div.querySelector('.pcap-globe-btn');
        if (globeBtn) {
            globeBtn.addEventListener('click', async () => {
                if (!window.PcapGlobeOverlay) {
                    addConsoleMessage('PcapGlobeOverlay not loaded', 'error');
                    return;
                }
                globeBtn.textContent = 'Loading...';
                globeBtn.disabled = true;
                try {
                    await window.PcapGlobeOverlay.loadSession(session.session_id, { mode: 'ports' });
                    addConsoleMessage(`Globe overlay loaded for ${session.session_id}`, 'success');
                } catch (e) {
                    console.error('[PCAP] Globe overlay error:', e);
                    addConsoleMessage(`Globe overlay failed: ${e.message}`, 'error');
                } finally {
                    globeBtn.textContent = '\uD83C\uDF10 Globe';
                    globeBtn.disabled = false;
                }
            });
        }
    }
    
    // Load stored sessions from server
    async function loadStoredSessions() {
        const btn = document.getElementById('pcap-load-sessions-btn');
        if (btn) btn.textContent = 'Loading...';
        try {
            const resp = await fetch('/api/pcap/sessions');
            if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
            const data = await resp.json();
            if ((data.ok || data.status === 'ok') && data.sessions) {
                data.sessions.forEach(s => addHistoryItem(window.normalizePcapSession(s), true));
                addConsoleMessage(`Loaded ${data.sessions.length} stored PCAP sessions`, 'info');
            }
        } catch (e) {
            console.error('[PCAP] Failed to load sessions:', e);
            addConsoleMessage(`Failed to load stored sessions: ${e.message}`, 'alert');
        } finally {
            if (btn) btn.textContent = 'Load Stored';
        }
    }
    
    // Re-ingest a stored session (replay without re-uploading)
    async function reingestSession(sessionId) {
        addConsoleMessage(`Re-ingesting session ${sessionId}...`, 'info');
        
        const progressContainer = document.getElementById('pcap-progress-container');
        const progressBar = document.getElementById('pcap-progress-bar');
        const progressLabel = document.getElementById('pcap-progress-label');
        const progressPercent = document.getElementById('pcap-progress-percent');
        
        if (progressContainer) progressContainer.style.display = 'block';
        if (progressBar) progressBar.style.width = '30%';
        if (progressLabel) progressLabel.textContent = 'Re-ingesting...';
        if (progressPercent) progressPercent.textContent = '30%';
        
        try {
            const resp = await fetch(`/api/pcap/${sessionId}/ingest`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ mode: 'flows', dpi: true })
            });
            const ingestData = await resp.json();
            
            if (progressBar) progressBar.style.width = '100%';
            if (progressLabel) progressLabel.textContent = 'Complete';
            if (progressPercent) progressPercent.textContent = '100%';
            
            addConsoleMessage(`Re-ingest Complete: ${sessionId} — ${ingestData.result?.host_count || 0} hosts, ${ingestData.result?.flow_count || 0} flows${ingestData.result?.note === 'simulated' ? ' (simulated)' : ' (real Scapy)'}`, 'success');
            
            // --- PROMOTE GEO-RESOLVED PCAP HOSTS TO CESIUM ENTITIES ---
            const geoPoints = ingestData.result?.geo_points || [];
            const v = window.viewer || (typeof viewer !== 'undefined' ? viewer : null);
            const arv = window.AutoReconVisualization;
            
            if (geoPoints.length > 0 && v) {
                // Filter to only hosts with valid geo coordinates
                const validGeo = geoPoints.filter(p => {
                    const lat = parseFloat(p.lat);
                    const lon = parseFloat(p.lon);
                    return isFinite(lat) && isFinite(lon) && lat >= -90 && lat <= 90 && lon >= -180 && lon <= 180;
                });
                const skipped = geoPoints.length - validGeo.length;
                if (skipped > 0) {
                    addConsoleMessage(`Skipped ${skipped} hosts without geo coordinates`, 'info');
                }
                
                const sorted = [...validGeo].sort((a, b) => (b.bytes || 0) - (a.bytes || 0));
                let firstEntityId = null;
                let created = 0;
                
                // Use CesiumEntityManager if available, otherwise defensive fallback
                const mgr = (typeof CesiumEntityManager === 'function')
                    ? new CesiumEntityManager(v) : null;
                
                // Set anchor to top-traffic host
                if (mgr && sorted.length > 0) {
                    mgr.setAnchor(sessionId, parseFloat(sorted[0].lat), parseFloat(sorted[0].lon));
                }
                
                for (let i = 0; i < sorted.length; i++) {
                    const p = sorted[i];
                    const pcapId = 'PCAP-' + (p.ip || 'unknown').replace(/[^a-zA-Z0-9]/g, '_');
                    
                    if (mgr) {
                        // CesiumEntityManager handles validation + band layout
                        const entity = mgr.addHost(p, sessionId);
                        if (entity) created++;
                    } else {
                        // Fallback: use AutoReconVisualization with validated coords
                        const lat = parseFloat(p.lat);
                        const lon = parseFloat(p.lon);
                        if (!isFinite(lat) || !isFinite(lon)) continue;
                        
                        const reconEntity = {
                            entity_id: pcapId,
                            name: `${p.ip} (${p.city || p.country || p.org || 'PCAP Host'})`,
                            disposition: i === 0 ? 'SUSPICIOUS' : 'UNKNOWN',
                            threat_level: 'UNKNOWN',
                            type: 'PCAP_HOST',
                            location: { lat: lat, lon: lon, altitude_m: 500 },
                            velocity: { heading_deg: 0, speed_kts: 0 },
                            last_seen: new Date().toISOString(),
                            metadata: { source: 'pcap_reingest', session_id: sessionId, ip: p.ip, org: p.org || '', city: p.city || '', country: p.country || '', bytes: p.bytes || 0 }
                        };
                        
                        if (arv && arv.entities) arv.entities[pcapId] = reconEntity;
                        fetch('/api/recon/entity', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(reconEntity) }).catch(() => {});
                        
                        try {
                            const reconCesiumId = `recon_entity_${pcapId}`;
                            if (!v.entities.getById(reconCesiumId) && arv && typeof arv.addEntityMarker === 'function') {
                                arv.addEntityMarker(reconEntity);
                            }
                            created++;
                        } catch (e) {}
                    }
                    
                    if (i === 0) firstEntityId = pcapId;
                }
                
                // Flow arcs — only between geo-valid hosts
                let arcCount = 0;
                if (sorted.length > 1) {
                    for (let i = 1; i < sorted.length; i++) {
                        if (mgr) {
                            if (mgr.addFlowArc(sorted[0], sorted[i])) arcCount++;
                        } else {
                            // Manual guard: validate both endpoints
                            const sLat = parseFloat(sorted[0].lat), sLon = parseFloat(sorted[0].lon);
                            const dLat = parseFloat(sorted[i].lat), dLon = parseFloat(sorted[i].lon);
                            if (!isFinite(sLat) || !isFinite(sLon) || !isFinite(dLat) || !isFinite(dLon)) continue;
                            try {
                                v.entities.add({
                                    name: `Flow: ${sorted[0].ip} → ${sorted[i].ip}`,
                                    polyline: {
                                        positions: Cesium.Cartesian3.fromDegreesArray([sLon, sLat, dLon, dLat]),
                                        width: 2,
                                        material: new Cesium.PolylineGlowMaterialProperty({
                                            glowPower: 0.15,
                                            color: Cesium.Color.CYAN.withAlpha(0.6),
                                        }),
                                        clampToGround: true,
                                    },
                                });
                                arcCount++;
                            } catch (e) {}
                        }
                    }
                }
                
                addConsoleMessage(`Created ${created} Cesium entities + ${arcCount} flow arcs (${skipped} hosts lacked geo)`, 'success');
                if (firstEntityId) {
                    // Fly to first entity
                    if (arv && typeof arv.flyToEntity === 'function') {
                        arv.flyToEntity(firstEntityId);
                    } else if (sorted.length > 0) {
                        try {
                            v.camera.flyTo({
                                destination: Cesium.Cartesian3.fromDegrees(
                                    parseFloat(sorted[0].lon), parseFloat(sorted[0].lat), 500000
                                ),
                                duration: 2.0,
                            });
                        } catch (e) {}
                    }
                }
            }
            
            setTimeout(() => {
                if (progressContainer) progressContainer.style.display = 'none';
            }, 2000);
        } catch (e) {
            addConsoleMessage(`Re-ingest failed: ${e.message}`, 'error');
            if (progressLabel) progressLabel.textContent = 'Failed';
            if (progressBar) progressBar.style.width = '0%';
        }
    }
    
    // Attach load stored sessions button
    const loadBtn = document.getElementById('pcap-load-sessions-btn');
    if (loadBtn) loadBtn.addEventListener('click', loadStoredSessions);
    
    // Auto-load on panel open
    loadStoredSessions();
    
    // =========================================================================
    // VIEW SESSION HYPERGRAPH
    // =========================================================================
    async function viewSessionGraph(sessionId) {
        addConsoleMessage(`Loading hypergraph for ${sessionId}...`, 'info');
        
        try {
            const resp = await fetch(`/api/pcap/${sessionId}/subgraph?depth=2`);
            if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
            const data = await resp.json();
            
            if (!data.ok || !data.subgraph) {
                const errMsg = data.error || data.message || 'No subgraph data';
                addConsoleMessage(`${errMsg} for ${sessionId}`, 'alert');
                return;
            }
            
            const sg = data.subgraph;
            const nodes = sg.nodes || [];
            const edges = sg.edges || [];
            const stats = sg.stats || {};
            
            // Remove existing modal if any
            let modal = document.getElementById('pcap-graph-modal');
            if (modal) modal.remove();
            
            // Create modal overlay
            modal = document.createElement('div');
            modal.id = 'pcap-graph-modal';
            modal.style.cssText = 'position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.85);z-index:10000;display:flex;align-items:center;justify-content:center;';
            
            // Kind color map
            const kindColors = {
                pcap_session: '#4a9eff',
                pcap_artifact: '#e74c3c',
                pcap_activity: '#f39c12',
                host: '#2ecc71',
                geo_point: '#9b59b6',
                flow_aggregate: '#1abc9c',
                SESSION_HAS_ARTIFACT: '#ff6b6b',
                SESSION_OBSERVED_HOST: '#4ecdc4',
                HOST_GEO_ESTIMATE: '#a29bfe',
                SESSION_ACTIVITY: '#ffeaa7',
                SESSION_OBSERVED_FLOW: '#74b9ff',
                FLOW_SRC: '#fd79a8',
                FLOW_DST: '#e17055'
            };
            
            // Build kind legend and stats
            const kindEntries = Object.entries(stats.kinds || {}).sort((a,b) => b[1] - a[1]);
            const legendHtml = kindEntries.map(([k, count]) => {
                const c = kindColors[k] || '#888';
                return `<span style="display:inline-flex;align-items:center;gap:4px;margin:2px 8px 2px 0;font-size:11px;"><span style="width:10px;height:10px;border-radius:50%;background:${c};display:inline-block;"></span>${k}: <strong>${count}</strong></span>`;
            }).join('');
            
            // Build node table rows (sorted by kind)
            const sortedNodes = [...nodes].sort((a,b) => (a.kind||'').localeCompare(b.kind||''));
            const nodeRowsHtml = sortedNodes.map(n => {
                const c = kindColors[n.kind] || '#888';
                const labels = n.labels ? Object.entries(n.labels).filter(([k,v])=>v!==null&&v!==undefined).map(([k,v])=>`${k}=${typeof v==='number'?v.toLocaleString():v}`).join(', ') : '';
                const pos = n.position ? `[${n.position.map(p=>typeof p==='number'?p.toFixed(4):p).join(', ')}]` : '';
                return `<tr style="border-bottom:1px solid #333;">
                    <td style="padding:3px 6px;"><span style="color:${c};font-weight:600;">${n.kind||'?'}</span></td>
                    <td style="padding:3px 6px;color:#ccc;font-family:monospace;font-size:10px;word-break:break-all;">${n.id}</td>
                    <td style="padding:3px 6px;color:#aaa;font-size:10px;">${labels}</td>
                    <td style="padding:3px 6px;color:#888;font-size:10px;">${pos}</td>
                </tr>`;
            }).join('');
            
            // Build edge table rows
            const edgeRowsHtml = edges.map(e => {
                const c = kindColors[e.kind] || '#888';
                const nodesList = (e.nodes||[]).join(' → ');
                return `<tr style="border-bottom:1px solid #333;">
                    <td style="padding:3px 6px;"><span style="color:${c};font-weight:600;">${e.kind||'?'}</span></td>
                    <td style="padding:3px 6px;color:#ccc;font-family:monospace;font-size:10px;word-break:break-all;">${e.id||''}</td>
                    <td style="padding:3px 6px;color:#aaa;font-size:10px;word-break:break-all;">${nodesList}</td>
                </tr>`;
            }).join('');

            modal.innerHTML = `
                <div style="background:#1a1a2e;border:1px solid #444;border-radius:8px;width:90%;max-width:1000px;max-height:90vh;display:flex;flex-direction:column;overflow:hidden;">
                    <!-- Header -->
                    <div style="display:flex;justify-content:space-between;align-items:center;padding:12px 16px;border-bottom:1px solid #333;background:#16213e;">
                        <div>
                            <h3 style="margin:0;color:#4a9eff;font-size:16px;">Session Hypergraph: ${sessionId}</h3>
                            <div style="color:#888;font-size:12px;margin-top:2px;">${stats.node_count || 0} nodes • ${stats.edge_count || 0} edges</div>
                        </div>
                        <div style="display:flex;gap:8px;align-items:center;">
                            <div style="display:flex;border:1px solid #555;border-radius:4px;overflow:hidden;">
                                <button id="pcap-graph-2d-btn" style="padding:3px 10px;background:#4a9eff;border:none;color:#fff;cursor:pointer;font-size:11px;font-weight:600;">2D</button>
                                <button id="pcap-graph-3d-btn" style="padding:3px 10px;background:transparent;border:none;border-left:1px solid #555;color:#888;cursor:pointer;font-size:11px;font-weight:600;">3D</button>
                            </div>
                            <button id="pcap-graph-fullscreen-btn" title="Fullscreen" style="background:none;border:1px solid #555;color:#aaa;padding:3px 8px;border-radius:4px;cursor:pointer;font-size:13px;line-height:1;">⛶</button>
                            <button id="pcap-graph-close" style="background:none;border:1px solid #666;color:#fff;padding:4px 12px;border-radius:4px;cursor:pointer;font-size:14px;">✕</button>
                        </div>
                    </div>
                    
                    <!-- Kind Legend -->
                    <div style="padding:8px 16px;border-bottom:1px solid #333;background:rgba(255,255,255,0.02);display:flex;flex-wrap:wrap;align-items:center;">
                        ${legendHtml || '<span style="color:#888;font-size:11px;">No nodes</span>'}
                    </div>
                    
                    <!-- Canvas + Tables -->
                    <div style="flex:1;overflow-y:auto;padding:0;">
                        <!-- SVG Force Graph -->
                        <div id="pcap-graph-svg-wrap" style="padding:12px 16px;">
                            <svg id="pcap-graph-svg" width="100%" height="350" style="background:#111;border-radius:6px;border:1px solid #333;"></svg>
                        </div>
                        
                        <!-- Three.js 3D Force Graph -->
                        <div id="pcap-graph-3d-container" style="display:none;padding:12px 16px;height:370px;position:relative;background:#111;margin:0 16px;border-radius:6px;border:1px solid #333;"></div>
                        
                        <!-- Tab Switcher -->
                        <div style="display:flex;border-bottom:1px solid #333;padding:0 16px;">
                            <button class="pcap-graph-tab active" data-tab="nodes" style="padding:6px 16px;background:none;border:none;border-bottom:2px solid #4a9eff;color:#4a9eff;cursor:pointer;font-size:12px;">Nodes (${nodes.length})</button>
                            <button class="pcap-graph-tab" data-tab="edges" style="padding:6px 16px;background:none;border:none;border-bottom:2px solid transparent;color:#888;cursor:pointer;font-size:12px;">Edges (${edges.length})</button>
                        </div>
                        
                        <!-- Nodes Table -->
                        <div id="pcap-graph-nodes-tab" style="padding:0 16px 12px;">
                            <table style="width:100%;border-collapse:collapse;font-size:11px;">
                                <thead><tr style="color:#888;text-align:left;border-bottom:1px solid #444;">
                                    <th style="padding:4px 6px;">Kind</th><th style="padding:4px 6px;">ID</th><th style="padding:4px 6px;">Labels</th><th style="padding:4px 6px;">Position</th>
                                </tr></thead>
                                <tbody>${nodeRowsHtml || '<tr><td colspan="4" style="padding:8px;color:#888;">No nodes</td></tr>'}</tbody>
                            </table>
                        </div>
                        
                        <!-- Edges Table -->
                        <div id="pcap-graph-edges-tab" style="display:none;padding:0 16px 12px;">
                            <table style="width:100%;border-collapse:collapse;font-size:11px;">
                                <thead><tr style="color:#888;text-align:left;border-bottom:1px solid #444;">
                                    <th style="padding:4px 6px;">Kind</th><th style="padding:4px 6px;">ID</th><th style="padding:4px 6px;">Nodes</th>
                                </tr></thead>
                                <tbody>${edgeRowsHtml || '<tr><td colspan="3" style="padding:8px;color:#888;">No edges</td></tr>'}</tbody>
                            </table>
                        </div>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            // Close handler
            document.getElementById('pcap-graph-close').addEventListener('click', () => {
                if (window._pcapGraph3D) { window._pcapGraph3D.dispose(); window._pcapGraph3D = null; }
                modal.remove();
            });
            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    if (window._pcapGraph3D) { window._pcapGraph3D.dispose(); window._pcapGraph3D = null; }
                    modal.remove();
                }
            });
            
            // Tab switcher
            modal.querySelectorAll('.pcap-graph-tab').forEach(tab => {
                tab.addEventListener('click', () => {
                    modal.querySelectorAll('.pcap-graph-tab').forEach(t => {
                        t.classList.remove('active');
                        t.style.borderBottomColor = 'transparent';
                        t.style.color = '#888';
                    });
                    tab.classList.add('active');
                    tab.style.borderBottomColor = '#4a9eff';
                    tab.style.color = '#4a9eff';
                    document.getElementById('pcap-graph-nodes-tab').style.display = tab.dataset.tab === 'nodes' ? 'block' : 'none';
                    document.getElementById('pcap-graph-edges-tab').style.display = tab.dataset.tab === 'edges' ? 'block' : 'none';
                });
            });
            
            // ---- Render SVG Force-Directed Graph ----
            renderSessionForceGraph(nodes, edges, kindColors);
            
            // ---- 2D / 3D Toggle ----
            const btn2d = document.getElementById('pcap-graph-2d-btn');
            const btn3d = document.getElementById('pcap-graph-3d-btn');
            const svgWrap = document.getElementById('pcap-graph-svg-wrap');
            const threeDContainer = document.getElementById('pcap-graph-3d-container');
            
            btn3d.addEventListener('click', () => {
                btn2d.style.background = 'transparent'; btn2d.style.color = '#888';
                btn3d.style.background = '#4a9eff'; btn3d.style.color = '#fff';
                svgWrap.style.display = 'none';
                threeDContainer.style.display = 'block';
                if (!window._pcapGraph3D) {
                    setTimeout(() => renderSession3DGraph(nodes, edges, kindColors), 50);
                }
            });
            
            btn2d.addEventListener('click', () => {
                btn3d.style.background = 'transparent'; btn3d.style.color = '#888';
                btn2d.style.background = '#4a9eff'; btn2d.style.color = '#fff';
                threeDContainer.style.display = 'none';
                svgWrap.style.display = 'block';
            });
            
            // ---- Fullscreen Toggle ----
            const fsBtn = document.getElementById('pcap-graph-fullscreen-btn');
            const modalPanel = modal.querySelector(':scope > div'); // the inner panel
            const legendBar = modal.querySelector(':scope > div > div:nth-child(2)'); // kind legend
            const bodyArea = modal.querySelector(':scope > div > div:nth-child(3)'); // canvas+tables area
            const svgEl = document.getElementById('pcap-graph-svg');
            let isFullscreen = false;
            
            fsBtn.addEventListener('click', () => {
                isFullscreen = !isFullscreen;
                if (isFullscreen) {
                    // Expand modal panel to fill viewport
                    modalPanel.style.width = '100%';
                    modalPanel.style.maxWidth = '100%';
                    modalPanel.style.maxHeight = '100vh';
                    modalPanel.style.height = '100vh';
                    modalPanel.style.borderRadius = '0';
                    
                    // Expand graph areas
                    svgWrap.style.flex = '1';
                    svgWrap.style.display === 'none' || (svgEl.setAttribute('height', '100%'), svgWrap.style.height = '100%');
                    threeDContainer.style.height = '100%';
                    threeDContainer.style.margin = '0 16px';
                    
                    // Make body area fill remaining space
                    bodyArea.style.flex = '1';
                    bodyArea.style.display = 'flex';
                    bodyArea.style.flexDirection = 'column';
                    
                    // Hide tables to give full space to graph
                    modal.querySelectorAll('.pcap-graph-tab').forEach(t => t.parentElement.style.display = 'none');
                    document.getElementById('pcap-graph-nodes-tab').style.display = 'none';
                    document.getElementById('pcap-graph-edges-tab').style.display = 'none';
                    
                    // Re-render SVG at new size if 2D is active
                    if (svgWrap.style.display !== 'none') {
                        setTimeout(() => {
                            const r = svgWrap.getBoundingClientRect();
                            svgEl.setAttribute('height', r.height - 24);
                            svgEl.setAttribute('viewBox', `0 0 ${r.width - 32} ${r.height - 24}`);
                            renderSessionForceGraph(nodes, edges, kindColors);
                        }, 60);
                    }
                    
                    // Resize 3D if active
                    if (threeDContainer.style.display !== 'none' && window._pcapGraph3D) {
                        setTimeout(() => window.dispatchEvent(new Event('resize')), 60);
                    }
                    
                    fsBtn.textContent = '\u2716';
                    fsBtn.title = 'Exit Fullscreen';
                    fsBtn.style.color = '#4a9eff';
                } else {
                    // Restore modal panel
                    modalPanel.style.width = '90%';
                    modalPanel.style.maxWidth = '1000px';
                    modalPanel.style.maxHeight = '90vh';
                    modalPanel.style.height = '';
                    modalPanel.style.borderRadius = '8px';
                    
                    // Restore graph areas
                    svgWrap.style.flex = '';
                    svgWrap.style.height = '';
                    svgEl.setAttribute('height', '350');
                    threeDContainer.style.height = '370px';
                    threeDContainer.style.margin = '0 16px';
                    
                    // Restore body
                    bodyArea.style.flex = '1';
                    bodyArea.style.display = '';
                    bodyArea.style.flexDirection = '';
                    
                    // Show tables again
                    modal.querySelectorAll('.pcap-graph-tab').forEach(t => t.parentElement.style.display = 'flex');
                    const activeTab = modal.querySelector('.pcap-graph-tab.active');
                    if (activeTab) {
                        document.getElementById('pcap-graph-nodes-tab').style.display = activeTab.dataset.tab === 'nodes' ? 'block' : 'none';
                        document.getElementById('pcap-graph-edges-tab').style.display = activeTab.dataset.tab === 'edges' ? 'block' : 'none';
                    } else {
                        document.getElementById('pcap-graph-nodes-tab').style.display = 'block';
                    }
                    
                    // Re-render SVG at original size
                    if (svgWrap.style.display !== 'none') {
                        setTimeout(() => {
                            const r = svgWrap.getBoundingClientRect();
                            svgEl.setAttribute('viewBox', `0 0 ${r.width - 32} 350`);
                            renderSessionForceGraph(nodes, edges, kindColors);
                        }, 60);
                    }
                    
                    // Resize 3D
                    if (threeDContainer.style.display !== 'none' && window._pcapGraph3D) {
                        setTimeout(() => window.dispatchEvent(new Event('resize')), 60);
                    }
                    
                    fsBtn.textContent = '\u26F6';
                    fsBtn.title = 'Fullscreen';
                    fsBtn.style.color = '#aaa';
                }
            });
            
            // ESC key exits fullscreen first, then closes modal
            const escHandler = (e) => {
                if (e.key === 'Escape') {
                    if (isFullscreen) {
                        fsBtn.click();
                        e.stopPropagation();
                    } else {
                        if (window._pcapGraph3D) { window._pcapGraph3D.dispose(); window._pcapGraph3D = null; }
                        modal.remove();
                        document.removeEventListener('keydown', escHandler);
                    }
                }
            };
            document.addEventListener('keydown', escHandler);
            
            addConsoleMessage(`Hypergraph loaded: ${stats.node_count} nodes, ${stats.edge_count} edges`, 'success');
        } catch (e) {
            console.error('[PCAP] View graph error:', e);
            addConsoleMessage(`Failed to load graph: ${e.message}`, 'error');
        }
    }
    
    function renderSessionForceGraph(nodes, edges, kindColors) {
        const svg = document.getElementById('pcap-graph-svg');
        if (!svg || nodes.length === 0) return;
        
        const rect = svg.getBoundingClientRect();
        const W = rect.width || 960;
        const H = 350;
        svg.setAttribute('viewBox', `0 0 ${W} ${H}`);
        
        // Build adjacency from edges
        const nodeMap = {};
        nodes.forEach((n, i) => {
            nodeMap[n.id] = {
                ...n,
                idx: i,
                x: W/2 + (Math.random() - 0.5) * W * 0.6,
                y: H/2 + (Math.random() - 0.5) * H * 0.6,
                vx: 0, vy: 0
            };
        });
        
        const links = [];
        edges.forEach(e => {
            const ns = e.nodes || [];
            for (let i = 0; i < ns.length - 1; i++) {
                if (nodeMap[ns[i]] && nodeMap[ns[i+1]]) {
                    links.push({ source: nodeMap[ns[i]], target: nodeMap[ns[i+1]], kind: e.kind });
                }
            }
        });
        
        // Simple force simulation (no d3 dependency)
        const iterations = 120;
        const repulsion = 800;
        const attraction = 0.005;
        const damping = 0.92;
        const centerGravity = 0.01;
        
        const simNodes = Object.values(nodeMap);
        
        for (let iter = 0; iter < iterations; iter++) {
            // Repulsion (all pairs)
            for (let i = 0; i < simNodes.length; i++) {
                for (let j = i + 1; j < simNodes.length; j++) {
                    const a = simNodes[i], b = simNodes[j];
                    let dx = b.x - a.x, dy = b.y - a.y;
                    const dist = Math.sqrt(dx*dx + dy*dy) || 1;
                    const force = repulsion / (dist * dist);
                    const fx = (dx / dist) * force;
                    const fy = (dy / dist) * force;
                    a.vx -= fx; a.vy -= fy;
                    b.vx += fx; b.vy += fy;
                }
            }
            
            // Attraction (linked pairs)
            links.forEach(l => {
                let dx = l.target.x - l.source.x;
                let dy = l.target.y - l.source.y;
                const dist = Math.sqrt(dx*dx + dy*dy) || 1;
                const force = (dist - 60) * attraction;
                const fx = (dx / dist) * force;
                const fy = (dy / dist) * force;
                l.source.vx += fx; l.source.vy += fy;
                l.target.vx -= fx; l.target.vy -= fy;
            });
            
            // Center gravity
            simNodes.forEach(n => {
                n.vx += (W/2 - n.x) * centerGravity;
                n.vy += (H/2 - n.y) * centerGravity;
            });
            
            // Update positions
            simNodes.forEach(n => {
                n.vx *= damping;
                n.vy *= damping;
                n.x += n.vx;
                n.y += n.vy;
                // Clamp
                n.x = Math.max(20, Math.min(W - 20, n.x));
                n.y = Math.max(20, Math.min(H - 20, n.y));
            });
        }
        
        // Render SVG
        let svgContent = '';
        
        // Edges
        links.forEach(l => {
            const c = kindColors[l.kind] || '#555';
            svgContent += `<line x1="${l.source.x}" y1="${l.source.y}" x2="${l.target.x}" y2="${l.target.y}" stroke="${c}" stroke-width="1" stroke-opacity="0.4"/>`;
        });
        
        // Nodes
        simNodes.forEach(n => {
            const c = kindColors[n.kind] || '#888';
            const r = n.kind === 'pcap_session' ? 8 : n.kind === 'host' ? 6 : n.kind === 'flow_aggregate' ? 4 : 5;
            const shortId = n.id.length > 20 ? n.id.substring(0, 18) + '…' : n.id;
            svgContent += `<circle cx="${n.x}" cy="${n.y}" r="${r}" fill="${c}" stroke="#fff" stroke-width="0.5" opacity="0.9"><title>${n.kind}: ${n.id}</title></circle>`;
            // Only label key nodes
            if (['pcap_session', 'pcap_artifact', 'host'].includes(n.kind)) {
                const label = n.labels?.ip || n.labels?.name || shortId;
                svgContent += `<text x="${n.x}" y="${n.y - r - 3}" text-anchor="middle" fill="${c}" font-size="9" font-family="monospace">${label}</text>`;
            }
        });
        
        svg.innerHTML = svgContent;
    }
    
    // ========== Three.js 3D Force-Directed Graph ==========
    function renderSession3DGraph(nodes, edges, kindColors) {
        const container = document.getElementById('pcap-graph-3d-container');
        if (!container || nodes.length === 0 || !window.THREE) {
            console.warn('[3D Graph] Missing container, nodes, or THREE.js');
            return;
        }
        
        // Clean up previous instance
        if (window._pcapGraph3D) {
            window._pcapGraph3D.dispose();
            window._pcapGraph3D = null;
        }
        
        const THREE = window.THREE;
        const W = container.clientWidth || 960;
        const H = container.clientHeight || 350;
        
        // ---- Scene ----
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0a0a1a);
        scene.fog = new THREE.FogExp2(0x0a0a1a, 0.003);
        
        // ---- Camera ----
        const camera = new THREE.PerspectiveCamera(60, W / H, 0.1, 5000);
        camera.position.set(200, 150, 200);
        
        // ---- Renderer ----
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(W, H);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        container.innerHTML = '';
        container.appendChild(renderer.domElement);
        renderer.domElement.style.borderRadius = '6px';
        
        // ---- Orbit Controls ----
        let controls = null;
        if (window.ThreeOrbitControls) {
            controls = new window.ThreeOrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.1;
            controls.autoRotate = true;
            controls.autoRotateSpeed = 0.5;
            controls.minDistance = 20;
            controls.maxDistance = 2000;
        }
        
        // ---- Lights ----
        scene.add(new THREE.AmbientLight(0x6688cc, 0.4));
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.9);
        dirLight.position.set(200, 300, 200);
        scene.add(dirLight);
        const pointLight = new THREE.PointLight(0x4a9eff, 0.6, 500);
        pointLight.position.set(0, 100, 0);
        scene.add(pointLight);
        
        // ---- 3D Force Simulation ----
        const nodeMap = {};
        const N = nodes.length;
        const spread = Math.max(120, Math.sqrt(N) * 12);
        nodes.forEach((n, i) => {
            nodeMap[n.id] = {
                ...n,
                idx: i,
                x: (Math.random() - 0.5) * spread,
                y: (Math.random() - 0.5) * spread,
                z: (Math.random() - 0.5) * spread,
                vx: 0, vy: 0, vz: 0
            };
        });
        
        const links = [];
        edges.forEach(e => {
            const ns = e.nodes || [];
            for (let i = 0; i < ns.length - 1; i++) {
                if (nodeMap[ns[i]] && nodeMap[ns[i+1]]) {
                    links.push({ source: nodeMap[ns[i]], target: nodeMap[ns[i+1]], kind: e.kind });
                }
            }
        });
        
        const simNodes = Object.values(nodeMap);
        // Scale simulation params for large graphs to prevent numerical explosion
        const iterations = N > 1000 ? 80 : N > 500 ? 120 : 160;
        const repulsion = N > 1000 ? 600 : N > 500 ? 900 : 1400;
        const attraction = N > 1000 ? 0.008 : 0.004;
        const damping = N > 1000 ? 0.82 : 0.9;
        const centerGravity = N > 1000 ? 0.015 : 0.008;
        const maxForce = spread * 0.5;   // clamp individual force component
        const maxVel = spread * 0.25;    // clamp velocity component
        const posClamp = spread * 8;     // hard limit on position magnitude
        
        for (let iter = 0; iter < iterations; iter++) {
            // Repulsion (all pairs)
            for (let i = 0; i < simNodes.length; i++) {
                for (let j = i + 1; j < simNodes.length; j++) {
                    const a = simNodes[i], b = simNodes[j];
                    let dx = b.x - a.x, dy = b.y - a.y, dz = b.z - a.z;
                    const distSq = dx*dx + dy*dy + dz*dz;
                    const dist = Math.sqrt(distSq) || 1;
                    // Soft-clamp: minimum effective distance prevents force explosion
                    const effDist = Math.max(dist, 2.0);
                    let force = repulsion / (effDist * effDist);
                    if (force > maxForce) force = maxForce;
                    const fx = (dx / dist) * force;
                    const fy = (dy / dist) * force;
                    const fz = (dz / dist) * force;
                    a.vx -= fx; a.vy -= fy; a.vz -= fz;
                    b.vx += fx; b.vy += fy; b.vz += fz;
                }
            }
            
            // Attraction (linked pairs)
            links.forEach(l => {
                let dx = l.target.x - l.source.x;
                let dy = l.target.y - l.source.y;
                let dz = l.target.z - l.source.z;
                const dist = Math.sqrt(dx*dx + dy*dy + dz*dz) || 1;
                let force = (dist - 50) * attraction;
                if (Math.abs(force) > maxForce) force = Math.sign(force) * maxForce;
                const fx = (dx / dist) * force;
                const fy = (dy / dist) * force;
                const fz = (dz / dist) * force;
                l.source.vx += fx; l.source.vy += fy; l.source.vz += fz;
                l.target.vx -= fx; l.target.vy -= fy; l.target.vz -= fz;
            });
            
            // Center gravity
            simNodes.forEach(n => {
                n.vx -= n.x * centerGravity;
                n.vy -= n.y * centerGravity;
                n.vz -= n.z * centerGravity;
            });
            
            // Update positions with velocity clamp + position clamp
            simNodes.forEach(n => {
                n.vx *= damping; n.vy *= damping; n.vz *= damping;
                // Velocity clamp
                n.vx = Math.max(-maxVel, Math.min(maxVel, n.vx));
                n.vy = Math.max(-maxVel, Math.min(maxVel, n.vy));
                n.vz = Math.max(-maxVel, Math.min(maxVel, n.vz));
                n.x += n.vx; n.y += n.vy; n.z += n.vz;
                // Position clamp
                n.x = Math.max(-posClamp, Math.min(posClamp, n.x));
                n.y = Math.max(-posClamp, Math.min(posClamp, n.y));
                n.z = Math.max(-posClamp, Math.min(posClamp, n.z));
            });
        }
        
        // NaN guard: replace any NaN/Infinity positions with origin
        simNodes.forEach(n => {
            if (!isFinite(n.x)) n.x = (Math.random() - 0.5) * spread;
            if (!isFinite(n.y)) n.y = (Math.random() - 0.5) * spread;
            if (!isFinite(n.z)) n.z = (Math.random() - 0.5) * spread;
        });
        
        // ---- Groups ----
        const nodesGroup = new THREE.Group();
        const edgesGroup = new THREE.Group();
        scene.add(edgesGroup);
        scene.add(nodesGroup);
        
        // ---- Node Meshes ----
        const nodeMeshes = [];
        const kindSizes = { pcap_session: 5, pcap_artifact: 4, pcap_activity: 3.5, host: 3, geo_point: 2.5, flow_aggregate: 2 };
        
        simNodes.forEach(n => {
            const kind = n.kind || 'unknown';
            const colorHex = kindColors[kind] || '#888888';
            const color = new THREE.Color(colorHex);
            const r = kindSizes[kind] || 2;
            
            const geometry = new THREE.SphereGeometry(r, 16, 12);
            const material = new THREE.MeshStandardMaterial({
                color: color,
                emissive: color.clone().multiplyScalar(0.35),
                metalness: 0.4,
                roughness: 0.5
            });
            const mesh = new THREE.Mesh(geometry, material);
            const px = isFinite(n.x) ? n.x : 0;
            const py = isFinite(n.y) ? n.y : 0;
            const pz = isFinite(n.z) ? n.z : 0;
            mesh.position.set(px, py, pz);
            mesh.userData = { id: n.id, kind: kind, labels: n.labels };
            nodesGroup.add(mesh);
            nodeMeshes.push(mesh);
        });
        
        // ---- Edge Lines (batched LineSegments) ----
        const edgePositions = [];
        const edgeColors = [];
        links.forEach(l => {
            // Skip edges with non-finite endpoints (NaN guard)
            if (!isFinite(l.source.x) || !isFinite(l.source.y) || !isFinite(l.source.z) ||
                !isFinite(l.target.x) || !isFinite(l.target.y) || !isFinite(l.target.z)) return;
            const colorHex = kindColors[l.kind] || '#555555';
            const color = new THREE.Color(colorHex);
            edgePositions.push(l.source.x, l.source.y, l.source.z);
            edgePositions.push(l.target.x, l.target.y, l.target.z);
            edgeColors.push(color.r, color.g, color.b);
            edgeColors.push(color.r, color.g, color.b);
        });
        
        if (edgePositions.length > 0) {
            const edgeGeometry = new THREE.BufferGeometry();
            edgeGeometry.setAttribute('position', new THREE.Float32BufferAttribute(edgePositions, 3));
            edgeGeometry.setAttribute('color', new THREE.Float32BufferAttribute(edgeColors, 3));
            const edgeMaterial = new THREE.LineBasicMaterial({
                vertexColors: true,
                transparent: true,
                opacity: 0.35
            });
            edgesGroup.add(new THREE.LineSegments(edgeGeometry, edgeMaterial));
        }
        
        // ---- Glow Particles for key nodes ----
        const glowKinds = ['pcap_session', 'pcap_artifact', 'host'];
        simNodes.filter(n => glowKinds.includes(n.kind)).forEach(n => {
            const colorHex = kindColors[n.kind] || '#ffffff';
            const sprite = new THREE.Sprite(
                new THREE.SpriteMaterial({
                    color: new THREE.Color(colorHex),
                    transparent: true,
                    opacity: 0.15,
                    depthWrite: false
                })
            );
            const glowSize = (kindSizes[n.kind] || 2) * 4;
            sprite.scale.set(glowSize, glowSize, 1);
            const gx = isFinite(n.x) ? n.x : 0;
            const gy = isFinite(n.y) ? n.y : 0;
            const gz = isFinite(n.z) ? n.z : 0;
            sprite.position.set(gx, gy, gz);
            nodesGroup.add(sprite);
        });
        
        // ---- Fit Camera ----
        const box = new THREE.Box3().setFromObject(nodesGroup);
        const center = new THREE.Vector3();
        box.getCenter(center);
        const size = new THREE.Vector3();
        box.getSize(size);
        // Guard against NaN/Infinity in bounding box (can happen if all nodes are at origin)
        if (!isFinite(center.x)) center.set(0, 0, 0);
        if (!isFinite(size.x) || !isFinite(size.y) || !isFinite(size.z)) size.set(200, 200, 200);
        const maxDim = Math.max(size.x, size.y, size.z) || 100;
        const fov = camera.fov * (Math.PI / 180);
        const dist = (maxDim / 2) / Math.tan(fov / 2) * 1.6;
        
        camera.position.set(center.x + dist * 0.6, center.y + dist * 0.4, center.z + dist * 0.7);
        camera.lookAt(center);
        if (controls) {
            controls.target.copy(center);
            controls.update();
        }
        
        // ---- Raycaster Tooltip ----
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let tooltip = document.createElement('div');
        tooltip.style.cssText = 'position:absolute;display:none;background:rgba(10,10,30,0.92);color:#fff;padding:6px 10px;border-radius:4px;font-size:11px;font-family:monospace;pointer-events:none;z-index:10001;white-space:nowrap;border:1px solid #4a9eff;box-shadow:0 2px 8px rgba(74,158,255,0.3);';
        container.appendChild(tooltip);
        
        let hoveredMesh = null;
        renderer.domElement.addEventListener('mousemove', (event) => {
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(nodeMeshes);
            
            if (intersects.length > 0) {
                const obj = intersects[0].object;
                // Highlight
                if (hoveredMesh && hoveredMesh !== obj) {
                    hoveredMesh.material.emissive.copy(hoveredMesh.material.color).multiplyScalar(0.35);
                }
                hoveredMesh = obj;
                obj.material.emissive.set(0xffffff);
                
                const d = obj.userData;
                const label = d.labels?.ip || d.labels?.name || d.id;
                tooltip.innerHTML = `<span style="color:${kindColors[d.kind]||'#888'};font-weight:600;">${d.kind}</span><br>${label}`;
                tooltip.style.display = 'block';
                tooltip.style.left = (event.clientX - rect.left + 12) + 'px';
                tooltip.style.top = (event.clientY - rect.top - 30) + 'px';
                renderer.domElement.style.cursor = 'pointer';
            } else {
                if (hoveredMesh) {
                    hoveredMesh.material.emissive.copy(hoveredMesh.material.color).multiplyScalar(0.35);
                    hoveredMesh = null;
                }
                tooltip.style.display = 'none';
                renderer.domElement.style.cursor = 'grab';
            }
        });
        
        // ---- Stats Overlay ----
        const statsOverlay = document.createElement('div');
        statsOverlay.style.cssText = 'position:absolute;top:8px;left:8px;color:#4a9eff;font-size:10px;font-family:monospace;opacity:0.7;pointer-events:none;';
        statsOverlay.textContent = `${nodes.length} nodes • ${links.length} edges • Three.js r${THREE.REVISION}`;
        container.appendChild(statsOverlay);
        
        // ---- Controls hint ----
        const hint = document.createElement('div');
        hint.style.cssText = 'position:absolute;bottom:8px;right:8px;color:#666;font-size:9px;font-family:monospace;pointer-events:none;';
        hint.textContent = 'LMB: Rotate • Scroll: Zoom • RMB: Pan';
        container.appendChild(hint);
        
        // ---- Animation Loop ----
        let animId = null;
        function animate() {
            animId = requestAnimationFrame(animate);
            if (controls) controls.update();
            
            // Subtle node pulse
            const t = Date.now() * 0.001;
            nodeMeshes.forEach((m, i) => {
                const s = 1 + Math.sin(t * 2 + i * 0.1) * 0.03;
                m.scale.set(s, s, s);
            });
            
            renderer.render(scene, camera);
        }
        animate();
        
        // ---- Resize Handler ----
        const onResize = () => {
            const w = container.clientWidth;
            const h = container.clientHeight;
            if (w > 0 && h > 0) {
                camera.aspect = w / h;
                camera.updateProjectionMatrix();
                renderer.setSize(w, h);
            }
        };
        window.addEventListener('resize', onResize);
        
        // ---- Store Dispose ----
        window._pcapGraph3D = {
            dispose: () => {
                if (animId) cancelAnimationFrame(animId);
                window.removeEventListener('resize', onResize);
                if (controls) controls.dispose();
                renderer.dispose();
                scene.traverse(obj => {
                    if (obj.geometry) obj.geometry.dispose();
                    if (obj.material) {
                        if (Array.isArray(obj.material)) obj.material.forEach(m => m.dispose());
                        else obj.material.dispose();
                    }
                });
                container.innerHTML = '';
            }
        };
        
        console.log(`[3D Graph] Rendered ${nodes.length} nodes, ${links.length} edges`);
    }

    // ========================================================================
    // unbreakableFlyToPoints — nuclear camera reset + flyToBoundingSphere
    // Kills trackedEntity, resets lookAtTransform, ensures SCENE3D,
    // re-enables all ScreenSpaceCameraController inputs, then frames
    // an array of Cartesian3 positions with flyToBoundingSphere.
    // ========================================================================
    function unbreakableFlyToPoints(viewer, points, opts) {
        if (!viewer || !viewer.camera || !points || !points.length) return;
        opts = opts || {};

        // 1. Kill any tracked / selected entity (overrides camera transforms)
        try { viewer.trackedEntity = undefined; } catch (e) {}
        try { viewer.selectedEntity = undefined; } catch (e) {}

        // 2. Reset camera lookAtTransform to IDENTITY so camera is "free"
        try { viewer.camera.lookAtTransform(Cesium.Matrix4.IDENTITY); } catch (e) {}

        // 3. Ensure SCENE3D mode (Columbus / 2D can swallow flyTo)
        try {
            if (viewer.scene.mode !== Cesium.SceneMode.SCENE3D) {
                viewer.scene.mode = Cesium.SceneMode.SCENE3D;
            }
        } catch (e) {}

        // 4. Re-enable all ScreenSpaceCameraController inputs
        try {
            const ctrl = viewer.scene.screenSpaceCameraController;
            ctrl.enableRotate = true;
            ctrl.enableTilt = true;
            ctrl.enableZoom = true;
            ctrl.enableTranslate = true;
            ctrl.enableLook = true;
        } catch (e) {}

        // 5. Clear cameraLocked flag (RF Scythe global)
        window.cameraLocked = false;

        // 6. Build BoundingSphere from all points
        const bs = Cesium.BoundingSphere.fromPoints(points);

        // 7. Kick render loop (requestRenderMode compat)
        const durationMs = ((opts.duration || 2.0) * 1000) + 800;
        let kickerId = null;
        try {
            if (viewer.scene.requestRenderMode) {
                const t0 = performance.now();
                kickerId = setInterval(() => {
                    try { viewer.scene.requestRender(); } catch (e) {}
                    if (performance.now() - t0 > durationMs) {
                        clearInterval(kickerId);
                        kickerId = null;
                    }
                }, 16);
                viewer.scene.requestRender();
            }
        } catch (e) {}

        // 8. flyToBoundingSphere with HeadingPitchRange offset
        const hpr = new Cesium.HeadingPitchRange(
            Cesium.Math.toRadians(opts.heading || 0),
            opts.pitch != null ? opts.pitch : -0.85,
            opts.range || (bs.radius * 3)
        );

        viewer.camera.flyToBoundingSphere(bs, {
            duration: opts.duration || 2.0,
            offset: hpr,
            complete: function() {
                if (kickerId) { try { clearInterval(kickerId); } catch (e) {} }
                // Post-flight: re-assert freedom
                try { viewer.camera.lookAtTransform(Cesium.Matrix4.IDENTITY); } catch (e) {}
                try { viewer.trackedEntity = undefined; } catch (e) {}
                if (typeof opts.complete === 'function') opts.complete();
            },
            cancel: function() {
                if (kickerId) { try { clearInterval(kickerId); } catch (e) {} }
                if (typeof opts.cancel === 'function') opts.cancel();
            },
        });
    }
    window.unbreakableFlyToPoints = unbreakableFlyToPoints;

    // ========================================================================
    // PCAP Globe Overlay — Cesium spatial projection
    //  Modes: ports (default hub rollups), top (top talkers)
    //  Port hubs float in space around capture site
    //  Elevated geodesic arcs connect hubs to endpoints
    //  Click hub to expand/collapse top talkers
    // ========================================================================
    const PcapGlobeOverlay = {
        _state: {
            sessionId: null,
            mode: 'ports',
            entities: new Map(),
            expandedHubId: null,
            hubToEndpoints: new Map(),
            hubIndex: new Map(),
            clickHandler: null,
            data: null,
            params: null,
            topHostId: null,
        },

        clear() {
            const v = window.viewer;
            if (!v) return;
            for (const ent of this._state.entities.values()) {
                try { v.entities.remove(ent); } catch (e) {}
            }
            this._state.entities.clear();
            this._state.hubToEndpoints.clear();
            this._state.hubIndex.clear();
            this._state.expandedHubId = null;
            if (this._state.clickHandler) {
                try { this._state.clickHandler.destroy(); } catch (e) {}
                this._state.clickHandler = null;
            }
        },

        async loadSession(sessionId, opts) {
            const v = window.viewer;
            if (!v) throw new Error('Cesium viewer not initialized');

            this.clear();
            this._state.sessionId = sessionId;
            this._state.mode = (opts && opts.mode) || 'ports';

            const params = Object.assign({
                mode: 'ports',
                limit_ports: 6,
                limit_talkers: 18,
                include_tls: 1,
                include_geo: 1,
                hub_alt_m: 120000,
                hub_radius_m: 250000,
                arc_peak_alt_m: 220000,
                arc_samples: 48,
            }, opts || {});
            this._state.params = params;

            const qs = new URLSearchParams();
            Object.entries(params).forEach(([k, val]) => {
                if (val !== undefined && val !== null && val !== '') qs.set(k, String(val));
            });

            const url = `/api/pcap/${encodeURIComponent(sessionId)}/globe?${qs.toString()}`;
            const res = await fetch(url);
            if (!res.ok) throw new Error(`Globe fetch failed: HTTP ${res.status}`);
            const data = await res.json();
            if (!data.ok) throw new Error(data.message || 'Globe response not ok');
            this._state.data = data;

            this._renderPorts(v, data);
            this._installClickHandler(v);

            // Fly to capture site + all hubs using unbreakable camera (defer to next frame for entity render)
            const cap = data.capture_site;
            const flyPts = [this._cartFromLLA(cap.lat, cap.lon, 0)];
            const hubs = data.hubs || [];
            hubs.forEach((hub, i) => {
                flyPts.push(this._hubCartesian(cap, i, hubs.length, data.layout.hub_alt_m, data.layout.hub_radius_m));
            });
            
            // Ensure entities render before camera flies
            setTimeout(() => {
                if (flyPts.length > 0 && typeof unbreakableFlyToPoints === 'function') {
                    unbreakableFlyToPoints(v, flyPts, { duration: 1.8, pitch: -0.85 });
                    addConsoleMessage(`📷 Camera flying to ${hubs.length} hub${hubs.length !== 1 ? 's' : ''} near ${cap.label || 'capture site'}`, 'info');
                }
            }, 100);

            addConsoleMessage(`Globe overlay: ${hubs.length} port hubs for ${sessionId}`, 'success');
        },

        _cartFromLLA(lat, lon, altM) {
            return Cesium.Cartesian3.fromDegrees(lon, lat, altM || 0);
        },

        _hubCartesian(anchorLLA, idx, n, hubAltM, radiusM) {
            const anchor = this._cartFromLLA(anchorLLA.lat, anchorLLA.lon, anchorLLA.alt_m || 0);
            const enu = Cesium.Transforms.eastNorthUpToFixedFrame(anchor);
            const angle = (idx / Math.max(1, n)) * Math.PI * 2.0;
            const local = new Cesium.Cartesian3(
                radiusM * Math.cos(angle),
                radiusM * Math.sin(angle),
                hubAltM
            );
            return Cesium.Matrix4.multiplyByPoint(enu, local, new Cesium.Cartesian3());
        },

        _elevatedArcPositions(startCarto, endCarto, samples, peakAltM) {
            const geod = new Cesium.EllipsoidGeodesic(startCarto, endCarto);
            const out = [];
            const n = Math.max(8, Math.min(256, samples || 48));
            const h0 = startCarto.height || 0;
            const h1 = endCarto.height || 0;
            for (let i = 0; i < n; i++) {
                const t = i / (n - 1);
                const c = geod.interpolateUsingFraction(t);
                const base = h0 + (h1 - h0) * t;
                c.height = base + (peakAltM || 0) * Math.sin(Math.PI * t);
                out.push(Cesium.Ellipsoid.WGS84.cartographicToCartesian(c));
            }
            return out;
        },

        _endpointDescription(ep) {
            const esc = s => String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
            const geo = ep.geo ? `${ep.geo.country_iso||''} ${ep.geo.city||''}`.trim() : 'geo: n/a';
            const prov = ep.geo_provenance ? `(${ep.geo_provenance.geo_source||'geo'}; conf=${ep.geo_provenance.geo_confidence??'?'})` : '';
            return `<div style="font-family:ui-sans-serif,system-ui;font-size:13px;line-height:1.35;">
                <div style="font-weight:700;margin-bottom:6px;">${esc(ep.ip)} (${esc(ep.role)})</div>
                <div><b>bytes</b>: ${ep.bytes_total?.toLocaleString()} &nbsp; <b>flows</b>: ${ep.flows}</div>
                <div><b>geo</b>: ${esc(geo)} ${esc(prov)}</div>
            </div>`;
        },

        _renderPorts(viewer, data) {
            const capture = data.capture_site;
            const layout = data.layout;

            // Capture anchor point
            const anchorId = `pcapAnchor:${data.session.session_id}`;
            const anchorEnt = viewer.entities.add({
                id: anchorId,
                position: this._cartFromLLA(capture.lat, capture.lon, capture.alt_m || 0),
                point: { pixelSize: 10, color: Cesium.Color.WHITE.withAlpha(0.85), outlineWidth: 2, outlineColor: Cesium.Color.BLACK },
                label: {
                    text: capture.label || 'PCAP Capture',
                    font: '14px sans-serif',
                    fillColor: Cesium.Color.WHITE,
                    outlineColor: Cesium.Color.BLACK,
                    outlineWidth: 2,
                    style: Cesium.LabelStyle.FILL_AND_OUTLINE,
                    pixelOffset: new Cesium.Cartesian2(0, -18),
                    distanceDisplayCondition: new Cesium.DistanceDisplayCondition(0.0, 15000000.0),
                },
            });
            this._state.entities.set(anchorId, anchorEnt);

            // Dashed line from ground to each hub
            const hubs = data.hubs || [];
            const n = hubs.length;

            hubs.forEach((hub, i) => {
                const hubPos = this._hubCartesian(capture, i, n, layout.hub_alt_m, layout.hub_radius_m);
                const hubId = `pcapHub:${hub.hub_id}`;

                const sev = Math.max(0, Math.min(1, hub.scanner_like_p95 ?? 0));
                const hubColor = sev > 0.85 ? Cesium.Color.RED.withAlpha(0.85) :
                                 sev > 0.55 ? Cesium.Color.ORANGE.withAlpha(0.85) :
                                 Cesium.Color.CYAN.withAlpha(0.85);

                const hubEnt = viewer.entities.add({
                    id: hubId,
                    position: hubPos,
                    point: { pixelSize: 14, color: hubColor, outlineWidth: 2, outlineColor: Cesium.Color.BLACK },
                    label: {
                        text: `${hub.proto}:${hub.port}  (${hub.flow_count} flows)`,
                        font: '13px monospace',
                        fillColor: Cesium.Color.WHITE,
                        outlineColor: Cesium.Color.BLACK,
                        outlineWidth: 2,
                        style: Cesium.LabelStyle.FILL_AND_OUTLINE,
                        pixelOffset: new Cesium.Cartesian2(0, -22),
                        distanceDisplayCondition: new Cesium.DistanceDisplayCondition(0.0, 25000000.0),
                    },
                    properties: {
                        __pcap_kind: 'hub',
                        hub_id: hub.hub_id,
                        proto: hub.proto,
                        port: hub.port,
                    },
                });
                this._state.entities.set(hubId, hubEnt);
                this._state.hubToEndpoints.set(hub.hub_id, hub.top_talkers || []);
                this._state.hubIndex.set(hub.hub_id, { hub, hubPos });

                // Vertical tether from anchor up to hub
                const anchorCart = this._cartFromLLA(capture.lat, capture.lon, capture.alt_m || 0);
                const tetherId = `pcapTether:${hub.hub_id}`;
                const tetherEnt = viewer.entities.add({
                    id: tetherId,
                    polyline: {
                        positions: [anchorCart, hubPos],
                        width: 1,
                        material: new Cesium.PolylineDashMaterialProperty({
                            color: hubColor.withAlpha(0.3),
                            dashLength: 12,
                        }),
                        arcType: Cesium.ArcType.NONE,
                    },
                });
                this._state.entities.set(tetherId, tetherEnt);
            });
        },

        async _expandHub(viewer, hub_id) {
            if (this._state.expandedHubId && this._state.expandedHubId !== hub_id) {
                this._collapseHub(viewer, this._state.expandedHubId);
            }

            const hubInfo = this._state.hubIndex.get(hub_id);
            if (!hubInfo) return;
            const { hub, hubPos } = hubInfo;
            const data = this._state.data;
            const layout = data.layout;

            let endpoints = this._state.hubToEndpoints.get(hub_id) || [];

            // Optionally re-fetch with port filter for deeper drill-down
            try {
                const params = this._state.params || {};
                const qs = new URLSearchParams();
                qs.set('mode', 'ports');
                qs.set('port', String(hub.port));
                qs.set('proto', hub.proto.toLowerCase());
                qs.set('limit_ports', '1');
                qs.set('limit_talkers', String(params.limit_talkers || 20));
                const r = await fetch(`/api/pcap/${encodeURIComponent(data.session.session_id)}/globe?${qs.toString()}`);
                if (r.ok) {
                    const d = await r.json();
                    if (d.ok && d.hubs && d.hubs.length) {
                        endpoints = d.hubs[0].top_talkers || endpoints;
                        this._state.hubToEndpoints.set(hub_id, endpoints);
                    }
                }
            } catch (e) { /* use cached */ }

            const hubCarto = Cesium.Ellipsoid.WGS84.cartesianToCartographic(hubPos);

            endpoints.forEach((ep) => {
                if (!ep.geo || ep.geo.lat == null || ep.geo.lon == null) return;

                const epId = `pcapHost:${hub_id}:${ep.endpoint_id}`;
                const epPos = this._cartFromLLA(ep.geo.lat, ep.geo.lon, 1500);

                const sc = Math.max(0, Math.min(1, ep.scanner_like_mean ?? 0));
                const epColor = sc > 0.85 ? Cesium.Color.RED.withAlpha(0.8) :
                                sc > 0.55 ? Cesium.Color.YELLOW.withAlpha(0.8) :
                                Cesium.Color.LIME.withAlpha(0.7);

                const hostEnt = viewer.entities.add({
                    id: epId,
                    position: epPos,
                    point: { pixelSize: 7, color: epColor, outlineWidth: 1, outlineColor: Cesium.Color.BLACK },
                    label: {
                        text: ep.ip,
                        font: '12px monospace',
                        fillColor: Cesium.Color.WHITE,
                        outlineColor: Cesium.Color.BLACK,
                        outlineWidth: 2,
                        style: Cesium.LabelStyle.FILL_AND_OUTLINE,
                        pixelOffset: new Cesium.Cartesian2(10, 0),
                        distanceDisplayCondition: new Cesium.DistanceDisplayCondition(0.0, 15000000.0),
                    },
                    description: this._endpointDescription(ep),
                    properties: {
                        __pcap_kind: 'endpoint',
                        hub_id: hub_id,
                        endpoint_id: ep.endpoint_id,
                        ip: ep.ip,
                    },
                });
                this._state.entities.set(epId, hostEnt);

                // Elevated arc from hub to endpoint
                const endCarto = Cesium.Cartographic.fromDegrees(ep.geo.lon, ep.geo.lat, 1500);
                const positions = this._elevatedArcPositions(hubCarto, endCarto, layout.arc_samples, layout.arc_peak_alt_m);
                const arcWidth = 2 + Math.min(6, Math.log10(1 + (ep.bytes_total || 0)) * 1.2);

                const arcId = `pcapArc:${hub_id}:${ep.endpoint_id}`;
                const arcEnt = viewer.entities.add({
                    id: arcId,
                    polyline: {
                        positions: positions,
                        width: arcWidth,
                        arcType: Cesium.ArcType.NONE,
                        material: epColor.withAlpha(0.55),
                    },
                    properties: {
                        __pcap_kind: 'arc',
                        hub_id: hub_id,
                        endpoint_id: ep.endpoint_id,
                        bytes_total: ep.bytes_total || 0,
                    },
                });
                this._state.entities.set(arcId, arcEnt);
            });

            this._state.expandedHubId = hub_id;

            // Fly to hub + endpoints using unbreakable camera
            const flyPts = [hubPos];
            const capSite = data.capture_site;
            if (capSite) flyPts.push(this._cartFromLLA(capSite.lat, capSite.lon, 0));
            endpoints.forEach((ep) => {
                if (ep.geo && ep.geo.lat != null && ep.geo.lon != null) {
                    flyPts.push(this._cartFromLLA(ep.geo.lat, ep.geo.lon, 1500));
                }
            });
            unbreakableFlyToPoints(viewer, flyPts, { duration: 1.2, pitch: -0.85 });

            addConsoleMessage(`Expanded hub ${hub.proto}:${hub.port} — ${endpoints.length} endpoints`, 'info');
        },

        _collapseHub(viewer, hub_id) {
            const toRemove = [];
            for (const [id, ent] of this._state.entities.entries()) {
                if (id.startsWith(`pcapHost:${hub_id}:`) || id.startsWith(`pcapArc:${hub_id}:`)) {
                    toRemove.push([id, ent]);
                }
            }
            toRemove.forEach(([id, ent]) => {
                try { viewer.entities.remove(ent); } catch (e) {}
                this._state.entities.delete(id);
            });
            if (this._state.expandedHubId === hub_id) this._state.expandedHubId = null;
        },

        _installClickHandler(viewer) {
            const handler = new Cesium.ScreenSpaceEventHandler(viewer.scene.canvas);
            this._state.clickHandler = handler;
            const self = this;

            handler.setInputAction(async (click) => {
                const picked = viewer.scene.pick(click.position);
                if (!picked || !picked.id) return;

                const entId = (typeof picked.id === 'object' && picked.id.id) ? picked.id.id : String(picked.id);

                // Hub click → expand/collapse
                if (entId.startsWith('pcapHub:')) {
                    const hid = entId.replace('pcapHub:', '');
                    if (self._state.expandedHubId === hid) {
                        self._collapseHub(viewer, hid);
                    } else {
                        await self._expandHub(viewer, hid);
                    }
                    return;
                }

                // Arc click → highlight pulse
                if (entId.startsWith('pcapArc:')) {
                    const ent = self._state.entities.get(entId);
                    if (ent && ent.polyline) {
                        const origW = ent.polyline.width?.getValue ? ent.polyline.width.getValue(Cesium.JulianDate.now()) : 3;
                        ent.polyline.width = 8;
                        setTimeout(() => { try { ent.polyline.width = origW; } catch (e) {} }, 1200);
                    }
                    return;
                }

                // Endpoint click → fly closer + open InfoBox
                if (entId.startsWith('pcapHost:')) {
                    const ent = self._state.entities.get(entId);
                    if (ent) {
                        viewer.selectedEntity = ent;
                        const pos = ent.position?.getValue ? ent.position.getValue(Cesium.JulianDate.now()) : ent.position;
                        if (pos) {
                            unbreakableFlyToPoints(viewer, [pos], { duration: 1.1, pitch: -0.6, range: 800000 });
                        }
                    }
                    return;
                }
            }, Cesium.ScreenSpaceEventType.LEFT_CLICK);
        },
    };

    window.PcapGlobeOverlay = PcapGlobeOverlay;
})();
</script>

</body>
</html>
